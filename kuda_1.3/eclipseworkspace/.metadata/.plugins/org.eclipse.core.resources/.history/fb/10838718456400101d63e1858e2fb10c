/**
 * 
 */

var lgb = (function(hvac) {
	
		
	
	/**
	 * The version of LGB released
	 * @constant
	 */
	lgb.version = '0.1';
	
	
	/**
	 * @class A Loader to get all the 3d content and init the GUI
	 */
	lgb.Loader = function() {


		this.theModel = null;
		this.msgHandler = null;
		this.count = 0; // Counter to keep track of wall opacity
		this.dir = 1; // Whether wall is becoming more or less opaque
		
	};
	
	
	lgb.Loader.prototype = {
			filePath : 'scene.json;',

			init: function(clientElement) {
				hemi.core.init(clientElements[0]);
				hemi.view.setBGColor([0.8, 0.8, 0.8, 1]);
				this.createWorld();
			},
	
			
			createWorld: function() {
				this.theModel = new hemi.model.Model();	// Create a new Model
				
				hemi.world.subscribe(hemi.msg.ready,
					function(msg) {
						this.setupScene();
					});
				
				theModel.setFileName(filePath); // Set the model file
				hemi.world.ready();   // Indicate that we are ready to start our script
			},
			
	
			setupScene: function() {
				var transformList = theModel.getTransforms('Mesh_033');
				var transform = transformList[0];
				
				var theMaterial = transform.shapes[0].elements[0].material;
				
				var drawList = theMaterial.getParam('o3d.drawList').value;
				var zdrawList = hemi.view.viewInfo.zOrderedDrawList;
				
				theMaterial.getParam('o3d.drawList').value = zdrawList;
				
				var theMaterialOpacity = hemi.fx.addOpacity(theMaterial);
				theMaterialOpacity.value = 1.0;
				
				/* Create a transform-level opacity paramater that will override the
				 * material-level opacity parameter. That way, we can make this wall
				 * fade without fading every object that uses the wall material.
				 */
				var opacity = transform.createParam('opacity','ParamFloat');
				opacity.value = 1.0;
				
				/* On any keyDown, begin the fading. Reverse the direction each time */

					
				/* Fade the wall a little more on each frame, between 1 and 0.4 */
				hemi.view.addRenderListener({
					onRender : function(e) {
						if (count > 0) {
							opacity.value += dir*0.02;
							count--;
						}
					}});
				
				
				var vp = new hemi.view.Viewpoint();		// Create a new Viewpoint
				vp.eye = [-56,61,39];					// Set viewpoint eye
				vp.target = [0,10,0];					// Set viewpoint target
			//	vp.fov = 52;
				/**
				 * Move the camera from it's default position (eye : [0,0,-1],
				 *		target : [0,0,0]} to the new viewpoint, and take 120
				 *		render cycles (~2 seconds) to do so.
				 */
				
				//hemi.console.addToPage();
				//trace (hemi.version);
				console.log("kuda version: %s", hemi.version);
				
				hemi.world.camera.enableControl();	// Enable camera mouse control
				hemi.model.modelRoot.rotateX(4.72);
				
				
				msgHandler = hemi.world.camera.subscribe(
						hemi.msg.stop,
						onCameraMoved);
				
				
				hemi.world.camera.moveToView(vp,40);
			},
				
			onCameraMoved: function(msg) {
				var result = hemi.world.camera.unsubscribe(msgHandler, hemi.msg.stop);
				onWorldSetup();
			},
			
			
			leftNavClick: function(buttonNumber) {
				switch(buttonNumber)
				{
					case 0:
						
						if (count == 0) {
							count = 40;
							dir = -dir;
						} 
						
					  break;
					case 1:
			
					  break;
					default:
			
					}
			}	
			
			
			
			
			
	};
	

	
	return lgb;
	
})(lgb || {});