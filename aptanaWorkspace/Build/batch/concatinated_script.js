// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Bootstrap for the Google JS Library (Closure).
 *
 * In uncompiled mode base.js will write out Closure's deps file, unless the
 * global <code>CLOSURE_NO_DEPS</code> is set to true.  This allows projects to
 * include their own deps file(s) from different locations.
 *
 *
 * @provideGoog
 */


/**
 * @define {boolean} Overridden to true by the compiler when --closure_pass
 *     or --mark_as_compiled is specified.
 */
var COMPILED = false;


/**
 * Base namespace for the Closure library.  Checks to see goog is already
 * defined in the current scope before assigning to prevent clobbering if
 * base.js is loaded more than once.
 *
 * @const
 */
var goog = goog || {};


/**
 * Reference to the global context.  In most cases this will be 'window'.
 */
goog.global = this;


/**
 * A hook for overriding the define values in uncompiled mode.
 *
 * In uncompiled mode, {@code CLOSURE_UNCOMPILED_DEFINES} may be defined before
 * loading base.js.  If a key is defined in {@code CLOSURE_UNCOMPILED_DEFINES},
 * {@code goog.define} will use the value instead of the default value.  This
 * allows flags to be overwritten without compilation (this is normally
 * accomplished with the compiler's "define" flag).
 *
 * Example:
 * <pre>
 *   var CLOSURE_UNCOMPILED_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object.<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_UNCOMPILED_DEFINES;


/**
 * A hook for overriding the define values in uncompiled or compiled mode,
 * like CLOSURE_UNCOMPILED_DEFINES but effective in compiled code.  In
 * uncompiled code CLOSURE_UNCOMPILED_DEFINES takes precedence.
 *
 * Also unlike CLOSURE_UNCOMPILED_DEFINES the values must be number, boolean or
 * string literals or the compiler will emit an error.
 *
 * While any @define value may be set, only those set with goog.define will be
 * effective for uncompiled code.
 *
 * Example:
 * <pre>
 *   var CLOSURE_DEFINES = {'goog.DEBUG': false};
 * </pre>
 *
 * @type {Object.<string, (string|number|boolean)>|undefined}
 */
goog.global.CLOSURE_DEFINES;


/**
 * Returns true if the specified value is not undefined.
 * WARNING: Do not use this to test if an object has a property. Use the in
 * operator instead.
 *
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined.
 */
goog.isDef = function(val) {
  // void 0 always evaluates to undefined and hence we do not need to depend on
  // the definition of the global variable named 'undefined'.
  return val !== void 0;
};


/**
 * Builds an object structure for the provided namespace path, ensuring that
 * names that already exist are not overwritten. For example:
 * "a.b.c" -> a = {};a.b={};a.b.c={};
 * Used by goog.provide and goog.exportSymbol.
 * @param {string} name name of the object that this file defines.
 * @param {*=} opt_object the object to expose at the end of the path.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is |goog.global|.
 * @private
 */
goog.exportPath_ = function(name, opt_object, opt_objectToExportTo) {
  var parts = name.split('.');
  var cur = opt_objectToExportTo || goog.global;

  // Internet Explorer exhibits strange behavior when throwing errors from
  // methods externed in this manner.  See the testExportSymbolExceptions in
  // base_test.html for an example.
  if (!(parts[0] in cur) && cur.execScript) {
    cur.execScript('var ' + parts[0]);
  }

  // Certain browsers cannot parse code in the form for((a in b); c;);
  // This pattern is produced by the JSCompiler when it collapses the
  // statement above into the conditional loop below. To prevent this from
  // happening, use a for-loop and reserve the init logic as below.

  // Parentheses added to eliminate strict JS warning in Firefox.
  for (var part; parts.length && (part = parts.shift());) {
    if (!parts.length && goog.isDef(opt_object)) {
      // last part and we have an object; use it
      cur[part] = opt_object;
    } else if (cur[part]) {
      cur = cur[part];
    } else {
      cur = cur[part] = {};
    }
  }
};


/**
 * Defines a named value. In uncompiled mode, the value is retreived from
 * CLOSURE_DEFINES or CLOSURE_UNCOMPILED_DEFINES if the object is defined and
 * has the property specified, and otherwise used the defined defaultValue.
 * When compiled, the default can be overridden using compiler command-line
 * options.
 *
 * @param {string} name The distinguished name to provide.
 * @param {string|number|boolean} defaultValue
 */
goog.define = function(name, defaultValue) {
  var value = defaultValue;
  if (!COMPILED) {
    if (goog.global.CLOSURE_UNCOMPILED_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_UNCOMPILED_DEFINES, name)) {
      value = goog.global.CLOSURE_UNCOMPILED_DEFINES[name];
    } else if (goog.global.CLOSURE_DEFINES &&
        Object.prototype.hasOwnProperty.call(
            goog.global.CLOSURE_DEFINES, name)) {
      value = goog.global.CLOSURE_DEFINES[name];
    }
  }
  goog.exportPath_(name, value);
};


/**
 * @define {boolean} DEBUG is provided as a convenience so that debugging code
 * that should not be included in a production js_binary can be easily stripped
 * by specifying --define goog.DEBUG=false to the JSCompiler. For example, most
 * toString() methods should be declared inside an "if (goog.DEBUG)" conditional
 * because they are generally used for debugging purposes and it is difficult
 * for the JSCompiler to statically determine whether they are used.
 */
goog.DEBUG = true;


/**
 * @define {string} LOCALE defines the locale being used for compilation. It is
 * used to select locale specific data to be compiled in js binary. BUILD rule
 * can specify this value by "--define goog.LOCALE=<locale_name>" as JSCompiler
 * option.
 *
 * Take into account that the locale code format is important. You should use
 * the canonical Unicode format with hyphen as a delimiter. Language must be
 * lowercase, Language Script - Capitalized, Region - UPPERCASE.
 * There are few examples: pt-BR, en, en-US, sr-Latin-BO, zh-Hans-CN.
 *
 * See more info about locale codes here:
 * http://www.unicode.org/reports/tr35/#Unicode_Language_and_Locale_Identifiers
 *
 * For language codes you should use values defined by ISO 693-1. See it here
 * http://www.w3.org/WAI/ER/IG/ert/iso639.htm. There is only one exception from
 * this rule: the Hebrew language. For legacy reasons the old code (iw) should
 * be used instead of the new code (he), see http://wiki/Main/IIISynonyms.
 */
goog.define('goog.LOCALE', 'en');  // default to en


/**
 * @define {boolean} Whether this code is running on trusted sites.
 *
 * On untrusted sites, several native functions can be defined or overridden by
 * external libraries like Prototype, Datejs, and JQuery and setting this flag
 * to false forces closure to use its own implementations when possible.
 *
 * If your JavaScript can be loaded by a third party site and you are wary about
 * relying on non-standard implementations, specify
 * "--define goog.TRUSTED_SITE=false" to the JSCompiler.
 */
goog.define('goog.TRUSTED_SITE', true);


/**
 * @define {boolean} Whether a project is expected to be running in strict mode.
 *
 * This define can be used to trigger alternate implementations compatible with
 * running in EcmaScript Strict mode or warn about unavailable functionality.
 * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode
 */
goog.define('goog.STRICT_MODE_COMPATIBLE', false);


/**
 * Creates object stubs for a namespace.  The presence of one or more
 * goog.provide() calls indicate that the file defines the given
 * objects/namespaces.  Provided objects must not be null or undefined.
 * Build tools also scan for provide/require statements
 * to discern dependencies, build dependency files (see deps.js), etc.
 * @see goog.require
 * @param {string} name Namespace provided by this file in the form
 *     "goog.package.part".
 */
goog.provide = function(name) {
  if (!COMPILED) {
    // Ensure that the same namespace isn't provided twice. This is intended
    // to teach new developers that 'goog.provide' is effectively a variable
    // declaration. And when JSCompiler transforms goog.provide into a real
    // variable declaration, the compiled JS should work the same as the raw
    // JS--even when the raw JS uses goog.provide incorrectly.
    if (goog.isProvided_(name)) {
      throw Error('Namespace "' + name + '" already declared.');
    }
    delete goog.implicitNamespaces_[name];

    var namespace = name;
    while ((namespace = namespace.substring(0, namespace.lastIndexOf('.')))) {
      if (goog.getObjectByName(namespace)) {
        break;
      }
      goog.implicitNamespaces_[namespace] = true;
    }
  }

  goog.exportPath_(name);
};


/**
 * Marks that the current file should only be used for testing, and never for
 * live code in production.
 *
 * In the case of unit tests, the message may optionally be an exact namespace
 * for the test (e.g. 'goog.stringTest'). The linter will then ignore the extra
 * provide (if not explicitly defined in the code).
 *
 * @param {string=} opt_message Optional message to add to the error that's
 *     raised when used in production code.
 */
goog.setTestOnly = function(opt_message) {
  if (COMPILED && !goog.DEBUG) {
    opt_message = opt_message || '';
    throw Error('Importing test-only code into non-debug environment' +
                (opt_message ? ': ' + opt_message : '.'));
  }
};


/**
 * Forward declares a symbol. This is an indication to the compiler that the
 * symbol may be used in the source yet is not required and may not be provided
 * in compilation.
 *
 * The most common usage of forward declaration is code that takes a type as a
 * function parameter but does not need to require it. By forward declaring
 * instead of requiring, no hard dependency is made, and (if not required
 * elsewhere) the namespace may never be required and thus, not be pulled
 * into the JavaScript binary. If it is required elsewhere, it will be type
 * checked as normal.
 *
 *
 * @param {string} name The namespace to forward declare in the form of
 *     "goog.package.part".
 */
goog.forwardDeclare = function(name) {};


if (!COMPILED) {

  /**
   * Check if the given name has been goog.provided. This will return false for
   * names that are available only as implicit namespaces.
   * @param {string} name name of the object to look for.
   * @return {boolean} Whether the name has been provided.
   * @private
   */
  goog.isProvided_ = function(name) {
    return !goog.implicitNamespaces_[name] &&
        goog.isDefAndNotNull(goog.getObjectByName(name));
  };

  /**
   * Namespaces implicitly defined by goog.provide. For example,
   * goog.provide('goog.events.Event') implicitly declares that 'goog' and
   * 'goog.events' must be namespaces.
   *
   * @type {Object}
   * @private
   */
  goog.implicitNamespaces_ = {};
}


/**
 * Returns an object based on its fully qualified external name.  The object
 * is not found if null or undefined.  If you are using a compilation pass that
 * renames property names beware that using this function will not find renamed
 * properties.
 *
 * @param {string} name The fully qualified name.
 * @param {Object=} opt_obj The object within which to look; default is
 *     |goog.global|.
 * @return {?} The value (object or primitive) or, if not found, null.
 */
goog.getObjectByName = function(name, opt_obj) {
  var parts = name.split('.');
  var cur = opt_obj || goog.global;
  for (var part; part = parts.shift(); ) {
    if (goog.isDefAndNotNull(cur[part])) {
      cur = cur[part];
    } else {
      return null;
    }
  }
  return cur;
};


/**
 * Globalizes a whole namespace, such as goog or goog.lang.
 *
 * @param {Object} obj The namespace to globalize.
 * @param {Object=} opt_global The object to add the properties to.
 * @deprecated Properties may be explicitly exported to the global scope, but
 *     this should no longer be done in bulk.
 */
goog.globalize = function(obj, opt_global) {
  var global = opt_global || goog.global;
  for (var x in obj) {
    global[x] = obj[x];
  }
};


/**
 * Adds a dependency from a file to the files it requires.
 * @param {string} relPath The path to the js file.
 * @param {Array} provides An array of strings with the names of the objects
 *                         this file provides.
 * @param {Array} requires An array of strings with the names of the objects
 *                         this file requires.
 */
goog.addDependency = function(relPath, provides, requires) {
  if (goog.DEPENDENCIES_ENABLED) {
    var provide, require;
    var path = relPath.replace(/\\/g, '/');
    var deps = goog.dependencies_;
    for (var i = 0; provide = provides[i]; i++) {
      deps.nameToPath[provide] = path;
      if (!(path in deps.pathToNames)) {
        deps.pathToNames[path] = {};
      }
      deps.pathToNames[path][provide] = true;
    }
    for (var j = 0; require = requires[j]; j++) {
      if (!(path in deps.requires)) {
        deps.requires[path] = {};
      }
      deps.requires[path][require] = true;
    }
  }
};




// NOTE(nnaze): The debug DOM loader was included in base.js as an original way
// to do "debug-mode" development.  The dependency system can sometimes be
// confusing, as can the debug DOM loader's asynchronous nature.
//
// With the DOM loader, a call to goog.require() is not blocking -- the script
// will not load until some point after the current script.  If a namespace is
// needed at runtime, it needs to be defined in a previous script, or loaded via
// require() with its registered dependencies.
// User-defined namespaces may need their own deps file.  See http://go/js_deps,
// http://go/genjsdeps, or, externally, DepsWriter.
// https://developers.google.com/closure/library/docs/depswriter
//
// Because of legacy clients, the DOM loader can't be easily removed from
// base.js.  Work is being done to make it disableable or replaceable for
// different environments (DOM-less JavaScript interpreters like Rhino or V8,
// for example). See bootstrap/ for more information.


/**
 * @define {boolean} Whether to enable the debug loader.
 *
 * If enabled, a call to goog.require() will attempt to load the namespace by
 * appending a script tag to the DOM (if the namespace has been registered).
 *
 * If disabled, goog.require() will simply assert that the namespace has been
 * provided (and depend on the fact that some outside tool correctly ordered
 * the script).
 */
goog.define('goog.ENABLE_DEBUG_LOADER', true);


/**
 * Implements a system for the dynamic resolution of dependencies that works in
 * parallel with the BUILD system. Note that all calls to goog.require will be
 * stripped by the JSCompiler when the --closure_pass option is used.
 * @see goog.provide
 * @param {string} name Namespace to include (as was given in goog.provide()) in
 *     the form "goog.package.part".
 */
goog.require = function(name) {

  // If the object already exists we do not need do do anything.
  // TODO(arv): If we start to support require based on file name this has to
  //            change.
  // TODO(arv): If we allow goog.foo.* this has to change.
  // TODO(arv): If we implement dynamic load after page load we should probably
  //            not remove this code for the compiled output.
  if (!COMPILED) {
    if (goog.isProvided_(name)) {
      return;
    }

    if (goog.ENABLE_DEBUG_LOADER) {
      var path = goog.getPathFromDeps_(name);
      if (path) {
        goog.included_[path] = true;
        goog.writeScripts_();
        return;
      }
    }

    var errorMessage = 'goog.require could not find: ' + name;
    if (goog.global.console) {
      goog.global.console['error'](errorMessage);
    }


      throw Error(errorMessage);

  }
};


/**
 * Path for included scripts.
 * @type {string}
 */
goog.basePath = '';


/**
 * A hook for overriding the base path.
 * @type {string|undefined}
 */
goog.global.CLOSURE_BASE_PATH;


/**
 * Whether to write out Closure's deps file. By default, the deps are written.
 * @type {boolean|undefined}
 */
goog.global.CLOSURE_NO_DEPS;


/**
 * A function to import a single script. This is meant to be overridden when
 * Closure is being run in non-HTML contexts, such as web workers. It's defined
 * in the global scope so that it can be set before base.js is loaded, which
 * allows deps.js to be imported properly.
 *
 * The function is passed the script source, which is a relative URI. It should
 * return true if the script was imported, false otherwise.
 * @type {(function(string): boolean)|undefined}
 */
goog.global.CLOSURE_IMPORT_SCRIPT;


/**
 * Null function used for default values of callbacks, etc.
 * @return {void} Nothing.
 */
goog.nullFunction = function() {};


/**
 * The identity function. Returns its first argument.
 *
 * @param {*=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {?} The first argument. We can't know the type -- just pass it along
 *      without type.
 * @deprecated Use goog.functions.identity instead.
 */
goog.identityFunction = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * When defining a class Foo with an abstract method bar(), you can do:
 * Foo.prototype.bar = goog.abstractMethod
 *
 * Now if a subclass of Foo fails to override bar(), an error will be thrown
 * when bar() is invoked.
 *
 * Note: This does not take the name of the function to override as an argument
 * because that would make it more difficult to obfuscate our JavaScript code.
 *
 * @type {!Function}
 * @throws {Error} when invoked to indicate the method should be overridden.
 */
goog.abstractMethod = function() {
  throw Error('unimplemented abstract method');
};


/**
 * Adds a {@code getInstance} static method that always returns the same
 * instance object.
 * @param {!Function} ctor The constructor for the class to add the static
 *     method to.
 */
goog.addSingletonGetter = function(ctor) {
  ctor.getInstance = function() {
    if (ctor.instance_) {
      return ctor.instance_;
    }
    if (goog.DEBUG) {
      // NOTE: JSCompiler can't optimize away Array#push.
      goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = ctor;
    }
    return ctor.instance_ = new ctor;
  };
};


/**
 * All singleton classes that have been instantiated, for testing. Don't read
 * it directly, use the {@code goog.testing.singleton} module. The compiler
 * removes this variable if unused.
 * @type {!Array.<!Function>}
 * @private
 */
goog.instantiatedSingletons_ = [];


/**
 * True if goog.dependencies_ is available.
 * @const {boolean}
 */
goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;


if (goog.DEPENDENCIES_ENABLED) {
  /**
   * Object used to keep track of urls that have already been added. This record
   * allows the prevention of circular dependencies.
   * @type {Object}
   * @private
   */
  goog.included_ = {};


  /**
   * This object is used to keep track of dependencies and other data that is
   * used for loading scripts.
   * @private
   * @type {Object}
   */
  goog.dependencies_ = {
    pathToNames: {}, // 1 to many
    nameToPath: {}, // 1 to 1
    requires: {}, // 1 to many
    // Used when resolving dependencies to prevent us from visiting file twice.
    visited: {},
    written: {} // Used to keep track of script files we have written.
  };


  /**
   * Tries to detect whether is in the context of an HTML document.
   * @return {boolean} True if it looks like HTML document.
   * @private
   */
  goog.inHtmlDocument_ = function() {
    var doc = goog.global.document;
    return typeof doc != 'undefined' &&
           'write' in doc;  // XULDocument misses write.
  };


  /**
   * Tries to detect the base path of base.js script that bootstraps Closure.
   * @private
   */
  goog.findBasePath_ = function() {
    if (goog.global.CLOSURE_BASE_PATH) {
      goog.basePath = goog.global.CLOSURE_BASE_PATH;
      return;
    } else if (!goog.inHtmlDocument_()) {
      return;
    }
    var doc = goog.global.document;
    var scripts = doc.getElementsByTagName('script');
    // Search backwards since the current script is in almost all cases the one
    // that has base.js.
    for (var i = scripts.length - 1; i >= 0; --i) {
      var src = scripts[i].src;
      var qmark = src.lastIndexOf('?');
      var l = qmark == -1 ? src.length : qmark;
      if (src.substr(l - 7, 7) == 'base.js') {
        goog.basePath = src.substr(0, l - 7);
        return;
      }
    }
  };


  /**
   * Imports a script if, and only if, that script hasn't already been imported.
   * (Must be called at execution time)
   * @param {string} src Script source.
   * @private
   */
  goog.importScript_ = function(src) {
    var importScript = goog.global.CLOSURE_IMPORT_SCRIPT ||
        goog.writeScriptTag_;
    if (!goog.dependencies_.written[src] && importScript(src)) {
      goog.dependencies_.written[src] = true;
    }
  };


  /**
   * The default implementation of the import function. Writes a script tag to
   * import the script.
   *
   * @param {string} src The script source.
   * @return {boolean} True if the script was imported, false otherwise.
   * @private
   */
  goog.writeScriptTag_ = function(src) {
    if (goog.inHtmlDocument_()) {
      var doc = goog.global.document;

      // If the user tries to require a new symbol after document load,
      // something has gone terribly wrong. Doing a document.write would
      // wipe out the page.
      if (doc.readyState == 'complete') {
        // Certain test frameworks load base.js multiple times, which tries
        // to write deps.js each time. If that happens, just fail silently.
        // These frameworks wipe the page between each load of base.js, so this
        // is OK.
        var isDeps = /\bdeps.js$/.test(src);
        if (isDeps) {
          return false;
        } else {
          throw Error('Cannot write "' + src + '" after document load');
        }
      }

      doc.write(
          '<script type="text/javascript" src="' + src + '"></' + 'script>');
      return true;
    } else {
      return false;
    }
  };


  /**
   * Resolves dependencies based on the dependencies added using addDependency
   * and calls importScript_ in the correct order.
   * @private
   */
  goog.writeScripts_ = function() {
    // The scripts we need to write this time.
    var scripts = [];
    var seenScript = {};
    var deps = goog.dependencies_;

    function visitNode(path) {
      if (path in deps.written) {
        return;
      }

      // We have already visited this one. We can get here if we have cyclic
      // dependencies.
      if (path in deps.visited) {
        if (!(path in seenScript)) {
          seenScript[path] = true;
          scripts.push(path);
        }
        return;
      }

      deps.visited[path] = true;

      if (path in deps.requires) {
        for (var requireName in deps.requires[path]) {
          // If the required name is defined, we assume that it was already
          // bootstrapped by other means.
          if (!goog.isProvided_(requireName)) {
            if (requireName in deps.nameToPath) {
              visitNode(deps.nameToPath[requireName]);
            } else {
              throw Error('Undefined nameToPath for ' + requireName);
            }
          }
        }
      }

      if (!(path in seenScript)) {
        seenScript[path] = true;
        scripts.push(path);
      }
    }

    for (var path in goog.included_) {
      if (!deps.written[path]) {
        visitNode(path);
      }
    }

    for (var i = 0; i < scripts.length; i++) {
      if (scripts[i]) {
        goog.importScript_(goog.basePath + scripts[i]);
      } else {
        throw Error('Undefined script input');
      }
    }
  };


  /**
   * Looks at the dependency rules and tries to determine the script file that
   * fulfills a particular rule.
   * @param {string} rule In the form goog.namespace.Class or project.script.
   * @return {?string} Url corresponding to the rule, or null.
   * @private
   */
  goog.getPathFromDeps_ = function(rule) {
    if (rule in goog.dependencies_.nameToPath) {
      return goog.dependencies_.nameToPath[rule];
    } else {
      return null;
    }
  };

  goog.findBasePath_();

  // Allow projects to manage the deps files themselves.
  if (!goog.global.CLOSURE_NO_DEPS) {
    goog.importScript_(goog.basePath + 'deps.js');
  }
}



//==============================================================================
// Language Enhancements
//==============================================================================


/**
 * This is a "fixed" version of the typeof operator.  It differs from the typeof
 * operator in such a way that null returns 'null' and arrays return 'array'.
 * @param {*} value The value to get the type of.
 * @return {string} The name of the type.
 */
goog.typeOf = function(value) {
  var s = typeof value;
  if (s == 'object') {
    if (value) {
      // Check these first, so we can avoid calling Object.prototype.toString if
      // possible.
      //
      // IE improperly marshals tyepof across execution contexts, but a
      // cross-context object will still return false for "instanceof Object".
      if (value instanceof Array) {
        return 'array';
      } else if (value instanceof Object) {
        return s;
      }

      // HACK: In order to use an Object prototype method on the arbitrary
      //   value, the compiler requires the value be cast to type Object,
      //   even though the ECMA spec explicitly allows it.
      var className = Object.prototype.toString.call(
          /** @type {Object} */ (value));
      // In Firefox 3.6, attempting to access iframe window objects' length
      // property throws an NS_ERROR_FAILURE, so we need to special-case it
      // here.
      if (className == '[object Window]') {
        return 'object';
      }

      // We cannot always use constructor == Array or instanceof Array because
      // different frames have different Array objects. In IE6, if the iframe
      // where the array was created is destroyed, the array loses its
      // prototype. Then dereferencing val.splice here throws an exception, so
      // we can't use goog.isFunction. Calling typeof directly returns 'unknown'
      // so that will work. In this case, this function will return false and
      // most array functions will still work because the array is still
      // array-like (supports length and []) even though it has lost its
      // prototype.
      // Mark Miller noticed that Object.prototype.toString
      // allows access to the unforgeable [[Class]] property.
      //  15.2.4.2 Object.prototype.toString ( )
      //  When the toString method is called, the following steps are taken:
      //      1. Get the [[Class]] property of this object.
      //      2. Compute a string value by concatenating the three strings
      //         "[object ", Result(1), and "]".
      //      3. Return Result(2).
      // and this behavior survives the destruction of the execution context.
      if ((className == '[object Array]' ||
           // In IE all non value types are wrapped as objects across window
           // boundaries (not iframe though) so we have to do object detection
           // for this edge case.
           typeof value.length == 'number' &&
           typeof value.splice != 'undefined' &&
           typeof value.propertyIsEnumerable != 'undefined' &&
           !value.propertyIsEnumerable('splice')

          )) {
        return 'array';
      }
      // HACK: There is still an array case that fails.
      //     function ArrayImpostor() {}
      //     ArrayImpostor.prototype = [];
      //     var impostor = new ArrayImpostor;
      // this can be fixed by getting rid of the fast path
      // (value instanceof Array) and solely relying on
      // (value && Object.prototype.toString.vall(value) === '[object Array]')
      // but that would require many more function calls and is not warranted
      // unless closure code is receiving objects from untrusted sources.

      // IE in cross-window calls does not correctly marshal the function type
      // (it appears just as an object) so we cannot use just typeof val ==
      // 'function'. However, if the object has a call property, it is a
      // function.
      if ((className == '[object Function]' ||
          typeof value.call != 'undefined' &&
          typeof value.propertyIsEnumerable != 'undefined' &&
          !value.propertyIsEnumerable('call'))) {
        return 'function';
      }

    } else {
      return 'null';
    }

  } else if (s == 'function' && typeof value.call == 'undefined') {
    // In Safari typeof nodeList returns 'function', and on Firefox typeof
    // behaves similarly for HTML{Applet,Embed,Object}, Elements and RegExps. We
    // would like to return object for those and we can detect an invalid
    // function by making sure that the function object has a call method.
    return 'object';
  }
  return s;
};


/**
 * Returns true if the specified value is null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is null.
 */
goog.isNull = function(val) {
  return val === null;
};


/**
 * Returns true if the specified value is defined and not null.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is defined and not null.
 */
goog.isDefAndNotNull = function(val) {
  // Note that undefined == null.
  return val != null;
};


/**
 * Returns true if the specified value is an array.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArray = function(val) {
  return goog.typeOf(val) == 'array';
};


/**
 * Returns true if the object looks like an array. To qualify as array like
 * the value needs to be either a NodeList or an object with a Number length
 * property.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an array.
 */
goog.isArrayLike = function(val) {
  var type = goog.typeOf(val);
  return type == 'array' || type == 'object' && typeof val.length == 'number';
};


/**
 * Returns true if the object looks like a Date. To qualify as Date-like the
 * value needs to be an object and have a getFullYear() function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a like a Date.
 */
goog.isDateLike = function(val) {
  return goog.isObject(val) && typeof val.getFullYear == 'function';
};


/**
 * Returns true if the specified value is a string.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a string.
 */
goog.isString = function(val) {
  return typeof val == 'string';
};


/**
 * Returns true if the specified value is a boolean.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is boolean.
 */
goog.isBoolean = function(val) {
  return typeof val == 'boolean';
};


/**
 * Returns true if the specified value is a number.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a number.
 */
goog.isNumber = function(val) {
  return typeof val == 'number';
};


/**
 * Returns true if the specified value is a function.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is a function.
 */
goog.isFunction = function(val) {
  return goog.typeOf(val) == 'function';
};


/**
 * Returns true if the specified value is an object.  This includes arrays and
 * functions.
 * @param {?} val Variable to test.
 * @return {boolean} Whether variable is an object.
 */
goog.isObject = function(val) {
  var type = typeof val;
  return type == 'object' && val != null || type == 'function';
  // return Object(val) === val also works, but is slower, especially if val is
  // not an object.
};


/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. The unique ID is
 * guaranteed to be unique across the current session amongst objects that are
 * passed into {@code getUid}. There is no guarantee that the ID is unique or
 * consistent across sessions. It is unsafe to generate unique ID for function
 * prototypes.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
goog.getUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In Opera window.hasOwnProperty exists but always returns false so we avoid
  // using it. As a consequence the unique ID generated for BaseClass.prototype
  // and SubClass.prototype will be the same.
  return obj[goog.UID_PROPERTY_] ||
      (obj[goog.UID_PROPERTY_] = ++goog.uidCounter_);
};


/**
 * Whether the given object is alreay assigned a unique ID.
 *
 * This does not modify the object.
 *
 * @param {Object} obj The object to check.
 * @return {boolean} Whether there an assigned unique id for the object.
 */
goog.hasUid = function(obj) {
  return !!obj[goog.UID_PROPERTY_];
};


/**
 * Removes the unique ID from an object. This is useful if the object was
 * previously mutated using {@code goog.getUid} in which case the mutation is
 * undone.
 * @param {Object} obj The object to remove the unique ID field from.
 */
goog.removeUid = function(obj) {
  // TODO(arv): Make the type stricter, do not accept null.

  // In IE, DOM nodes are not instances of Object and throw an exception if we
  // try to delete.  Instead we try to use removeAttribute.
  if ('removeAttribute' in obj) {
    obj.removeAttribute(goog.UID_PROPERTY_);
  }
  /** @preserveTry */
  try {
    delete obj[goog.UID_PROPERTY_];
  } catch (ex) {
  }
};


/**
 * Name for unique ID property. Initialized in a way to help avoid collisions
 * with other closure JavaScript on the same page.
 * @type {string}
 * @private
 */
goog.UID_PROPERTY_ = 'closure_uid_' + ((Math.random() * 1e9) >>> 0);


/**
 * Counter for UID.
 * @type {number}
 * @private
 */
goog.uidCounter_ = 0;


/**
 * Adds a hash code field to an object. The hash code is unique for the
 * given object.
 * @param {Object} obj The object to get the hash code for.
 * @return {number} The hash code for the object.
 * @deprecated Use goog.getUid instead.
 */
goog.getHashCode = goog.getUid;


/**
 * Removes the hash code field from an object.
 * @param {Object} obj The object to remove the field from.
 * @deprecated Use goog.removeUid instead.
 */
goog.removeHashCode = goog.removeUid;


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.cloneObject</code> does not detect reference loops. Objects that
 * refer to themselves will cause infinite recursion.
 *
 * <code>goog.cloneObject</code> is unaware of unique identifiers, and copies
 * UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 * @deprecated goog.cloneObject is unsafe. Prefer the goog.object methods.
 */
goog.cloneObject = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.cloneObject(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * A native implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 * @suppress {deprecated} The compiler thinks that Function.prototype.bind is
 *     deprecated because some people have declared a pure-JS version.
 *     Only the pure-JS version is truly deprecated.
 */
goog.bindNative_ = function(fn, selfObj, var_args) {
  return /** @type {!Function} */ (fn.call.apply(fn.bind, arguments));
};


/**
 * A pure-JS implementation of goog.bind.
 * @param {Function} fn A function to partially apply.
 * @param {Object|undefined} selfObj Specifies the object which this should
 *     point to when the function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @private
 */
goog.bindJs_ = function(fn, selfObj, var_args) {
  if (!fn) {
    throw new Error();
  }

  if (arguments.length > 2) {
    var boundArgs = Array.prototype.slice.call(arguments, 2);
    return function() {
      // Prepend the bound arguments to the current arguments.
      var newArgs = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(newArgs, boundArgs);
      return fn.apply(selfObj, newArgs);
    };

  } else {
    return function() {
      return fn.apply(selfObj, arguments);
    };
  }
};


/**
 * Partially applies this function to a particular 'this object' and zero or
 * more arguments. The result is a new function with some arguments of the first
 * function pre-filled and the value of this 'pre-specified'.
 *
 * Remaining arguments specified at call-time are appended to the pre-specified
 * ones.
 *
 * Also see: {@link #partial}.
 *
 * Usage:
 * <pre>var barMethBound = bind(myFunction, myObj, 'arg1', 'arg2');
 * barMethBound('arg3', 'arg4');</pre>
 *
 * @param {?function(this:T, ...)} fn A function to partially apply.
 * @param {T} selfObj Specifies the object which this should point to when the
 *     function is run.
 * @param {...*} var_args Additional arguments that are partially applied to the
 *     function.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 * @template T
 * @suppress {deprecated} See above.
 */
goog.bind = function(fn, selfObj, var_args) {
  // TODO(nicksantos): narrow the type signature.
  if (Function.prototype.bind &&
      // NOTE(nicksantos): Somebody pulled base.js into the default Chrome
      // extension environment. This means that for Chrome extensions, they get
      // the implementation of Function.prototype.bind that calls goog.bind
      // instead of the native one. Even worse, we don't want to introduce a
      // circular dependency between goog.bind and Function.prototype.bind, so
      // we have to hack this to make sure it works correctly.
      Function.prototype.bind.toString().indexOf('native code') != -1) {
    goog.bind = goog.bindNative_;
  } else {
    goog.bind = goog.bindJs_;
  }
  return goog.bind.apply(null, arguments);
};


/**
 * Like bind(), except that a 'this object' is not required. Useful when the
 * target function is already bound.
 *
 * Usage:
 * var g = partial(f, arg1, arg2);
 * g(arg3, arg4);
 *
 * @param {Function} fn A function to partially apply.
 * @param {...*} var_args Additional arguments that are partially applied to fn.
 * @return {!Function} A partially-applied form of the function bind() was
 *     invoked as a method of.
 */
goog.partial = function(fn, var_args) {
  var args = Array.prototype.slice.call(arguments, 1);
  return function() {
    // Clone the array (with slice()) and append additional arguments
    // to the existing arguments.
    var newArgs = args.slice();
    newArgs.push.apply(newArgs, arguments);
    return fn.apply(this, newArgs);
  };
};


/**
 * Copies all the members of a source object to a target object. This method
 * does not work on all browsers for all objects that contain keys such as
 * toString or hasOwnProperty. Use goog.object.extend for this purpose.
 * @param {Object} target Target.
 * @param {Object} source Source.
 */
goog.mixin = function(target, source) {
  for (var x in source) {
    target[x] = source[x];
  }

  // For IE7 or lower, the for-in-loop does not contain any properties that are
  // not enumerable on the prototype object (for example, isPrototypeOf from
  // Object.prototype) but also it will not include 'replace' on objects that
  // extend String and change 'replace' (not that it is common for anyone to
  // extend anything except Object).
};


/**
 * @return {number} An integer value representing the number of milliseconds
 *     between midnight, January 1, 1970 and the current time.
 */
goog.now = (goog.TRUSTED_SITE && Date.now) || (function() {
  // Unary plus operator converts its operand to a number which in the case of
  // a date is done by calling getTime().
  return +new Date();
});


/**
 * Evals JavaScript in the global scope.  In IE this uses execScript, other
 * browsers use goog.global.eval. If goog.global.eval does not evaluate in the
 * global scope (for example, in Safari), appends a script tag instead.
 * Throws an exception if neither execScript or eval is defined.
 * @param {string} script JavaScript string.
 */
goog.globalEval = function(script) {
  if (goog.global.execScript) {
    goog.global.execScript(script, 'JavaScript');
  } else if (goog.global.eval) {
    // Test to see if eval works
    if (goog.evalWorksForGlobals_ == null) {
      goog.global.eval('var _et_ = 1;');
      if (typeof goog.global['_et_'] != 'undefined') {
        delete goog.global['_et_'];
        goog.evalWorksForGlobals_ = true;
      } else {
        goog.evalWorksForGlobals_ = false;
      }
    }

    if (goog.evalWorksForGlobals_) {
      goog.global.eval(script);
    } else {
      var doc = goog.global.document;
      var scriptElt = doc.createElement('script');
      scriptElt.type = 'text/javascript';
      scriptElt.defer = false;
      // Note(user): can't use .innerHTML since "t('<test>')" will fail and
      // .text doesn't work in Safari 2.  Therefore we append a text node.
      scriptElt.appendChild(doc.createTextNode(script));
      doc.body.appendChild(scriptElt);
      doc.body.removeChild(scriptElt);
    }
  } else {
    throw Error('goog.globalEval not available');
  }
};


/**
 * Indicates whether or not we can call 'eval' directly to eval code in the
 * global scope. Set to a Boolean by the first call to goog.globalEval (which
 * empirically tests whether eval works for globals). @see goog.globalEval
 * @type {?boolean}
 * @private
 */
goog.evalWorksForGlobals_ = null;


/**
 * Optional map of CSS class names to obfuscated names used with
 * goog.getCssName().
 * @type {Object|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMapping_;


/**
 * Optional obfuscation style for CSS class names. Should be set to either
 * 'BY_WHOLE' or 'BY_PART' if defined.
 * @type {string|undefined}
 * @private
 * @see goog.setCssNameMapping
 */
goog.cssNameMappingStyle_;


/**
 * Handles strings that are intended to be used as CSS class names.
 *
 * This function works in tandem with @see goog.setCssNameMapping.
 *
 * Without any mapping set, the arguments are simple joined with a hyphen and
 * passed through unaltered.
 *
 * When there is a mapping, there are two possible styles in which these
 * mappings are used. In the BY_PART style, each part (i.e. in between hyphens)
 * of the passed in css name is rewritten according to the map. In the BY_WHOLE
 * style, the full css name is looked up in the map directly. If a rewrite is
 * not specified by the map, the compiler will output a warning.
 *
 * When the mapping is passed to the compiler, it will replace calls to
 * goog.getCssName with the strings from the mapping, e.g.
 *     var x = goog.getCssName('foo');
 *     var y = goog.getCssName(this.baseClass, 'active');
 *  becomes:
 *     var x= 'foo';
 *     var y = this.baseClass + '-active';
 *
 * If one argument is passed it will be processed, if two are passed only the
 * modifier will be processed, as it is assumed the first argument was generated
 * as a result of calling goog.getCssName.
 *
 * @param {string} className The class name.
 * @param {string=} opt_modifier A modifier to be appended to the class name.
 * @return {string} The class name or the concatenation of the class name and
 *     the modifier.
 */
goog.getCssName = function(className, opt_modifier) {
  var getMapping = function(cssName) {
    return goog.cssNameMapping_[cssName] || cssName;
  };

  var renameByParts = function(cssName) {
    // Remap all the parts individually.
    var parts = cssName.split('-');
    var mapped = [];
    for (var i = 0; i < parts.length; i++) {
      mapped.push(getMapping(parts[i]));
    }
    return mapped.join('-');
  };

  var rename;
  if (goog.cssNameMapping_) {
    rename = goog.cssNameMappingStyle_ == 'BY_WHOLE' ?
        getMapping : renameByParts;
  } else {
    rename = function(a) {
      return a;
    };
  }

  if (opt_modifier) {
    return className + '-' + rename(opt_modifier);
  } else {
    return rename(className);
  }
};


/**
 * Sets the map to check when returning a value from goog.getCssName(). Example:
 * <pre>
 * goog.setCssNameMapping({
 *   "goog": "a",
 *   "disabled": "b",
 * });
 *
 * var x = goog.getCssName('goog');
 * // The following evaluates to: "a a-b".
 * goog.getCssName('goog') + ' ' + goog.getCssName(x, 'disabled')
 * </pre>
 * When declared as a map of string literals to string literals, the JSCompiler
 * will replace all calls to goog.getCssName() using the supplied map if the
 * --closure_pass flag is set.
 *
 * @param {!Object} mapping A map of strings to strings where keys are possible
 *     arguments to goog.getCssName() and values are the corresponding values
 *     that should be returned.
 * @param {string=} opt_style The style of css name mapping. There are two valid
 *     options: 'BY_PART', and 'BY_WHOLE'.
 * @see goog.getCssName for a description.
 */
goog.setCssNameMapping = function(mapping, opt_style) {
  goog.cssNameMapping_ = mapping;
  goog.cssNameMappingStyle_ = opt_style;
};


/**
 * To use CSS renaming in compiled mode, one of the input files should have a
 * call to goog.setCssNameMapping() with an object literal that the JSCompiler
 * can extract and use to replace all calls to goog.getCssName(). In uncompiled
 * mode, JavaScript code should be loaded before this base.js file that declares
 * a global variable, CLOSURE_CSS_NAME_MAPPING, which is used below. This is
 * to ensure that the mapping is loaded before any calls to goog.getCssName()
 * are made in uncompiled mode.
 *
 * A hook for overriding the CSS name mapping.
 * @type {Object|undefined}
 */
goog.global.CLOSURE_CSS_NAME_MAPPING;


if (!COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING) {
  // This does not call goog.setCssNameMapping() because the JSCompiler
  // requires that goog.setCssNameMapping() be called with an object literal.
  goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING;
}


/**
 * Gets a localized message.
 *
 * This function is a compiler primitive. If you give the compiler a localized
 * message bundle, it will replace the string at compile-time with a localized
 * version, and expand goog.getMsg call to a concatenated string.
 *
 * Messages must be initialized in the form:
 * <code>
 * var MSG_NAME = goog.getMsg('Hello {$placeholder}', {'placeholder': 'world'});
 * </code>
 *
 * @param {string} str Translatable string, places holders in the form {$foo}.
 * @param {Object=} opt_values Map of place holder name to value.
 * @return {string} message with placeholders filled.
 */
goog.getMsg = function(str, opt_values) {
  var values = opt_values || {};
  for (var key in values) {
    var value = ('' + values[key]).replace(/\$/g, '$$$$');
    str = str.replace(new RegExp('\\{\\$' + key + '\\}', 'gi'), value);
  }
  return str;
};


/**
 * Gets a localized message. If the message does not have a translation, gives a
 * fallback message.
 *
 * This is useful when introducing a new message that has not yet been
 * translated into all languages.
 *
 * This function is a compiler primitive. Must be used in the form:
 * <code>var x = goog.getMsgWithFallback(MSG_A, MSG_B);</code>
 * where MSG_A and MSG_B were initialized with goog.getMsg.
 *
 * @param {string} a The preferred message.
 * @param {string} b The fallback message.
 * @return {string} The best translated message.
 */
goog.getMsgWithFallback = function(a, b) {
  return a;
};


/**
 * Exposes an unobfuscated global namespace path for the given object.
 * Note that fields of the exported object *will* be obfuscated, unless they are
 * exported in turn via this function or goog.exportProperty.
 *
 * Also handy for making public items that are defined in anonymous closures.
 *
 * ex. goog.exportSymbol('public.path.Foo', Foo);
 *
 * ex. goog.exportSymbol('public.path.Foo.staticFunction', Foo.staticFunction);
 *     public.path.Foo.staticFunction();
 *
 * ex. goog.exportSymbol('public.path.Foo.prototype.myMethod',
 *                       Foo.prototype.myMethod);
 *     new public.path.Foo().myMethod();
 *
 * @param {string} publicPath Unobfuscated name to export.
 * @param {*} object Object the name should point to.
 * @param {Object=} opt_objectToExportTo The object to add the path to; default
 *     is goog.global.
 */
goog.exportSymbol = function(publicPath, object, opt_objectToExportTo) {
  goog.exportPath_(publicPath, object, opt_objectToExportTo);
};


/**
 * Exports a property unobfuscated into the object's namespace.
 * ex. goog.exportProperty(Foo, 'staticFunction', Foo.staticFunction);
 * ex. goog.exportProperty(Foo.prototype, 'myMethod', Foo.prototype.myMethod);
 * @param {Object} object Object whose static property is being exported.
 * @param {string} publicName Unobfuscated name to export.
 * @param {*} symbol Object the name should point to.
 */
goog.exportProperty = function(object, publicName, symbol) {
  object[publicName] = symbol;
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * <pre>
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   goog.base(this, a, b);
 * }
 * goog.inherits(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // This works.
 * </pre>
 *
 * In addition, a superclass' implementation of a method can be invoked as
 * follows:
 *
 * <pre>
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass.superClass_.foo.call(this, a);
 *   // Other code here.
 * };
 * </pre>
 *
 * @param {Function} childCtor Child class.
 * @param {Function} parentCtor Parent class.
 */
goog.inherits = function(childCtor, parentCtor) {
  /** @constructor */
  function tempCtor() {};
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor();
  /** @override */
  childCtor.prototype.constructor = childCtor;

  /**
   * Calls superclass constructor/method.
   *
   * This function is only available if you use goog.inherits to
   * express inheritance relationships between classes.
   *
   * NOTE: This is a replacement for goog.base and for superClass_
   * property defined in childCtor.
   *
   * @param {!Object} me Should always be "this".
   * @param {string} methodName The method name to call. Calling
   *     superclass constructor can be done with the special string
   *     'constructor'.
   * @param {...*} var_args The arguments to pass to superclass
   *     method/constructor.
   * @return {*} The return value of the superclass method/constructor.
   */
  childCtor.base = function(me, methodName, var_args) {
    var args = Array.prototype.slice.call(arguments, 2);
    return parentCtor.prototype[methodName].apply(me, args);
  };
};


/**
 * Call up to the superclass.
 *
 * If this is called from a constructor, then this calls the superclass
 * constructor with arguments 1-N.
 *
 * If this is called from a prototype method, then you must pass the name of the
 * method as the second argument to this function. If you do not, you will get a
 * runtime error. This calls the superclass' method with arguments 2-N.
 *
 * This function only works if you use goog.inherits to express inheritance
 * relationships between your classes.
 *
 * This function is a compiler primitive. At compile-time, the compiler will do
 * macro expansion to remove a lot of the extra overhead that this function
 * introduces. The compiler will also enforce a lot of the assumptions that this
 * function makes, and treat it as a compiler error if you break them.
 *
 * @param {!Object} me Should always be "this".
 * @param {*=} opt_methodName The method name if calling a super method.
 * @param {...*} var_args The rest of the arguments.
 * @return {*} The return value of the superclass method.
 * @suppress {es5Strict} This method can not be used in strict mode, but
 *     all Closure Library consumers must depend on this file.
 */
goog.base = function(me, opt_methodName, var_args) {
  var caller = arguments.callee.caller;

  if (goog.STRICT_MODE_COMPATIBLE || (goog.DEBUG && !caller)) {
    throw Error('arguments.caller not defined.  goog.base() cannot be used ' +
                'with strict mode code. See ' +
                'http://www.ecma-international.org/ecma-262/5.1/#sec-C');
  }

  if (caller.superClass_) {
    // This is a constructor. Call the superclass constructor.
    return caller.superClass_.constructor.apply(
        me, Array.prototype.slice.call(arguments, 1));
  }

  var args = Array.prototype.slice.call(arguments, 2);
  var foundCaller = false;
  for (var ctor = me.constructor;
       ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
    if (ctor.prototype[opt_methodName] === caller) {
      foundCaller = true;
    } else if (foundCaller) {
      return ctor.prototype[opt_methodName].apply(me, args);
    }
  }

  // If we did not find the caller in the prototype chain, then one of two
  // things happened:
  // 1) The caller is an instance method.
  // 2) This method was not called by the right caller.
  if (me[opt_methodName] === caller) {
    return me.constructor.prototype[opt_methodName].apply(me, args);
  } else {
    throw Error(
        'goog.base called from a method of one name ' +
        'to a method of a different name');
  }
};


/**
 * Allow for aliasing within scope functions.  This function exists for
 * uncompiled code - in compiled code the calls will be inlined and the aliases
 * applied.  In uncompiled code the function is simply run since the aliases as
 * written are valid JavaScript.
 * @param {function()} fn Function to call.  This function can contain aliases
 *     to namespaces (e.g. "var dom = goog.dom") or classes
 *     (e.g. "var Timer = goog.Timer").
 */
goog.scope = function(fn) {
  fn.call(goog.global);
};


/*
 * To support uncompiled, strict mode bundles that use eval to divide source
 * like so:
 *    eval('someSource;//# sourceUrl sourcefile.js');
 * We need to export the globally defined symbols "goog" and "COMPILED".
 * Exporting "goog" breaks the compiler optimizations, so we required that
 * be defined externally.
 * NOTE: We don't use goog.exportSymbol here because we don't want to trigger
 * extern generation when that compiler option is enabled.
 */
if (!COMPILED) {
  goog.global['COMPILED'] = COMPILED;
}


// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

goog.provide('goog.events.EventId');



/**
 * A templated class that is used when registering for events. Typical usage:
 * <code>
 *   /** @type {goog.events.EventId.<MyEventObj>}
 *   var myEventId = new goog.events.EventId(
 *       goog.events.getUniqueId(('someEvent'));
 *
 *   // No need to cast or declare here since the compiler knows the correct
 *   // type of 'evt' (MyEventObj).
 *   something.listen(myEventId, function(evt) {});
 * </code>
 *
 * @param {string} eventId
 * @template T
 * @constructor
 * @struct
 * @final
 */
goog.events.EventId = function(eventId) {
  /** @const */ this.id = eventId;
};


/**
 * @override
 */
goog.events.EventId.prototype.toString = function() {
  return this.id;
};
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the disposable interface.  A disposable object
 * has a dispose method to to clean up references and resources.
 * @author nnaze@google.com (Nathan Naze)
 */


goog.provide('goog.disposable.IDisposable');



/**
 * Interface for a disposable object.  If a instance requires cleanup
 * (references COM objects, DOM notes, or other disposable objects), it should
 * implement this interface (it may subclass goog.Disposable).
 * @interface
 */
goog.disposable.IDisposable = function() {};


/**
 * Disposes of the object and its resources.
 * @return {void} Nothing.
 */
goog.disposable.IDisposable.prototype.dispose = goog.abstractMethod;


/**
 * @return {boolean} Whether the object has been disposed of.
 */
goog.disposable.IDisposable.prototype.isDisposed = goog.abstractMethod;
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Implements the disposable interface. The dispose method is used
 * to clean up references and resources.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.Disposable');
/** @suppress {extraProvide} */
goog.provide('goog.dispose');
/** @suppress {extraProvide} */
goog.provide('goog.disposeAll');

goog.require('goog.disposable.IDisposable');



/**
 * Class that provides the basic implementation for disposable objects. If your
 * class holds one or more references to COM objects, DOM nodes, or other
 * disposable objects, it should extend this class or implement the disposable
 * interface (defined in goog.disposable.IDisposable).
 * @constructor
 * @implements {goog.disposable.IDisposable}
 */
goog.Disposable = function() {
  if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
    if (goog.Disposable.INCLUDE_STACK_ON_CREATION) {
      this.creationStack = new Error().stack;
    }
    goog.Disposable.instances_[goog.getUid(this)] = this;
  }
};


/**
 * @enum {number} Different monitoring modes for Disposable.
 */
goog.Disposable.MonitoringMode = {
  /**
   * No monitoring.
   */
  OFF: 0,
  /**
   * Creating and disposing the goog.Disposable instances is monitored. All
   * disposable objects need to call the {@code goog.Disposable} base
   * constructor. The PERMANENT mode must be switched on before creating any
   * goog.Disposable instances.
   */
  PERMANENT: 1,
  /**
   * INTERACTIVE mode can be switched on and off on the fly without producing
   * errors. It also doesn't warn if the disposable objects don't call the
   * {@code goog.Disposable} base constructor.
   */
  INTERACTIVE: 2
};


/**
 * @define {number} The monitoring mode of the goog.Disposable
 *     instances. Default is OFF. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.Disposable.MONITORING_MODE', 0);


/**
 * @define {boolean} Whether to attach creation stack to each created disposable
 *     instance; This is only relevant for when MonitoringMode != OFF.
 */
goog.define('goog.Disposable.INCLUDE_STACK_ON_CREATION', true);


/**
 * Maps the unique ID of every undisposed {@code goog.Disposable} object to
 * the object itself.
 * @type {!Object.<number, !goog.Disposable>}
 * @private
 */
goog.Disposable.instances_ = {};


/**
 * @return {!Array.<!goog.Disposable>} All {@code goog.Disposable} objects that
 *     haven't been disposed of.
 */
goog.Disposable.getUndisposedObjects = function() {
  var ret = [];
  for (var id in goog.Disposable.instances_) {
    if (goog.Disposable.instances_.hasOwnProperty(id)) {
      ret.push(goog.Disposable.instances_[Number(id)]);
    }
  }
  return ret;
};


/**
 * Clears the registry of undisposed objects but doesn't dispose of them.
 */
goog.Disposable.clearUndisposedObjects = function() {
  goog.Disposable.instances_ = {};
};


/**
 * Whether the object has been disposed of.
 * @type {boolean}
 * @private
 */
goog.Disposable.prototype.disposed_ = false;


/**
 * Callbacks to invoke when this object is disposed.
 * @type {Array.<!Function>}
 * @private
 */
goog.Disposable.prototype.onDisposeCallbacks_;


/**
 * If monitoring the goog.Disposable instances is enabled, stores the creation
 * stack trace of the Disposable instance.
 * @type {string}
 */
goog.Disposable.prototype.creationStack;


/**
 * @return {boolean} Whether the object has been disposed of.
 * @override
 */
goog.Disposable.prototype.isDisposed = function() {
  return this.disposed_;
};


/**
 * @return {boolean} Whether the object has been disposed of.
 * @deprecated Use {@link #isDisposed} instead.
 */
goog.Disposable.prototype.getDisposed = goog.Disposable.prototype.isDisposed;


/**
 * Disposes of the object. If the object hasn't already been disposed of, calls
 * {@link #disposeInternal}. Classes that extend {@code goog.Disposable} should
 * override {@link #disposeInternal} in order to delete references to COM
 * objects, DOM nodes, and other disposable objects. Reentrant.
 *
 * @return {void} Nothing.
 * @override
 */
goog.Disposable.prototype.dispose = function() {
  if (!this.disposed_) {
    // Set disposed_ to true first, in case during the chain of disposal this
    // gets disposed recursively.
    this.disposed_ = true;
    this.disposeInternal();
    if (goog.Disposable.MONITORING_MODE != goog.Disposable.MonitoringMode.OFF) {
      var uid = goog.getUid(this);
      if (goog.Disposable.MONITORING_MODE ==
          goog.Disposable.MonitoringMode.PERMANENT &&
          !goog.Disposable.instances_.hasOwnProperty(uid)) {
        throw Error(this + ' did not call the goog.Disposable base ' +
            'constructor or was disposed of after a clearUndisposedObjects ' +
            'call');
      }
      delete goog.Disposable.instances_[uid];
    }
  }
};


/**
 * Associates a disposable object with this object so that they will be disposed
 * together.
 * @param {goog.disposable.IDisposable} disposable that will be disposed when
 *     this object is disposed.
 */
goog.Disposable.prototype.registerDisposable = function(disposable) {
  this.addOnDisposeCallback(goog.partial(goog.dispose, disposable));
};


/**
 * Invokes a callback function when this object is disposed. Callbacks are
 * invoked in the order in which they were added.
 * @param {function(this:T):?} callback The callback function.
 * @param {T=} opt_scope An optional scope to call the callback in.
 * @template T
 */
goog.Disposable.prototype.addOnDisposeCallback = function(callback, opt_scope) {
  if (!this.onDisposeCallbacks_) {
    this.onDisposeCallbacks_ = [];
  }

  this.onDisposeCallbacks_.push(
      goog.isDef(opt_scope) ? goog.bind(callback, opt_scope) : callback);
};


/**
 * Deletes or nulls out any references to COM objects, DOM nodes, or other
 * disposable objects. Classes that extend {@code goog.Disposable} should
 * override this method.
 * Not reentrant. To avoid calling it twice, it must only be called from the
 * subclass' {@code disposeInternal} method. Everywhere else the public
 * {@code dispose} method must be used.
 * For example:
 * <pre>
 *   mypackage.MyClass = function() {
 *     mypackage.MyClass.base(this, 'constructor');
 *     // Constructor logic specific to MyClass.
 *     ...
 *   };
 *   goog.inherits(mypackage.MyClass, goog.Disposable);
 *
 *   mypackage.MyClass.prototype.disposeInternal = function() {
 *     // Dispose logic specific to MyClass.
 *     ...
 *     // Call superclass's disposeInternal at the end of the subclass's, like
 *     // in C++, to avoid hard-to-catch issues.
 *     mypackage.MyClass.base(this, 'disposeInternal');
 *   };
 * </pre>
 * @protected
 */
goog.Disposable.prototype.disposeInternal = function() {
  if (this.onDisposeCallbacks_) {
    while (this.onDisposeCallbacks_.length) {
      this.onDisposeCallbacks_.shift()();
    }
  }
};


/**
 * Returns True if we can verify the object is disposed.
 * Calls {@code isDisposed} on the argument if it supports it.  If obj
 * is not an object with an isDisposed() method, return false.
 * @param {*} obj The object to investigate.
 * @return {boolean} True if we can verify the object is disposed.
 */
goog.Disposable.isDisposed = function(obj) {
  if (obj && typeof obj.isDisposed == 'function') {
    return obj.isDisposed();
  }
  return false;
};


/**
 * Calls {@code dispose} on the argument if it supports it. If obj is not an
 *     object with a dispose() method, this is a no-op.
 * @param {*} obj The object to dispose of.
 */
goog.dispose = function(obj) {
  if (obj && typeof obj.dispose == 'function') {
    obj.dispose();
  }
};


/**
 * Calls {@code dispose} on each member of the list that supports it. (If the
 * member is an ArrayLike, then {@code goog.disposeAll()} will be called
 * recursively on each of its members.) If the member is not an object with a
 * {@code dispose()} method, then it is ignored.
 * @param {...*} var_args The list.
 */
goog.disposeAll = function(var_args) {
  for (var i = 0, len = arguments.length; i < len; ++i) {
    var disposable = arguments[i];
    if (goog.isArrayLike(disposable)) {
      goog.disposeAll.apply(null, disposable);
    } else {
      goog.dispose(disposable);
    }
  }
};
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A base class for event objects.
 *
 */


goog.provide('goog.events.Event');
goog.provide('goog.events.EventLike');

/**
 * goog.events.Event no longer depends on goog.Disposable. Keep requiring
 * goog.Disposable here to not break projects which assume this dependency.
 * @suppress {extraRequire}
 */
goog.require('goog.Disposable');
goog.require('goog.events.EventId');


/**
 * A typedef for event like objects that are dispatchable via the
 * goog.events.dispatchEvent function. strings are treated as the type for a
 * goog.events.Event. Objects are treated as an extension of a new
 * goog.events.Event with the type property of the object being used as the type
 * of the Event.
 * @typedef {string|Object|goog.events.Event|goog.events.EventId}
 */
goog.events.EventLike;



/**
 * A base class for event objects, so that they can support preventDefault and
 * stopPropagation.
 *
 * @param {string|!goog.events.EventId} type Event Type.
 * @param {Object=} opt_target Reference to the object that is the target of
 *     this event. It has to implement the {@code EventTarget} interface
 *     declared at {@link http://developer.mozilla.org/en/DOM/EventTarget}.
 * @constructor
 */
goog.events.Event = function(type, opt_target) {
  /**
   * Event type.
   * @type {string}
   */
  this.type = type instanceof goog.events.EventId ? String(type) : type;

  /**
   * Target of the event.
   * @type {Object|undefined}
   */
  this.target = opt_target;

  /**
   * Object that had the listener attached.
   * @type {Object|undefined}
   */
  this.currentTarget = this.target;

  /**
   * Whether to cancel the event in internal capture/bubble processing for IE.
   * @type {boolean}
   * @public
   * @suppress {underscore|visibility} Technically public, but referencing this
   *     outside this package is strongly discouraged.
   */
  this.propagationStopped_ = false;

  /**
   * Whether the default action has been prevented.
   * This is a property to match the W3C specification at
   * {@link http://www.w3.org/TR/DOM-Level-3-Events/
   * #events-event-type-defaultPrevented}.
   * Must be treated as read-only outside the class.
   * @type {boolean}
   */
  this.defaultPrevented = false;

  /**
   * Return value for in internal capture/bubble processing for IE.
   * @type {boolean}
   * @public
   * @suppress {underscore|visibility} Technically public, but referencing this
   *     outside this package is strongly discouraged.
   */
  this.returnValue_ = true;
};


/**
 * For backwards compatibility (goog.events.Event used to inherit
 * goog.Disposable).
 * @deprecated Events don't need to be disposed.
 */
goog.events.Event.prototype.disposeInternal = function() {
};


/**
 * For backwards compatibility (goog.events.Event used to inherit
 * goog.Disposable).
 * @deprecated Events don't need to be disposed.
 */
goog.events.Event.prototype.dispose = function() {
};


/**
 * Stops event propagation.
 */
goog.events.Event.prototype.stopPropagation = function() {
  this.propagationStopped_ = true;
};


/**
 * Prevents the default action, for example a link redirecting to a url.
 */
goog.events.Event.prototype.preventDefault = function() {
  this.defaultPrevented = true;
  this.returnValue_ = false;
};


/**
 * Stops the propagation of the event. It is equivalent to
 * {@code e.stopPropagation()}, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 */
goog.events.Event.stopPropagation = function(e) {
  e.stopPropagation();
};


/**
 * Prevents the default action. It is equivalent to
 * {@code e.preventDefault()}, but can be used as the callback argument of
 * {@link goog.events.listen} without declaring another function.
 * @param {!goog.events.Event} e An event.
 */
goog.events.Event.preventDefault = function(e) {
  e.preventDefault();
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of goog.dom.NodeType.
 */

goog.provide('goog.dom.NodeType');


/**
 * Constants for the nodeType attribute in the Node interface.
 *
 * These constants match those specified in the Node interface. These are
 * usually present on the Node object in recent browsers, but not in older
 * browsers (specifically, early IEs) and thus are given here.
 *
 * In some browsers (early IEs), these are not defined on the Node object,
 * so they are provided here.
 *
 * See http://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-1950641247
 * @enum {number}
 */
goog.dom.NodeType = {
  ELEMENT: 1,
  ATTRIBUTE: 2,
  TEXT: 3,
  CDATA_SECTION: 4,
  ENTITY_REFERENCE: 5,
  ENTITY: 6,
  PROCESSING_INSTRUCTION: 7,
  COMMENT: 8,
  DOCUMENT: 9,
  DOCUMENT_TYPE: 10,
  DOCUMENT_FRAGMENT: 11,
  NOTATION: 12
};
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Provides a base class for custom Error objects such that the
 * stack is correctly maintained.
 *
 * You should never need to throw goog.debug.Error(msg) directly, Error(msg) is
 * sufficient.
 *
 */

goog.provide('goog.debug.Error');



/**
 * Base class for custom error objects.
 * @param {*=} opt_msg The message associated with the error.
 * @constructor
 * @extends {Error}
 */
goog.debug.Error = function(opt_msg) {

  // Attempt to ensure there is a stack trace.
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, goog.debug.Error);
  } else {
    var stack = new Error().stack;
    if (stack) {
      this.stack = stack;
    }
  }

  if (opt_msg) {
    this.message = String(opt_msg);
  }
};
goog.inherits(goog.debug.Error, Error);


/** @override */
goog.debug.Error.prototype.name = 'CustomError';
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for string manipulation.
 */


/**
 * Namespace for string utilities
 */
goog.provide('goog.string');
goog.provide('goog.string.Unicode');


/**
 * @define {boolean} Enables HTML escaping of lowercase letter "e" which helps
 * with detection of double-escaping as this letter is frequently used.
 */
goog.define('goog.string.DETECT_DOUBLE_ESCAPING', false);


/**
 * Common Unicode string characters.
 * @enum {string}
 */
goog.string.Unicode = {
  NBSP: '\xa0'
};


/**
 * Fast prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix A string to look for at the start of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix}.
 */
goog.string.startsWith = function(str, prefix) {
  return str.lastIndexOf(prefix, 0) == 0;
};


/**
 * Fast suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix}.
 */
goog.string.endsWith = function(str, suffix) {
  var l = str.length - suffix.length;
  return l >= 0 && str.indexOf(suffix, l) == l;
};


/**
 * Case-insensitive prefix-checker.
 * @param {string} str The string to check.
 * @param {string} prefix  A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} begins with {@code prefix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveStartsWith = function(str, prefix) {
  return goog.string.caseInsensitiveCompare(
      prefix, str.substr(0, prefix.length)) == 0;
};


/**
 * Case-insensitive suffix-checker.
 * @param {string} str The string to check.
 * @param {string} suffix A string to look for at the end of {@code str}.
 * @return {boolean} True if {@code str} ends with {@code suffix} (ignoring
 *     case).
 */
goog.string.caseInsensitiveEndsWith = function(str, suffix) {
  return goog.string.caseInsensitiveCompare(
      suffix, str.substr(str.length - suffix.length, suffix.length)) == 0;
};


/**
 * Case-insensitive equality checker.
 * @param {string} str1 First string to check.
 * @param {string} str2 Second string to check.
 * @return {boolean} True if {@code str1} and {@code str2} are the same string,
 *     ignoring case.
 */
goog.string.caseInsensitiveEquals = function(str1, str2) {
  return str1.toLowerCase() == str2.toLowerCase();
};


/**
 * Does simple python-style string substitution.
 * subs("foo%s hot%s", "bar", "dog") becomes "foobar hotdog".
 * @param {string} str The string containing the pattern.
 * @param {...*} var_args The items to substitute into the pattern.
 * @return {string} A copy of {@code str} in which each occurrence of
 *     {@code %s} has been replaced an argument from {@code var_args}.
 */
goog.string.subs = function(str, var_args) {
  var splitParts = str.split('%s');
  var returnString = '';

  var subsArguments = Array.prototype.slice.call(arguments, 1);
  while (subsArguments.length &&
         // Replace up to the last split part. We are inserting in the
         // positions between split parts.
         splitParts.length > 1) {
    returnString += splitParts.shift() + subsArguments.shift();
  }

  return returnString + splitParts.join('%s'); // Join unused '%s'
};


/**
 * Converts multiple whitespace chars (spaces, non-breaking-spaces, new lines
 * and tabs) to a single space, and strips leading and trailing whitespace.
 * @param {string} str Input string.
 * @return {string} A copy of {@code str} with collapsed whitespace.
 */
goog.string.collapseWhitespace = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+/g, ' ').replace(/^\s+|\s+$/g, '');
};


/**
 * Checks if a string is empty or contains only whitespaces.
 * @param {string} str The string to check.
 * @return {boolean} True if {@code str} is empty or whitespace only.
 */
goog.string.isEmpty = function(str) {
  // testing length == 0 first is actually slower in all browsers (about the
  // same in Opera).
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return /^[\s\xa0]*$/.test(str);
};


/**
 * Checks if a string is null, undefined, empty or contains only whitespaces.
 * @param {*} str The string to check.
 * @return {boolean} True if{@code str} is null, undefined, empty, or
 *     whitespace only.
 */
goog.string.isEmptySafe = function(str) {
  return goog.string.isEmpty(goog.string.makeSafe(str));
};


/**
 * Checks if a string is all breaking whitespace.
 * @param {string} str The string to check.
 * @return {boolean} Whether the string is all breaking whitespace.
 */
goog.string.isBreakingWhitespace = function(str) {
  return !/[^\t\n\r ]/.test(str);
};


/**
 * Checks if a string contains all letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} consists entirely of letters.
 */
goog.string.isAlpha = function(str) {
  return !/[^a-zA-Z]/.test(str);
};


/**
 * Checks if a string contains only numbers.
 * @param {*} str string to check. If not a string, it will be
 *     casted to one.
 * @return {boolean} True if {@code str} is numeric.
 */
goog.string.isNumeric = function(str) {
  return !/[^0-9]/.test(str);
};


/**
 * Checks if a string contains only numbers or letters.
 * @param {string} str string to check.
 * @return {boolean} True if {@code str} is alphanumeric.
 */
goog.string.isAlphaNumeric = function(str) {
  return !/[^a-zA-Z0-9]/.test(str);
};


/**
 * Checks if a character is a space character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a space.
 */
goog.string.isSpace = function(ch) {
  return ch == ' ';
};


/**
 * Checks if a character is a valid unicode character.
 * @param {string} ch Character to check.
 * @return {boolean} True if {code ch} is a valid unicode character.
 */
goog.string.isUnicodeChar = function(ch) {
  return ch.length == 1 && ch >= ' ' && ch <= '~' ||
         ch >= '\u0080' && ch <= '\uFFFD';
};


/**
 * Takes a string and replaces newlines with a space. Multiple lines are
 * replaced with a single space.
 * @param {string} str The string from which to strip newlines.
 * @return {string} A copy of {@code str} stripped of newlines.
 */
goog.string.stripNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)+/g, ' ');
};


/**
 * Replaces Windows and Mac new lines with unix style: \r or \r\n with \n.
 * @param {string} str The string to in which to canonicalize newlines.
 * @return {string} {@code str} A copy of {@code} with canonicalized newlines.
 */
goog.string.canonicalizeNewlines = function(str) {
  return str.replace(/(\r\n|\r|\n)/g, '\n');
};


/**
 * Normalizes whitespace in a string, replacing all whitespace chars with
 * a space.
 * @param {string} str The string in which to normalize whitespace.
 * @return {string} A copy of {@code str} with all whitespace normalized.
 */
goog.string.normalizeWhitespace = function(str) {
  return str.replace(/\xa0|\s/g, ' ');
};


/**
 * Normalizes spaces in a string, replacing all consecutive spaces and tabs
 * with a single space. Replaces non-breaking space with a space.
 * @param {string} str The string in which to normalize spaces.
 * @return {string} A copy of {@code str} with all consecutive spaces and tabs
 *    replaced with a single space.
 */
goog.string.normalizeSpaces = function(str) {
  return str.replace(/\xa0|[ \t]+/g, ' ');
};


/**
 * Removes the breaking spaces from the left and right of the string and
 * collapses the sequences of breaking spaces in the middle into single spaces.
 * The original and the result strings render the same way in HTML.
 * @param {string} str A string in which to collapse spaces.
 * @return {string} Copy of the string with normalized breaking spaces.
 */
goog.string.collapseBreakingSpaces = function(str) {
  return str.replace(/[\t\r\n ]+/g, ' ').replace(
      /^[\t\r\n ]+|[\t\r\n ]+$/g, '');
};


/**
 * Trims white spaces to the left and right of a string.
 * @param {string} str The string to trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trim = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
};


/**
 * Trims whitespaces at the left end of a string.
 * @param {string} str The string to left trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimLeft = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/^[\s\xa0]+/, '');
};


/**
 * Trims whitespaces at the right end of a string.
 * @param {string} str The string to right trim.
 * @return {string} A trimmed copy of {@code str}.
 */
goog.string.trimRight = function(str) {
  // Since IE doesn't include non-breaking-space (0xa0) in their \s character
  // class (as required by section 7.2 of the ECMAScript spec), we explicitly
  // include it in the regexp to enforce consistent cross-browser behavior.
  return str.replace(/[\s\xa0]+$/, '');
};


/**
 * A string comparator that ignores case.
 * -1 = str1 less than str2
 *  0 = str1 equals str2
 *  1 = str1 greater than str2
 *
 * @param {string} str1 The string to compare.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} The comparator result, as described above.
 */
goog.string.caseInsensitiveCompare = function(str1, str2) {
  var test1 = String(str1).toLowerCase();
  var test2 = String(str2).toLowerCase();

  if (test1 < test2) {
    return -1;
  } else if (test1 == test2) {
    return 0;
  } else {
    return 1;
  }
};


/**
 * Regular expression used for splitting a string into substrings of fractional
 * numbers, integers, and non-numeric characters.
 * @type {RegExp}
 * @private
 */
goog.string.numerateCompareRegExp_ = /(\.\d+)|(\d+)|(\D+)/g;


/**
 * String comparison function that handles numbers in a way humans might expect.
 * Using this function, the string "File 2.jpg" sorts before "File 10.jpg". The
 * comparison is mostly case-insensitive, though strings that are identical
 * except for case are sorted with the upper-case strings before lower-case.
 *
 * This comparison function is significantly slower (about 500x) than either
 * the default or the case-insensitive compare. It should not be used in
 * time-critical code, but should be fast enough to sort several hundred short
 * strings (like filenames) with a reasonable delay.
 *
 * @param {string} str1 The string to compare in a numerically sensitive way.
 * @param {string} str2 The string to compare {@code str1} to.
 * @return {number} less than 0 if str1 < str2, 0 if str1 == str2, greater than
 *     0 if str1 > str2.
 */
goog.string.numerateCompare = function(str1, str2) {
  if (str1 == str2) {
    return 0;
  }
  if (!str1) {
    return -1;
  }
  if (!str2) {
    return 1;
  }

  // Using match to split the entire string ahead of time turns out to be faster
  // for most inputs than using RegExp.exec or iterating over each character.
  var tokens1 = str1.toLowerCase().match(goog.string.numerateCompareRegExp_);
  var tokens2 = str2.toLowerCase().match(goog.string.numerateCompareRegExp_);

  var count = Math.min(tokens1.length, tokens2.length);

  for (var i = 0; i < count; i++) {
    var a = tokens1[i];
    var b = tokens2[i];

    // Compare pairs of tokens, returning if one token sorts before the other.
    if (a != b) {

      // Only if both tokens are integers is a special comparison required.
      // Decimal numbers are sorted as strings (e.g., '.09' < '.1').
      var num1 = parseInt(a, 10);
      if (!isNaN(num1)) {
        var num2 = parseInt(b, 10);
        if (!isNaN(num2) && num1 - num2) {
          return num1 - num2;
        }
      }
      return a < b ? -1 : 1;
    }
  }

  // If one string is a substring of the other, the shorter string sorts first.
  if (tokens1.length != tokens2.length) {
    return tokens1.length - tokens2.length;
  }

  // The two strings must be equivalent except for case (perfect equality is
  // tested at the head of the function.) Revert to default ASCII-betical string
  // comparison to stablize the sort.
  return str1 < str2 ? -1 : 1;
};


/**
 * URL-encodes a string
 * @param {*} str The string to url-encode.
 * @return {string} An encoded copy of {@code str} that is safe for urls.
 *     Note that '#', ':', and other characters used to delimit portions
 *     of URLs *will* be encoded.
 */
goog.string.urlEncode = function(str) {
  return encodeURIComponent(String(str));
};


/**
 * URL-decodes the string. We need to specially handle '+'s because
 * the javascript library doesn't convert them to spaces.
 * @param {string} str The string to url decode.
 * @return {string} The decoded {@code str}.
 */
goog.string.urlDecode = function(str) {
  return decodeURIComponent(str.replace(/\+/g, ' '));
};


/**
 * Converts \n to <br>s or <br />s.
 * @param {string} str The string in which to convert newlines.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} A copy of {@code str} with converted newlines.
 */
goog.string.newLineToBr = function(str, opt_xml) {
  return str.replace(/(\r\n|\r|\n)/g, opt_xml ? '<br />' : '<br>');
};


/**
 * Escapes double quote '"' and single quote '\'' characters in addition to
 * '&', '<', and '>' so that a string can be included in an HTML tag attribute
 * value within double or single quotes.
 *
 * It should be noted that > doesn't need to be escaped for the HTML or XML to
 * be valid, but it has been decided to escape it for consistency with other
 * implementations.
 *
 * With goog.string.DETECT_DOUBLE_ESCAPING, this function escapes also the
 * lowercase letter "e".
 *
 * NOTE(user):
 * HtmlEscape is often called during the generation of large blocks of HTML.
 * Using statics for the regular expressions and strings is an optimization
 * that can more than half the amount of time IE spends in this function for
 * large apps, since strings and regexes both contribute to GC allocations.
 *
 * Testing for the presence of a character before escaping increases the number
 * of function calls, but actually provides a speed increase for the average
 * case -- since the average case often doesn't require the escaping of all 4
 * characters and indexOf() is much cheaper than replace().
 * The worst case does suffer slightly from the additional calls, therefore the
 * opt_isLikelyToContainHtmlChars option has been included for situations
 * where all 4 HTML entities are very likely to be present and need escaping.
 *
 * Some benchmarks (times tended to fluctuate +-0.05ms):
 *                                     FireFox                     IE6
 * (no chars / average (mix of cases) / all 4 chars)
 * no checks                     0.13 / 0.22 / 0.22         0.23 / 0.53 / 0.80
 * indexOf                       0.08 / 0.17 / 0.26         0.22 / 0.54 / 0.84
 * indexOf + re test             0.07 / 0.17 / 0.28         0.19 / 0.50 / 0.85
 *
 * An additional advantage of checking if replace actually needs to be called
 * is a reduction in the number of object allocations, so as the size of the
 * application grows the difference between the various methods would increase.
 *
 * @param {string} str string to be escaped.
 * @param {boolean=} opt_isLikelyToContainHtmlChars Don't perform a check to see
 *     if the character needs replacing - use this option if you expect each of
 *     the characters to appear often. Leave false if you expect few html
 *     characters to occur in your strings, such as if you are escaping HTML.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.htmlEscape = function(str, opt_isLikelyToContainHtmlChars) {

  if (opt_isLikelyToContainHtmlChars) {
    str = str.replace(goog.string.AMP_RE_, '&amp;')
          .replace(goog.string.LT_RE_, '&lt;')
          .replace(goog.string.GT_RE_, '&gt;')
          .replace(goog.string.QUOT_RE_, '&quot;')
          .replace(goog.string.SINGLE_QUOTE_RE_, '&#39;')
          .replace(goog.string.NULL_RE_, '&#0;');
    if (goog.string.DETECT_DOUBLE_ESCAPING) {
      str = str.replace(goog.string.E_RE_, '&#101;');
    }
    return str;

  } else {
    // quick test helps in the case when there are no chars to replace, in
    // worst case this makes barely a difference to the time taken
    if (!goog.string.ALL_RE_.test(str)) return str;

    // str.indexOf is faster than regex.test in this case
    if (str.indexOf('&') != -1) {
      str = str.replace(goog.string.AMP_RE_, '&amp;');
    }
    if (str.indexOf('<') != -1) {
      str = str.replace(goog.string.LT_RE_, '&lt;');
    }
    if (str.indexOf('>') != -1) {
      str = str.replace(goog.string.GT_RE_, '&gt;');
    }
    if (str.indexOf('"') != -1) {
      str = str.replace(goog.string.QUOT_RE_, '&quot;');
    }
    if (str.indexOf('\'') != -1) {
      str = str.replace(goog.string.SINGLE_QUOTE_RE_, '&#39;');
    }
    if (str.indexOf('\x00') != -1) {
      str = str.replace(goog.string.NULL_RE_, '&#0;');
    }
    if (goog.string.DETECT_DOUBLE_ESCAPING && str.indexOf('e') != -1) {
      str = str.replace(goog.string.E_RE_, '&#101;');
    }
    return str;
  }
};


/**
 * Regular expression that matches an ampersand, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.AMP_RE_ = /&/g;


/**
 * Regular expression that matches a less than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.LT_RE_ = /</g;


/**
 * Regular expression that matches a greater than sign, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.GT_RE_ = />/g;


/**
 * Regular expression that matches a double quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.QUOT_RE_ = /"/g;


/**
 * Regular expression that matches a single quote, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.SINGLE_QUOTE_RE_ = /'/g;


/**
 * Regular expression that matches null character, for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.NULL_RE_ = /\x00/g;


/**
 * Regular expression that matches a lowercase letter "e", for use in escaping.
 * @const {!RegExp}
 * @private
 */
goog.string.E_RE_ = /e/g;


/**
 * Regular expression that matches any character that needs to be escaped.
 * @const {!RegExp}
 * @private
 */
goog.string.ALL_RE_ = (goog.string.DETECT_DOUBLE_ESCAPING ?
    /[\x00&<>"'e]/ :
    /[\x00&<>"']/);


/**
 * Unescapes an HTML string.
 *
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntities = function(str) {
  if (goog.string.contains(str, '&')) {
    // We are careful not to use a DOM if we do not have one. We use the []
    // notation so that the JSCompiler will not complain about these objects and
    // fields in the case where we have no DOM.
    if ('document' in goog.global) {
      return goog.string.unescapeEntitiesUsingDom_(str);
    } else {
      // Fall back on pure XML entities
      return goog.string.unescapePureXmlEntities_(str);
    }
  }
  return str;
};


/**
 * Unescapes a HTML string using the provided document.
 *
 * @param {string} str The string to unescape.
 * @param {!Document} document A document to use in escaping the string.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapeEntitiesWithDocument = function(str, document) {
  if (goog.string.contains(str, '&')) {
    return goog.string.unescapeEntitiesUsingDom_(str, document);
  }
  return str;
};


/**
 * Unescapes an HTML string using a DOM to resolve non-XML, non-numeric
 * entities. This function is XSS-safe and whitespace-preserving.
 * @private
 * @param {string} str The string to unescape.
 * @param {Document=} opt_document An optional document to use for creating
 *     elements. If this is not specified then the default window.document
 *     will be used.
 * @return {string} The unescaped {@code str} string.
 */
goog.string.unescapeEntitiesUsingDom_ = function(str, opt_document) {
  var seen = {'&amp;': '&', '&lt;': '<', '&gt;': '>', '&quot;': '"'};
  var div;
  if (opt_document) {
    div = opt_document.createElement('div');
  } else {
    div = goog.global.document.createElement('div');
  }
  // Match as many valid entity characters as possible. If the actual entity
  // happens to be shorter, it will still work as innerHTML will return the
  // trailing characters unchanged. Since the entity characters do not include
  // open angle bracket, there is no chance of XSS from the innerHTML use.
  // Since no whitespace is passed to innerHTML, whitespace is preserved.
  return str.replace(goog.string.HTML_ENTITY_PATTERN_, function(s, entity) {
    // Check for cached entity.
    var value = seen[s];
    if (value) {
      return value;
    }
    // Check for numeric entity.
    if (entity.charAt(0) == '#') {
      // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex numbers.
      var n = Number('0' + entity.substr(1));
      if (!isNaN(n)) {
        value = String.fromCharCode(n);
      }
    }
    // Fall back to innerHTML otherwise.
    if (!value) {
      // Append a non-entity character to avoid a bug in Webkit that parses
      // an invalid entity at the end of innerHTML text as the empty string.
      div.innerHTML = s + ' ';
      // Then remove the trailing character from the result.
      value = div.firstChild.nodeValue.slice(0, -1);
    }
    // Cache and return.
    return seen[s] = value;
  });
};


/**
 * Unescapes XML entities.
 * @private
 * @param {string} str The string to unescape.
 * @return {string} An unescaped copy of {@code str}.
 */
goog.string.unescapePureXmlEntities_ = function(str) {
  return str.replace(/&([^;]+);/g, function(s, entity) {
    switch (entity) {
      case 'amp':
        return '&';
      case 'lt':
        return '<';
      case 'gt':
        return '>';
      case 'quot':
        return '"';
      default:
        if (entity.charAt(0) == '#') {
          // Prefix with 0 so that hex entities (e.g. &#x10) parse as hex.
          var n = Number('0' + entity.substr(1));
          if (!isNaN(n)) {
            return String.fromCharCode(n);
          }
        }
        // For invalid entities we just return the entity
        return s;
    }
  });
};


/**
 * Regular expression that matches an HTML entity.
 * See also HTML5: Tokenization / Tokenizing character references.
 * @private
 * @type {!RegExp}
 */
goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;


/**
 * Do escaping of whitespace to preserve spatial formatting. We use character
 * entity #160 to make it safer for xml.
 * @param {string} str The string in which to escape whitespace.
 * @param {boolean=} opt_xml Whether to use XML compatible tags.
 * @return {string} An escaped copy of {@code str}.
 */
goog.string.whitespaceEscape = function(str, opt_xml) {
  // This doesn't use goog.string.preserveSpaces for backwards compatibility.
  return goog.string.newLineToBr(str.replace(/  /g, ' &#160;'), opt_xml);
};


/**
 * Preserve spaces that would be otherwise collapsed in HTML by replacing them
 * with non-breaking space Unicode characters.
 * @param {string} str The string in which to preserve whitespace.
 * @return {string} A copy of {@code str} with preserved whitespace.
 */
goog.string.preserveSpaces = function(str) {
  return str.replace(/(^|[\n ]) /g, '$1' + goog.string.Unicode.NBSP);
};


/**
 * Strip quote characters around a string.  The second argument is a string of
 * characters to treat as quotes.  This can be a single character or a string of
 * multiple character and in that case each of those are treated as possible
 * quote characters. For example:
 *
 * <pre>
 * goog.string.stripQuotes('"abc"', '"`') --> 'abc'
 * goog.string.stripQuotes('`abc`', '"`') --> 'abc'
 * </pre>
 *
 * @param {string} str The string to strip.
 * @param {string} quoteChars The quote characters to strip.
 * @return {string} A copy of {@code str} without the quotes.
 */
goog.string.stripQuotes = function(str, quoteChars) {
  var length = quoteChars.length;
  for (var i = 0; i < length; i++) {
    var quoteChar = length == 1 ? quoteChars : quoteChars.charAt(i);
    if (str.charAt(0) == quoteChar && str.charAt(str.length - 1) == quoteChar) {
      return str.substring(1, str.length - 1);
    }
  }
  return str;
};


/**
 * Truncates a string to a certain length and adds '...' if necessary.  The
 * length also accounts for the ellipsis, so a maximum length of 10 and a string
 * 'Hello World!' produces 'Hello W...'.
 * @param {string} str The string to truncate.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cut off in the middle.
 * @return {string} The truncated {@code str} string.
 */
goog.string.truncate = function(str, chars, opt_protectEscapedCharacters) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (str.length > chars) {
    str = str.substring(0, chars - 3) + '...';
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Truncate a string in the middle, adding "..." if necessary,
 * and favoring the beginning of the string.
 * @param {string} str The string to truncate the middle of.
 * @param {number} chars Max number of characters.
 * @param {boolean=} opt_protectEscapedCharacters Whether to protect escaped
 *     characters from being cutoff in the middle.
 * @param {number=} opt_trailingChars Optional number of trailing characters to
 *     leave at the end of the string, instead of truncating as close to the
 *     middle as possible.
 * @return {string} A truncated copy of {@code str}.
 */
goog.string.truncateMiddle = function(str, chars,
    opt_protectEscapedCharacters, opt_trailingChars) {
  if (opt_protectEscapedCharacters) {
    str = goog.string.unescapeEntities(str);
  }

  if (opt_trailingChars && str.length > chars) {
    if (opt_trailingChars > chars) {
      opt_trailingChars = chars;
    }
    var endPoint = str.length - opt_trailingChars;
    var startPoint = chars - opt_trailingChars;
    str = str.substring(0, startPoint) + '...' + str.substring(endPoint);
  } else if (str.length > chars) {
    // Favor the beginning of the string:
    var half = Math.floor(chars / 2);
    var endPos = str.length - half;
    half += chars % 2;
    str = str.substring(0, half) + '...' + str.substring(endPos);
  }

  if (opt_protectEscapedCharacters) {
    str = goog.string.htmlEscape(str);
  }

  return str;
};


/**
 * Special chars that need to be escaped for goog.string.quote.
 * @private
 * @type {Object}
 */
goog.string.specialEscapeChars_ = {
  '\0': '\\0',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\x0B': '\\x0B', // '\v' is not supported in JScript
  '"': '\\"',
  '\\': '\\\\'
};


/**
 * Character mappings used internally for goog.string.escapeChar.
 * @private
 * @type {Object}
 */
goog.string.jsEscapeCache_ = {
  '\'': '\\\''
};


/**
 * Encloses a string in double quotes and escapes characters so that the
 * string is a valid JS string.
 * @param {string} s The string to quote.
 * @return {string} A copy of {@code s} surrounded by double quotes.
 */
goog.string.quote = function(s) {
  s = String(s);
  if (s.quote) {
    return s.quote();
  } else {
    var sb = ['"'];
    for (var i = 0; i < s.length; i++) {
      var ch = s.charAt(i);
      var cc = ch.charCodeAt(0);
      sb[i + 1] = goog.string.specialEscapeChars_[ch] ||
          ((cc > 31 && cc < 127) ? ch : goog.string.escapeChar(ch));
    }
    sb.push('"');
    return sb.join('');
  }
};


/**
 * Takes a string and returns the escaped string for that character.
 * @param {string} str The string to escape.
 * @return {string} An escaped string representing {@code str}.
 */
goog.string.escapeString = function(str) {
  var sb = [];
  for (var i = 0; i < str.length; i++) {
    sb[i] = goog.string.escapeChar(str.charAt(i));
  }
  return sb.join('');
};


/**
 * Takes a character and returns the escaped string for that character. For
 * example escapeChar(String.fromCharCode(15)) -> "\\x0E".
 * @param {string} c The character to escape.
 * @return {string} An escaped string representing {@code c}.
 */
goog.string.escapeChar = function(c) {
  if (c in goog.string.jsEscapeCache_) {
    return goog.string.jsEscapeCache_[c];
  }

  if (c in goog.string.specialEscapeChars_) {
    return goog.string.jsEscapeCache_[c] = goog.string.specialEscapeChars_[c];
  }

  var rv = c;
  var cc = c.charCodeAt(0);
  if (cc > 31 && cc < 127) {
    rv = c;
  } else {
    // tab is 9 but handled above
    if (cc < 256) {
      rv = '\\x';
      if (cc < 16 || cc > 256) {
        rv += '0';
      }
    } else {
      rv = '\\u';
      if (cc < 4096) { // \u1000
        rv += '0';
      }
    }
    rv += cc.toString(16).toUpperCase();
  }

  return goog.string.jsEscapeCache_[c] = rv;
};


/**
 * Takes a string and creates a map (Object) in which the keys are the
 * characters in the string. The value for the key is set to true. You can
 * then use goog.object.map or goog.array.map to change the values.
 * @param {string} s The string to build the map from.
 * @return {!Object} The map of characters used.
 */
// TODO(arv): It seems like we should have a generic goog.array.toMap. But do
//            we want a dependency on goog.array in goog.string?
goog.string.toMap = function(s) {
  var rv = {};
  for (var i = 0; i < s.length; i++) {
    rv[s.charAt(i)] = true;
  }
  return rv;
};


/**
 * Determines whether a string contains a substring.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether {@code str} contains {@code subString}.
 */
goog.string.contains = function(str, subString) {
  return str.indexOf(subString) != -1;
};


/**
 * Determines whether a string contains a substring, ignoring case.
 * @param {string} str The string to search.
 * @param {string} subString The substring to search for.
 * @return {boolean} Whether {@code str} contains {@code subString}.
 */
goog.string.caseInsensitiveContains = function(str, subString) {
  return goog.string.contains(str.toLowerCase(), subString.toLowerCase());
};


/**
 * Returns the non-overlapping occurrences of ss in s.
 * If either s or ss evalutes to false, then returns zero.
 * @param {string} s The string to look in.
 * @param {string} ss The string to look for.
 * @return {number} Number of occurrences of ss in s.
 */
goog.string.countOf = function(s, ss) {
  return s && ss ? s.split(ss).length - 1 : 0;
};


/**
 * Removes a substring of a specified length at a specific
 * index in a string.
 * @param {string} s The base string from which to remove.
 * @param {number} index The index at which to remove the substring.
 * @param {number} stringLength The length of the substring to remove.
 * @return {string} A copy of {@code s} with the substring removed or the full
 *     string if nothing is removed or the input is invalid.
 */
goog.string.removeAt = function(s, index, stringLength) {
  var resultStr = s;
  // If the index is greater or equal to 0 then remove substring
  if (index >= 0 && index < s.length && stringLength > 0) {
    resultStr = s.substr(0, index) +
        s.substr(index + stringLength, s.length - index - stringLength);
  }
  return resultStr;
};


/**
 *  Removes the first occurrence of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.remove = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), '');
  return s.replace(re, '');
};


/**
 *  Removes all occurrences of a substring from a string.
 *  @param {string} s The base string from which to remove.
 *  @param {string} ss The string to remove.
 *  @return {string} A copy of {@code s} with {@code ss} removed or the full
 *      string if nothing is removed.
 */
goog.string.removeAll = function(s, ss) {
  var re = new RegExp(goog.string.regExpEscape(ss), 'g');
  return s.replace(re, '');
};


/**
 * Escapes characters in the string that are not safe to use in a RegExp.
 * @param {*} s The string to escape. If not a string, it will be casted
 *     to one.
 * @return {string} A RegExp safe, escaped copy of {@code s}.
 */
goog.string.regExpEscape = function(s) {
  return String(s).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').
      replace(/\x08/g, '\\x08');
};


/**
 * Repeats a string n times.
 * @param {string} string The string to repeat.
 * @param {number} length The number of times to repeat.
 * @return {string} A string containing {@code length} repetitions of
 *     {@code string}.
 */
goog.string.repeat = function(string, length) {
  return new Array(length + 1).join(string);
};


/**
 * Pads number to given length and optionally rounds it to a given precision.
 * For example:
 * <pre>padNumber(1.25, 2, 3) -> '01.250'
 * padNumber(1.25, 2) -> '01.25'
 * padNumber(1.25, 2, 1) -> '01.3'
 * padNumber(1.25, 0) -> '1.25'</pre>
 *
 * @param {number} num The number to pad.
 * @param {number} length The desired length.
 * @param {number=} opt_precision The desired precision.
 * @return {string} {@code num} as a string with the given options.
 */
goog.string.padNumber = function(num, length, opt_precision) {
  var s = goog.isDef(opt_precision) ? num.toFixed(opt_precision) : String(num);
  var index = s.indexOf('.');
  if (index == -1) {
    index = s.length;
  }
  return goog.string.repeat('0', Math.max(0, length - index)) + s;
};


/**
 * Returns a string representation of the given object, with
 * null and undefined being returned as the empty string.
 *
 * @param {*} obj The object to convert.
 * @return {string} A string representation of the {@code obj}.
 */
goog.string.makeSafe = function(obj) {
  return obj == null ? '' : String(obj);
};


/**
 * Concatenates string expressions. This is useful
 * since some browsers are very inefficient when it comes to using plus to
 * concat strings. Be careful when using null and undefined here since
 * these will not be included in the result. If you need to represent these
 * be sure to cast the argument to a String first.
 * For example:
 * <pre>buildString('a', 'b', 'c', 'd') -> 'abcd'
 * buildString(null, undefined) -> ''
 * </pre>
 * @param {...*} var_args A list of strings to concatenate. If not a string,
 *     it will be casted to one.
 * @return {string} The concatenation of {@code var_args}.
 */
goog.string.buildString = function(var_args) {
  return Array.prototype.join.call(arguments, '');
};


/**
 * Returns a string with at least 64-bits of randomness.
 *
 * Doesn't trust Javascript's random function entirely. Uses a combination of
 * random and current timestamp, and then encodes the string in base-36 to
 * make it shorter.
 *
 * @return {string} A random string, e.g. sn1s7vb4gcic.
 */
goog.string.getRandomString = function() {
  var x = 2147483648;
  return Math.floor(Math.random() * x).toString(36) +
         Math.abs(Math.floor(Math.random() * x) ^ goog.now()).toString(36);
};


/**
 * Compares two version numbers.
 *
 * @param {string|number} version1 Version of first item.
 * @param {string|number} version2 Version of second item.
 *
 * @return {number}  1 if {@code version1} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code version2} is higher.
 */
goog.string.compareVersions = function(version1, version2) {
  var order = 0;
  // Trim leading and trailing whitespace and split the versions into
  // subversions.
  var v1Subs = goog.string.trim(String(version1)).split('.');
  var v2Subs = goog.string.trim(String(version2)).split('.');
  var subCount = Math.max(v1Subs.length, v2Subs.length);

  // Iterate over the subversions, as long as they appear to be equivalent.
  for (var subIdx = 0; order == 0 && subIdx < subCount; subIdx++) {
    var v1Sub = v1Subs[subIdx] || '';
    var v2Sub = v2Subs[subIdx] || '';

    // Split the subversions into pairs of numbers and qualifiers (like 'b').
    // Two different RegExp objects are needed because they are both using
    // the 'g' flag.
    var v1CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    var v2CompParser = new RegExp('(\\d*)(\\D*)', 'g');
    do {
      var v1Comp = v1CompParser.exec(v1Sub) || ['', '', ''];
      var v2Comp = v2CompParser.exec(v2Sub) || ['', '', ''];
      // Break if there are no more matches.
      if (v1Comp[0].length == 0 && v2Comp[0].length == 0) {
        break;
      }

      // Parse the numeric part of the subversion. A missing number is
      // equivalent to 0.
      var v1CompNum = v1Comp[1].length == 0 ? 0 : parseInt(v1Comp[1], 10);
      var v2CompNum = v2Comp[1].length == 0 ? 0 : parseInt(v2Comp[1], 10);

      // Compare the subversion components. The number has the highest
      // precedence. Next, if the numbers are equal, a subversion without any
      // qualifier is always higher than a subversion with any qualifier. Next,
      // the qualifiers are compared as strings.
      order = goog.string.compareElements_(v1CompNum, v2CompNum) ||
          goog.string.compareElements_(v1Comp[2].length == 0,
              v2Comp[2].length == 0) ||
          goog.string.compareElements_(v1Comp[2], v2Comp[2]);
      // Stop as soon as an inequality is discovered.
    } while (order == 0);
  }

  return order;
};


/**
 * Compares elements of a version number.
 *
 * @param {string|number|boolean} left An element from a version number.
 * @param {string|number|boolean} right An element from a version number.
 *
 * @return {number}  1 if {@code left} is higher.
 *                   0 if arguments are equal.
 *                  -1 if {@code right} is higher.
 * @private
 */
goog.string.compareElements_ = function(left, right) {
  if (left < right) {
    return -1;
  } else if (left > right) {
    return 1;
  }
  return 0;
};


/**
 * Maximum value of #goog.string.hashCode, exclusive. 2^32.
 * @type {number}
 * @private
 */
goog.string.HASHCODE_MAX_ = 0x100000000;


/**
 * String hash function similar to java.lang.String.hashCode().
 * The hash code for a string is computed as
 * s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
 * where s[i] is the ith character of the string and n is the length of
 * the string. We mod the result to make it between 0 (inclusive) and 2^32
 * (exclusive).
 * @param {string} str A string.
 * @return {number} Hash value for {@code str}, between 0 (inclusive) and 2^32
 *  (exclusive). The empty string returns 0.
 */
goog.string.hashCode = function(str) {
  var result = 0;
  for (var i = 0; i < str.length; ++i) {
    result = 31 * result + str.charCodeAt(i);
    // Normalize to 4 byte range, 0 ... 2^32.
    result %= goog.string.HASHCODE_MAX_;
  }
  return result;
};


/**
 * The most recent unique ID. |0 is equivalent to Math.floor in this case.
 * @type {number}
 * @private
 */
goog.string.uniqueStringCounter_ = Math.random() * 0x80000000 | 0;


/**
 * Generates and returns a string which is unique in the current document.
 * This is useful, for example, to create unique IDs for DOM elements.
 * @return {string} A unique id.
 */
goog.string.createUniqueString = function() {
  return 'goog_' + goog.string.uniqueStringCounter_++;
};


/**
 * Converts the supplied string to a number, which may be Infinity or NaN.
 * This function strips whitespace: (toNumber(' 123') === 123)
 * This function accepts scientific notation: (toNumber('1e1') === 10)
 *
 * This is better than Javascript's built-in conversions because, sadly:
 *     (Number(' ') === 0) and (parseFloat('123a') === 123)
 *
 * @param {string} str The string to convert.
 * @return {number} The number the supplied string represents, or NaN.
 */
goog.string.toNumber = function(str) {
  var num = Number(str);
  if (num == 0 && goog.string.isEmpty(str)) {
    return NaN;
  }
  return num;
};


/**
 * Returns whether the given string is lower camel case (e.g. "isFooBar").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is lower camel case.
 */
goog.string.isLowerCamelCase = function(str) {
  return /^[a-z]+([A-Z][a-z]*)*$/.test(str);
};


/**
 * Returns whether the given string is upper camel case (e.g. "FooBarBaz").
 *
 * Note that this assumes the string is entirely letters.
 * @see http://en.wikipedia.org/wiki/CamelCase#Variations_and_synonyms
 *
 * @param {string} str String to test.
 * @return {boolean} Whether the string is upper camel case.
 */
goog.string.isUpperCamelCase = function(str) {
  return /^([A-Z][a-z]*)+$/.test(str);
};


/**
 * Converts a string from selector-case to camelCase (e.g. from
 * "multi-part-string" to "multiPartString"), useful for converting
 * CSS selectors and HTML dataset keys to their equivalent JS properties.
 * @param {string} str The string in selector-case form.
 * @return {string} The string in camelCase form.
 */
goog.string.toCamelCase = function(str) {
  return String(str).replace(/\-([a-z])/g, function(all, match) {
    return match.toUpperCase();
  });
};


/**
 * Converts a string from camelCase to selector-case (e.g. from
 * "multiPartString" to "multi-part-string"), useful for converting JS
 * style and dataset properties to equivalent CSS selectors and HTML keys.
 * @param {string} str The string in camelCase form.
 * @return {string} The string in selector-case form.
 */
goog.string.toSelectorCase = function(str) {
  return String(str).replace(/([A-Z])/g, '-$1').toLowerCase();
};


/**
 * Converts a string into TitleCase. First character of the string is always
 * capitalized in addition to the first letter of every subsequent word.
 * Words are delimited by one or more whitespaces by default. Custom delimiters
 * can optionally be specified to replace the default, which doesn't preserve
 * whitespace delimiters and instead must be explicitly included if needed.
 *
 * Default delimiter => " ":
 *    goog.string.toTitleCase('oneTwoThree')    => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three')  => 'One Two Three'
 *    goog.string.toTitleCase('  one   two   ') => '  One   Two   '
 *    goog.string.toTitleCase('one_two_three')  => 'One_two_three'
 *    goog.string.toTitleCase('one-two-three')  => 'One-two-three'
 *
 * Custom delimiter => "_-.":
 *    goog.string.toTitleCase('oneTwoThree', '_-.')       => 'OneTwoThree'
 *    goog.string.toTitleCase('one two three', '_-.')     => 'One two three'
 *    goog.string.toTitleCase('  one   two   ', '_-.')    => '  one   two   '
 *    goog.string.toTitleCase('one_two_three', '_-.')     => 'One_Two_Three'
 *    goog.string.toTitleCase('one-two-three', '_-.')     => 'One-Two-Three'
 *    goog.string.toTitleCase('one...two...three', '_-.') => 'One...Two...Three'
 *    goog.string.toTitleCase('one. two. three', '_-.')   => 'One. two. three'
 *    goog.string.toTitleCase('one-two.three', '_-.')     => 'One-Two.Three'
 *
 * @param {string} str String value in camelCase form.
 * @param {string=} opt_delimiters Custom delimiter character set used to
 *      distinguish words in the string value. Each character represents a
 *      single delimiter. When provided, default whitespace delimiter is
 *      overridden and must be explicitly included if needed.
 * @return {string} String value in TitleCase form.
 */
goog.string.toTitleCase = function(str, opt_delimiters) {
  var delimiters = goog.isString(opt_delimiters) ?
      goog.string.regExpEscape(opt_delimiters) : '\\s';

  // For IE8, we need to prevent using an empty character set. Otherwise,
  // incorrect matching will occur.
  delimiters = delimiters ? '|[' + delimiters + ']+' : '';

  var regexp = new RegExp('(^' + delimiters + ')([a-z])', 'g');
  return str.replace(regexp, function(all, p1, p2) {
    return p1 + p2.toUpperCase();
  });
};


/**
 * Parse a string in decimal or hexidecimal ('0xFFFF') form.
 *
 * To parse a particular radix, please use parseInt(string, radix) directly. See
 * https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/parseInt
 *
 * This is a wrapper for the built-in parseInt function that will only parse
 * numbers as base 10 or base 16.  Some JS implementations assume strings
 * starting with "0" are intended to be octal. ES3 allowed but discouraged
 * this behavior. ES5 forbids it.  This function emulates the ES5 behavior.
 *
 * For more information, see Mozilla JS Reference: http://goo.gl/8RiFj
 *
 * @param {string|number|null|undefined} value The value to be parsed.
 * @return {number} The number, parsed. If the string failed to parse, this
 *     will be NaN.
 */
goog.string.parseInt = function(value) {
  // Force finite numbers to strings.
  if (isFinite(value)) {
    value = String(value);
  }

  if (goog.isString(value)) {
    // If the string starts with '0x' or '-0x', parse as hex.
    return /^\s*-?0x/i.test(value) ?
        parseInt(value, 16) : parseInt(value, 10);
  }

  return NaN;
};


/**
 * Splits a string on a separator a limited number of times.
 *
 * This implementation is more similar to Python or Java, where the limit
 * parameter specifies the maximum number of splits rather than truncating
 * the number of results.
 *
 * See http://docs.python.org/2/library/stdtypes.html#str.split
 * See JavaDoc: http://goo.gl/F2AsY
 * See Mozilla reference: http://goo.gl/dZdZs
 *
 * @param {string} str String to split.
 * @param {string} separator The separator.
 * @param {number} limit The limit to the number of splits. The resulting array
 *     will have a maximum length of limit+1.  Negative numbers are the same
 *     as zero.
 * @return {!Array.<string>} The string, split.
 */

goog.string.splitLimit = function(str, separator, limit) {
  var parts = str.split(separator);
  var returnVal = [];

  // Only continue doing this while we haven't hit the limit and we have
  // parts left.
  while (limit > 0 && parts.length) {
    returnVal.push(parts.shift());
    limit--;
  }

  // If there are remaining parts, append them to the end.
  if (parts.length) {
    returnVal.push(parts.join(separator));
  }

  return returnVal;
};

// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities to check the preconditions, postconditions and
 * invariants runtime.
 *
 * Methods in this package should be given special treatment by the compiler
 * for type-inference. For example, <code>goog.asserts.assert(foo)</code>
 * will restrict <code>foo</code> to a truthy value.
 *
 * The compiler has an option to disable asserts. So code like:
 * <code>
 * var x = goog.asserts.assert(foo()); goog.asserts.assert(bar());
 * </code>
 * will be transformed into:
 * <code>
 * var x = foo();
 * </code>
 * The compiler will leave in foo() (because its return value is used),
 * but it will remove bar() because it assumes it does not have side-effects.
 *
 */

goog.provide('goog.asserts');
goog.provide('goog.asserts.AssertionError');

goog.require('goog.debug.Error');
goog.require('goog.dom.NodeType');
goog.require('goog.string');


/**
 * @define {boolean} Whether to strip out asserts or to leave them in.
 */
goog.define('goog.asserts.ENABLE_ASSERTS', goog.DEBUG);



/**
 * Error object for failed assertions.
 * @param {string} messagePattern The pattern that was used to form message.
 * @param {!Array.<*>} messageArgs The items to substitute into the pattern.
 * @constructor
 * @extends {goog.debug.Error}
 * @final
 */
goog.asserts.AssertionError = function(messagePattern, messageArgs) {
  messageArgs.unshift(messagePattern);
  goog.debug.Error.call(this, goog.string.subs.apply(null, messageArgs));
  // Remove the messagePattern afterwards to avoid permenantly modifying the
  // passed in array.
  messageArgs.shift();

  /**
   * The message pattern used to format the error message. Error handlers can
   * use this to uniquely identify the assertion.
   * @type {string}
   */
  this.messagePattern = messagePattern;
};
goog.inherits(goog.asserts.AssertionError, goog.debug.Error);


/** @override */
goog.asserts.AssertionError.prototype.name = 'AssertionError';


/**
 * Throws an exception with the given message and "Assertion failed" prefixed
 * onto it.
 * @param {string} defaultMessage The message to use if givenMessage is empty.
 * @param {Array.<*>} defaultArgs The substitution arguments for defaultMessage.
 * @param {string|undefined} givenMessage Message supplied by the caller.
 * @param {Array.<*>} givenArgs The substitution arguments for givenMessage.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 * @private
 */
goog.asserts.doAssertFailure_ =
    function(defaultMessage, defaultArgs, givenMessage, givenArgs) {
  var message = 'Assertion failed';
  if (givenMessage) {
    message += ': ' + givenMessage;
    var args = givenArgs;
  } else if (defaultMessage) {
    message += ': ' + defaultMessage;
    args = defaultArgs;
  }
  // The '' + works around an Opera 10 bug in the unit tests. Without it,
  // a stack trace is added to var message above. With this, a stack trace is
  // not added until this line (it causes the extra garbage to be added after
  // the assertion message instead of in the middle of it).
  throw new goog.asserts.AssertionError('' + message, args || []);
};


/**
 * Checks if the condition evaluates to true if goog.asserts.ENABLE_ASSERTS is
 * true.
 * @template T
 * @param {T} condition The condition to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {T} The value of the condition.
 * @throws {goog.asserts.AssertionError} When the condition evaluates to false.
 */
goog.asserts.assert = function(condition, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !condition) {
    goog.asserts.doAssertFailure_('', null, opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return condition;
};


/**
 * Fails if goog.asserts.ENABLE_ASSERTS is true. This function is useful in case
 * when we want to add a check in the unreachable area like switch-case
 * statement:
 *
 * <pre>
 *  switch(type) {
 *    case FOO: doSomething(); break;
 *    case BAR: doSomethingElse(); break;
 *    default: goog.assert.fail('Unrecognized type: ' + type);
 *      // We have only 2 types - "default:" section is unreachable code.
 *  }
 * </pre>
 *
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} Failure.
 */
goog.asserts.fail = function(opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS) {
    throw new goog.asserts.AssertionError(
        'Failure' + (opt_message ? ': ' + opt_message : ''),
        Array.prototype.slice.call(arguments, 1));
  }
};


/**
 * Checks if the value is a number if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {number} The value, guaranteed to be a number when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a number.
 */
goog.asserts.assertNumber = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isNumber(value)) {
    goog.asserts.doAssertFailure_('Expected number but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {number} */ (value);
};


/**
 * Checks if the value is a string if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {string} The value, guaranteed to be a string when asserts enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a string.
 */
goog.asserts.assertString = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isString(value)) {
    goog.asserts.doAssertFailure_('Expected string but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {string} */ (value);
};


/**
 * Checks if the value is a function if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Function} The value, guaranteed to be a function when asserts
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a function.
 */
goog.asserts.assertFunction = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isFunction(value)) {
    goog.asserts.doAssertFailure_('Expected function but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Function} */ (value);
};


/**
 * Checks if the value is an Object if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Object} The value, guaranteed to be a non-null object.
 * @throws {goog.asserts.AssertionError} When the value is not an object.
 */
goog.asserts.assertObject = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isObject(value)) {
    goog.asserts.doAssertFailure_('Expected object but got %s: %s.',
        [goog.typeOf(value), value],
        opt_message, Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Object} */ (value);
};


/**
 * Checks if the value is an Array if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Array} The value, guaranteed to be a non-null array.
 * @throws {goog.asserts.AssertionError} When the value is not an array.
 */
goog.asserts.assertArray = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isArray(value)) {
    goog.asserts.doAssertFailure_('Expected array but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Array} */ (value);
};


/**
 * Checks if the value is a boolean if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {boolean} The value, guaranteed to be a boolean when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertBoolean = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !goog.isBoolean(value)) {
    goog.asserts.doAssertFailure_('Expected boolean but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {boolean} */ (value);
};


/**
 * Checks if the value is a DOM Element if goog.asserts.ENABLE_ASSERTS is true.
 * @param {*} value The value to check.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @return {!Element} The value, likely to be a DOM Element when asserts are
 *     enabled.
 * @throws {goog.asserts.AssertionError} When the value is not a boolean.
 */
goog.asserts.assertElement = function(value, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && (!goog.isObject(value) ||
      value.nodeType != goog.dom.NodeType.ELEMENT)) {
    goog.asserts.doAssertFailure_('Expected Element but got %s: %s.',
        [goog.typeOf(value), value], opt_message,
        Array.prototype.slice.call(arguments, 2));
  }
  return /** @type {!Element} */ (value);
};


/**
 * Checks if the value is an instance of the user-defined type if
 * goog.asserts.ENABLE_ASSERTS is true.
 *
 * The compiler may tighten the type returned by this function.
 *
 * @param {*} value The value to check.
 * @param {function(new: T, ...)} type A user-defined constructor.
 * @param {string=} opt_message Error message in case of failure.
 * @param {...*} var_args The items to substitute into the failure message.
 * @throws {goog.asserts.AssertionError} When the value is not an instance of
 *     type.
 * @return {!T}
 * @template T
 */
goog.asserts.assertInstanceof = function(value, type, opt_message, var_args) {
  if (goog.asserts.ENABLE_ASSERTS && !(value instanceof type)) {
    goog.asserts.doAssertFailure_('instanceof check failed.', null,
        opt_message, Array.prototype.slice.call(arguments, 3));
  }
  return value;
};


/**
 * Checks that no enumerable keys are present in Object.prototype. Such keys
 * would break most code that use {@code for (var ... in ...)} loops.
 */
goog.asserts.assertObjectPrototypeIsIntact = function() {
  for (var key in Object.prototype) {
    goog.asserts.fail(key + ' should not be enumerable in Object.prototype.');
  }
};
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An interface for a listenable JavaScript object.
 */

goog.provide('goog.events.Listenable');
goog.provide('goog.events.ListenableKey');

/** @suppress {extraRequire} */
goog.require('goog.events.EventId');



/**
 * A listenable interface. A listenable is an object with the ability
 * to dispatch/broadcast events to "event listeners" registered via
 * listen/listenOnce.
 *
 * The interface allows for an event propagation mechanism similar
 * to one offered by native browser event targets, such as
 * capture/bubble mechanism, stopping propagation, and preventing
 * default actions. Capture/bubble mechanism depends on the ancestor
 * tree constructed via {@code #getParentEventTarget}; this tree
 * must be directed acyclic graph. The meaning of default action(s)
 * in preventDefault is specific to a particular use case.
 *
 * Implementations that do not support capture/bubble or can not have
 * a parent listenable can simply not implement any ability to set the
 * parent listenable (and have {@code #getParentEventTarget} return
 * null).
 *
 * Implementation of this class can be used with or independently from
 * goog.events.
 *
 * Implementation must call {@code #addImplementation(implClass)}.
 *
 * @interface
 * @see goog.events
 * @see http://www.w3.org/TR/DOM-Level-2-Events/events.html
 */
goog.events.Listenable = function() {};


/**
 * An expando property to indicate that an object implements
 * goog.events.Listenable.
 *
 * See addImplementation/isImplementedBy.
 *
 * @type {string}
 * @const
 */
goog.events.Listenable.IMPLEMENTED_BY_PROP =
    'closure_listenable_' + ((Math.random() * 1e6) | 0);


/**
 * Marks a given class (constructor) as an implementation of
 * Listenable, do that we can query that fact at runtime. The class
 * must have already implemented the interface.
 * @param {!Function} cls The class constructor. The corresponding
 *     class must have already implemented the interface.
 */
goog.events.Listenable.addImplementation = function(cls) {
  cls.prototype[goog.events.Listenable.IMPLEMENTED_BY_PROP] = true;
};


/**
 * @param {Object} obj The object to check.
 * @return {boolean} Whether a given instance implements Listenable. The
 *     class/superclass of the instance must call addImplementation.
 */
goog.events.Listenable.isImplementedBy = function(obj) {
  return !!(obj && obj[goog.events.Listenable.IMPLEMENTED_BY_PROP]);
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listen;


/**
 * Adds an event listener that is removed automatically after the
 * listener fired once.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.listenOnce;


/**
 * Removes an event listener which was added with listen() or listenOnce().
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The event type id.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener Callback
 *     method.
 * @param {boolean=} opt_useCapture Whether to fire in capture phase
 *     (defaults to false).
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call
 *     the listener.
 * @return {boolean} Whether any listener was removed.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.unlisten;


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {goog.events.ListenableKey} key The key returned by
 *     listen() or listenOnce().
 * @return {boolean} Whether any listener was removed.
 */
goog.events.Listenable.prototype.unlistenByKey;


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 */
goog.events.Listenable.prototype.dispatchEvent;


/**
 * Removes all listeners from this listenable. If type is specified,
 * it will only remove listeners of the particular type. otherwise all
 * registered listeners will be removed.
 *
 * @param {string=} opt_type Type of event to remove, default is to
 *     remove all types.
 * @return {number} Number of listeners removed.
 */
goog.events.Listenable.prototype.removeAllListeners;


/**
 * Returns the parent of this event target to use for capture/bubble
 * mechanism.
 *
 * NOTE(user): The name reflects the original implementation of
 * custom event target ({@code goog.events.EventTarget}). We decided
 * that changing the name is not worth it.
 *
 * @return {goog.events.Listenable} The parent EventTarget or null if
 *     there is no parent.
 */
goog.events.Listenable.prototype.getParentEventTarget;


/**
 * Fires all registered listeners in this listenable for the given
 * type and capture mode, passing them the given eventObject. This
 * does not perform actual capture/bubble. Only implementors of the
 * interface should be using this.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The type of the
 *     listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @param {EVENTOBJ} eventObject The event object to fire.
 * @return {boolean} Whether all listeners succeeded without
 *     attempting to prevent default behavior. If any listener returns
 *     false or called goog.events.Event#preventDefault, this returns
 *     false.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.fireListeners;


/**
 * Gets all listeners in this listenable for the given type and
 * capture mode.
 *
 * @param {string|!goog.events.EventId} type The type of the listeners to fire.
 * @param {boolean} capture The capture mode of the listeners to fire.
 * @return {!Array.<goog.events.ListenableKey>} An array of registered
 *     listeners.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.getListeners;


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>} type The name of the event
 *     without the 'on' prefix.
 * @param {function(this:SCOPE, EVENTOBJ):(boolean|undefined)} listener The
 *     listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {SCOPE=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 * @template SCOPE,EVENTOBJ
 */
goog.events.Listenable.prototype.getListener;


/**
 * Whether there is any active listeners matching the specified
 * signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {string|!goog.events.EventId.<EVENTOBJ>=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble
 *     listeners.
 * @return {boolean} Whether there is any active listeners matching
 *     the requested type and/or capture phase.
 * @template EVENTOBJ
 */
goog.events.Listenable.prototype.hasListener;



/**
 * An interface that describes a single registered listener.
 * @interface
 */
goog.events.ListenableKey = function() {};


/**
 * Counter used to create a unique key
 * @type {number}
 * @private
 */
goog.events.ListenableKey.counter_ = 0;


/**
 * Reserves a key to be used for ListenableKey#key field.
 * @return {number} A number to be used to fill ListenableKey#key
 *     field.
 */
goog.events.ListenableKey.reserveKey = function() {
  return ++goog.events.ListenableKey.counter_;
};


/**
 * The source event target.
 * @type {!(Object|goog.events.Listenable|goog.events.EventTarget)}
 */
goog.events.ListenableKey.prototype.src;


/**
 * The event type the listener is listening to.
 * @type {string}
 */
goog.events.ListenableKey.prototype.type;


/**
 * The listener function.
 * @type {function(?):?|{handleEvent:function(?):?}|null}
 */
goog.events.ListenableKey.prototype.listener;


/**
 * Whether the listener works on capture phase.
 * @type {boolean}
 */
goog.events.ListenableKey.prototype.capture;


/**
 * The 'this' object for the listener function's scope.
 * @type {Object}
 */
goog.events.ListenableKey.prototype.handler;


/**
 * A globally unique number to identify the key.
 * @type {number}
 */
goog.events.ListenableKey.prototype.key;
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Listener object.
 * @see ../demos/events.html
 */

goog.provide('goog.events.Listener');

goog.require('goog.events.ListenableKey');



/**
 * Simple class that stores information about a listener
 * @param {!Function} listener Callback function.
 * @param {Function} proxy Wrapper for the listener that patches the event.
 * @param {EventTarget|goog.events.Listenable} src Source object for
 *     the event.
 * @param {string} type Event type.
 * @param {boolean} capture Whether in capture or bubble phase.
 * @param {Object=} opt_handler Object in whose context to execute the callback.
 * @implements {goog.events.ListenableKey}
 * @constructor
 */
goog.events.Listener = function(
    listener, proxy, src, type, capture, opt_handler) {
  if (goog.events.Listener.ENABLE_MONITORING) {
    this.creationStack = new Error().stack;
  }

  /**
   * Callback function.
   * @type {Function}
   */
  this.listener = listener;

  /**
   * A wrapper over the original listener. This is used solely to
   * handle native browser events (it is used to simulate the capture
   * phase and to patch the event object).
   * @type {Function}
   */
  this.proxy = proxy;

  /**
   * Object or node that callback is listening to
   * @type {EventTarget|goog.events.Listenable}
   */
  this.src = src;

  /**
   * The event type.
   * @const {string}
   */
  this.type = type;

  /**
   * Whether the listener is being called in the capture or bubble phase
   * @const {boolean}
   */
  this.capture = !!capture;

  /**
   * Optional object whose context to execute the listener in
   * @type {Object|undefined}
   */
  this.handler = opt_handler;

  /**
   * The key of the listener.
   * @const {number}
   * @override
   */
  this.key = goog.events.ListenableKey.reserveKey();

  /**
   * Whether to remove the listener after it has been called.
   * @type {boolean}
   */
  this.callOnce = false;

  /**
   * Whether the listener has been removed.
   * @type {boolean}
   */
  this.removed = false;
};


/**
 * @define {boolean} Whether to enable the monitoring of the
 *     goog.events.Listener instances. Switching on the monitoring is only
 *     recommended for debugging because it has a significant impact on
 *     performance and memory usage. If switched off, the monitoring code
 *     compiles down to 0 bytes.
 */
goog.define('goog.events.Listener.ENABLE_MONITORING', false);


/**
 * If monitoring the goog.events.Listener instances is enabled, stores the
 * creation stack trace of the Disposable instance.
 * @type {string}
 */
goog.events.Listener.prototype.creationStack;


/**
 * Marks this listener as removed. This also remove references held by
 * this listener object (such as listener and event source).
 */
goog.events.Listener.prototype.markAsRemoved = function() {
  this.removed = true;
  this.listener = null;
  this.proxy = null;
  this.src = null;
  this.handler = null;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating objects/maps/hashes.
 */

goog.provide('goog.object');


/**
 * Calls a function for each element in an object/map/hash.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):?} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the object) and the return value is ignored.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @template T,K,V
 */
goog.object.forEach = function(obj, f, opt_obj) {
  for (var key in obj) {
    f.call(opt_obj, obj[key], key, obj);
  }
};


/**
 * Calls a function for each element in an object/map/hash. If that call returns
 * true, adds the element to a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to call
 *     for every element. This
 *     function takes 3 arguments (the element, the index and the object)
 *     and should return a boolean. If the return value is true the
 *     element is added to the result object. If it is false the
 *     element is not included.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,V>} a new object in which only elements that passed the
 *     test are present.
 * @template T,K,V
 */
goog.object.filter = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      res[key] = obj[key];
    }
  }
  return res;
};


/**
 * For every element in an object/map/hash calls a function and inserts the
 * result into a new object.
 *
 * @param {Object.<K,V>} obj The object over which to iterate.
 * @param {function(this:T,V,?,Object.<K,V>):R} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the object)
 *     and should return something. The result will be inserted
 *     into a new object.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {!Object.<K,R>} a new object with the results from f.
 * @template T,K,V,R
 */
goog.object.map = function(obj, f, opt_obj) {
  var res = {};
  for (var key in obj) {
    res[key] = f.call(opt_obj, obj[key], key, obj);
  }
  return res;
};


/**
 * Calls a function for each element in an object/map/hash. If any
 * call returns true, returns true (without checking the rest). If
 * all calls return false, returns false.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} true if any element passes the test.
 * @template T,K,V
 */
goog.object.some = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (f.call(opt_obj, obj[key], key, obj)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls a function for each element in an object/map/hash. If
 * all calls return true, returns true. If any call returns false, returns
 * false at this point and does not continue to check the remaining elements.
 *
 * @param {Object.<K,V>} obj The object to check.
 * @param {?function(this:T,V,?,Object.<K,V>):boolean} f The function to
 *     call for every element. This function
 *     takes 3 arguments (the element, the index and the object) and should
 *     return a boolean.
 * @param {T=} opt_obj This is used as the 'this' object within f.
 * @return {boolean} false if any element fails the test.
 * @template T,K,V
 */
goog.object.every = function(obj, f, opt_obj) {
  for (var key in obj) {
    if (!f.call(opt_obj, obj[key], key, obj)) {
      return false;
    }
  }
  return true;
};


/**
 * Returns the number of key-value pairs in the object map.
 *
 * @param {Object} obj The object for which to get the number of key-value
 *     pairs.
 * @return {number} The number of key-value pairs in the object map.
 */
goog.object.getCount = function(obj) {
  // JS1.5 has __count__ but it has been deprecated so it raises a warning...
  // in other words do not use. Also __count__ only includes the fields on the
  // actual object and not in the prototype chain.
  var rv = 0;
  for (var key in obj) {
    rv++;
  }
  return rv;
};


/**
 * Returns one key from the object map, if any exists.
 * For map literals the returned key will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object} obj The object to pick a key from.
 * @return {string|undefined} The key or undefined if the object is empty.
 */
goog.object.getAnyKey = function(obj) {
  for (var key in obj) {
    return key;
  }
};


/**
 * Returns one value from the object map, if any exists.
 * For map literals the returned value will be the first one in most of the
 * browsers (a know exception is Konqueror).
 *
 * @param {Object.<K,V>} obj The object to pick a value from.
 * @return {V|undefined} The value or undefined if the object is empty.
 * @template K,V
 */
goog.object.getAnyValue = function(obj) {
  for (var key in obj) {
    return obj[key];
  }
};


/**
 * Whether the object/hash/map contains the given object as a value.
 * An alias for goog.object.containsValue(obj, val).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The object for which to check.
 * @return {boolean} true if val is present.
 * @template K,V
 */
goog.object.contains = function(obj, val) {
  return goog.object.containsValue(obj, val);
};


/**
 * Returns the values of the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object from which to get the values.
 * @return {!Array.<V>} The values in the object/map/hash.
 * @template K,V
 */
goog.object.getValues = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = obj[key];
  }
  return res;
};


/**
 * Returns the keys of the object/map/hash.
 *
 * @param {Object} obj The object from which to get the keys.
 * @return {!Array.<string>} Array of property keys.
 */
goog.object.getKeys = function(obj) {
  var res = [];
  var i = 0;
  for (var key in obj) {
    res[i++] = key;
  }
  return res;
};


/**
 * Get a value from an object multiple levels deep.  This is useful for
 * pulling values from deeply nested objects, such as JSON responses.
 * Example usage: getValueByKeys(jsonObj, 'foo', 'entries', 3)
 *
 * @param {!Object} obj An object to get the value from.  Can be array-like.
 * @param {...(string|number|!Array.<number|string>)} var_args A number of keys
 *     (as strings, or numbers, for array-like objects).  Can also be
 *     specified as a single array of keys.
 * @return {*} The resulting value.  If, at any point, the value for a key
 *     is undefined, returns undefined.
 */
goog.object.getValueByKeys = function(obj, var_args) {
  var isArrayLike = goog.isArrayLike(var_args);
  var keys = isArrayLike ? var_args : arguments;

  // Start with the 2nd parameter for the variable parameters syntax.
  for (var i = isArrayLike ? 0 : 1; i < keys.length; i++) {
    obj = obj[keys[i]];
    if (!goog.isDef(obj)) {
      break;
    }
  }

  return obj;
};


/**
 * Whether the object/map/hash contains the given key.
 *
 * @param {Object} obj The object in which to look for key.
 * @param {*} key The key for which to check.
 * @return {boolean} true If the map contains the key.
 */
goog.object.containsKey = function(obj, key) {
  return key in obj;
};


/**
 * Whether the object/map/hash contains the given value. This is O(n).
 *
 * @param {Object.<K,V>} obj The object in which to look for val.
 * @param {V} val The value for which to check.
 * @return {boolean} true If the map contains the value.
 * @template K,V
 */
goog.object.containsValue = function(obj, val) {
  for (var key in obj) {
    if (obj[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its key.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The
 *      function to call for every element. Takes 3 arguments (the value,
 *     the key and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {string|undefined} The key of an element for which the function
 *     returns true or undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findKey = function(obj, f, opt_this) {
  for (var key in obj) {
    if (f.call(opt_this, obj[key], key, obj)) {
      return key;
    }
  }
  return undefined;
};


/**
 * Searches an object for an element that satisfies the given condition and
 * returns its value.
 * @param {Object.<K,V>} obj The object to search in.
 * @param {function(this:T,V,string,Object.<K,V>):boolean} f The function
 *     to call for every element. Takes 3 arguments (the value, the key
 *     and the object) and should return a boolean.
 * @param {T=} opt_this An optional "this" context for the function.
 * @return {V} The value of an element for which the function returns true or
 *     undefined if no such element is found.
 * @template T,K,V
 */
goog.object.findValue = function(obj, f, opt_this) {
  var key = goog.object.findKey(obj, f, opt_this);
  return key && obj[key];
};


/**
 * Whether the object/map/hash is empty.
 *
 * @param {Object} obj The object to test.
 * @return {boolean} true if obj is empty.
 */
goog.object.isEmpty = function(obj) {
  for (var key in obj) {
    return false;
  }
  return true;
};


/**
 * Removes all key value pairs from the object/map/hash.
 *
 * @param {Object} obj The object to clear.
 */
goog.object.clear = function(obj) {
  for (var i in obj) {
    delete obj[i];
  }
};


/**
 * Removes a key-value pair based on the key.
 *
 * @param {Object} obj The object from which to remove the key.
 * @param {*} key The key to remove.
 * @return {boolean} Whether an element was removed.
 */
goog.object.remove = function(obj, key) {
  var rv;
  if ((rv = key in obj)) {
    delete obj[key];
  }
  return rv;
};


/**
 * Adds a key-value pair to the object. Throws an exception if the key is
 * already in use. Use set if you want to change an existing pair.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} val The value to add.
 * @template K,V
 */
goog.object.add = function(obj, key, val) {
  if (key in obj) {
    throw Error('The object already contains the key "' + key + '"');
  }
  goog.object.set(obj, key, val);
};


/**
 * Returns the value for the given key.
 *
 * @param {Object.<K,V>} obj The object from which to get the value.
 * @param {string} key The key for which to get the value.
 * @param {R=} opt_val The value to return if no item is found for the given
 *     key (default is undefined).
 * @return {V|R|undefined} The value for the given key.
 * @template K,V,R
 */
goog.object.get = function(obj, key, opt_val) {
  if (key in obj) {
    return obj[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the object/map/hash.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add.
 * @template K,V
 */
goog.object.set = function(obj, key, value) {
  obj[key] = value;
};


/**
 * Adds a key-value pair to the object/map/hash if it doesn't exist yet.
 *
 * @param {Object.<K,V>} obj The object to which to add the key-value pair.
 * @param {string} key The key to add.
 * @param {V} value The value to add if the key wasn't present.
 * @return {V} The value of the entry at the end of the function.
 * @template K,V
 */
goog.object.setIfUndefined = function(obj, key, value) {
  return key in obj ? obj[key] : (obj[key] = value);
};


/**
 * Does a flat clone of the object.
 *
 * @param {Object.<K,V>} obj Object to clone.
 * @return {!Object.<K,V>} Clone of the input object.
 * @template K,V
 */
goog.object.clone = function(obj) {
  // We cannot use the prototype trick because a lot of methods depend on where
  // the actual key is set.

  var res = {};
  for (var key in obj) {
    res[key] = obj[key];
  }
  return res;
  // We could also use goog.mixin but I wanted this to be independent from that.
};


/**
 * Clones a value. The input may be an Object, Array, or basic type. Objects and
 * arrays will be cloned recursively.
 *
 * WARNINGS:
 * <code>goog.object.unsafeClone</code> does not detect reference loops. Objects
 * that refer to themselves will cause infinite recursion.
 *
 * <code>goog.object.unsafeClone</code> is unaware of unique identifiers, and
 * copies UIDs created by <code>getUid</code> into cloned results.
 *
 * @param {*} obj The value to clone.
 * @return {*} A clone of the input value.
 */
goog.object.unsafeClone = function(obj) {
  var type = goog.typeOf(obj);
  if (type == 'object' || type == 'array') {
    if (obj.clone) {
      return obj.clone();
    }
    var clone = type == 'array' ? [] : {};
    for (var key in obj) {
      clone[key] = goog.object.unsafeClone(obj[key]);
    }
    return clone;
  }

  return obj;
};


/**
 * Returns a new object in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * @param {Object} obj The object to transpose.
 * @return {!Object} The transposed object.
 */
goog.object.transpose = function(obj) {
  var transposed = {};
  for (var key in obj) {
    transposed[obj[key]] = key;
  }
  return transposed;
};


/**
 * The names of the fields that are defined on Object.prototype.
 * @type {Array.<string>}
 * @private
 */
goog.object.PROTOTYPE_FIELDS_ = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/**
 * Extends an object with another object.
 * This operates 'in-place'; it does not create a new Object.
 *
 * Example:
 * var o = {};
 * goog.object.extend(o, {a: 0, b: 1});
 * o; // {a: 0, b: 1}
 * goog.object.extend(o, {b: 2, c: 3});
 * o; // {a: 0, b: 2, c: 3}
 *
 * @param {Object} target The object to modify. Existing properties will be
 *     overwritten if they are also present in one of the objects in
 *     {@code var_args}.
 * @param {...Object} var_args The objects from which values will be copied.
 */
goog.object.extend = function(target, var_args) {
  var key, source;
  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    for (key in source) {
      target[key] = source[key];
    }

    // For IE the for-in-loop does not contain any properties that are not
    // enumerable on the prototype object (for example isPrototypeOf from
    // Object.prototype) and it will also not include 'replace' on objects that
    // extend String and change 'replace' (not that it is common for anyone to
    // extend anything except Object).

    for (var j = 0; j < goog.object.PROTOTYPE_FIELDS_.length; j++) {
      key = goog.object.PROTOTYPE_FIELDS_[j];
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
};


/**
 * Creates a new object built from the key-value pairs provided as arguments.
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise even arguments are used as
 *     the property names and odd arguments are used as the property values.
 * @return {!Object} The new object.
 * @throws {Error} If there are uneven number of arguments or there is only one
 *     non array argument.
 */
goog.object.create = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.create.apply(null, arguments[0]);
  }

  if (argLength % 2) {
    throw Error('Uneven number of arguments');
  }

  var rv = {};
  for (var i = 0; i < argLength; i += 2) {
    rv[arguments[i]] = arguments[i + 1];
  }
  return rv;
};


/**
 * Creates a new object where the property names come from the arguments but
 * the value is always set to true
 * @param {...*} var_args If only one argument is provided and it is an array
 *     then this is used as the arguments,  otherwise the arguments are used
 *     as the property names.
 * @return {!Object} The new object.
 */
goog.object.createSet = function(var_args) {
  var argLength = arguments.length;
  if (argLength == 1 && goog.isArray(arguments[0])) {
    return goog.object.createSet.apply(null, arguments[0]);
  }

  var rv = {};
  for (var i = 0; i < argLength; i++) {
    rv[arguments[i]] = true;
  }
  return rv;
};


/**
 * Creates an immutable view of the underlying object, if the browser
 * supports immutable objects.
 *
 * In default mode, writes to this view will fail silently. In strict mode,
 * they will throw an error.
 *
 * @param {!Object.<K,V>} obj An object.
 * @return {!Object.<K,V>} An immutable view of that object, or the
 *     original object if this browser does not support immutables.
 * @template K,V
 */
goog.object.createImmutableView = function(obj) {
  var result = obj;
  if (Object.isFrozen && !Object.isFrozen(obj)) {
    result = Object.create(obj);
    Object.freeze(result);
  }
  return result;
};


/**
 * @param {!Object} obj An object.
 * @return {boolean} Whether this is an immutable view of the object.
 */
goog.object.isImmutableView = function(obj) {
  return !!Object.isFrozen && Object.isFrozen(obj);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating arrays.
 *
 */


goog.provide('goog.array');
goog.provide('goog.array.ArrayLike');

goog.require('goog.asserts');


/**
 * @define {boolean} NATIVE_ARRAY_PROTOTYPES indicates whether the code should
 * rely on Array.prototype functions, if available.
 *
 * The Array.prototype functions can be defined by external libraries like
 * Prototype and setting this flag to false forces closure to use its own
 * goog.array implementation.
 *
 * If your javascript can be loaded by a third party site and you are wary about
 * relying on the prototype functions, specify
 * "--define goog.NATIVE_ARRAY_PROTOTYPES=false" to the JSCompiler.
 *
 * Setting goog.TRUSTED_SITE to false will automatically set
 * NATIVE_ARRAY_PROTOTYPES to false.
 */
goog.define('goog.NATIVE_ARRAY_PROTOTYPES', goog.TRUSTED_SITE);


/**
 * @define {boolean} If true, JSCompiler will use the native implementation of
 * array functions where appropriate (e.g., {@code Array#filter}) and remove the
 * unused pure JS implementation.
 */
goog.define('goog.array.ASSUME_NATIVE_FUNCTIONS', false);


/**
 * @typedef {Array|NodeList|Arguments|{length: number}}
 */
goog.array.ArrayLike;


/**
 * Returns the last element in an array without removing it.
 * Same as goog.array.last.
 * @param {Array.<T>|goog.array.ArrayLike} array The array.
 * @return {T} Last item in array.
 * @template T
 */
goog.array.peek = function(array) {
  return array[array.length - 1];
};


/**
 * Returns the last element in an array without removing it.
 * Same as goog.array.peek.
 * @param {Array.<T>|goog.array.ArrayLike} array The array.
 * @return {T} Last item in array.
 * @template T
 */
goog.array.last = goog.array.peek;


/**
 * Reference to the original {@code Array.prototype}.
 * @private
 */
goog.array.ARRAY_PROTOTYPE_ = Array.prototype;


// NOTE(arv): Since most of the array functions are generic it allows you to
// pass an array-like object. Strings have a length and are considered array-
// like. However, the 'in' operator does not work on strings so we cannot just
// use the array path even if the browser supports indexing into strings. We
// therefore end up splitting the string.


/**
 * Returns the index of the first element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-indexof}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at index 0.
 * @return {number} The index of the first matching array element.
 * @template T
 */
goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                     (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                      goog.array.ARRAY_PROTOTYPE_.indexOf) ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.indexOf.call(arr, obj, opt_fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ?
          0 : (opt_fromIndex < 0 ?
               Math.max(0, arr.length + opt_fromIndex) : opt_fromIndex);

      if (goog.isString(arr)) {
        // Array.prototype.indexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.indexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i < arr.length; i++) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Returns the index of the last element of an array with a specified value, or
 * -1 if the element is not present in the array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-lastindexof}
 *
 * @param {!Array.<T>|!goog.array.ArrayLike} arr The array to be searched.
 * @param {T} obj The object for which we are searching.
 * @param {?number=} opt_fromIndex The index at which to start the search. If
 *     omitted the search starts at the end of the array.
 * @return {number} The index of the last matching array element.
 * @template T
 */
goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES &&
                         (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                          goog.array.ARRAY_PROTOTYPE_.lastIndexOf) ?
    function(arr, obj, opt_fromIndex) {
      goog.asserts.assert(arr.length != null);

      // Firefox treats undefined and null as 0 in the fromIndex argument which
      // leads it to always return -1
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;
      return goog.array.ARRAY_PROTOTYPE_.lastIndexOf.call(arr, obj, fromIndex);
    } :
    function(arr, obj, opt_fromIndex) {
      var fromIndex = opt_fromIndex == null ? arr.length - 1 : opt_fromIndex;

      if (fromIndex < 0) {
        fromIndex = Math.max(0, arr.length + fromIndex);
      }

      if (goog.isString(arr)) {
        // Array.prototype.lastIndexOf uses === so only strings should be found.
        if (!goog.isString(obj) || obj.length != 1) {
          return -1;
        }
        return arr.lastIndexOf(obj, fromIndex);
      }

      for (var i = fromIndex; i >= 0; i--) {
        if (i in arr && arr[i] === obj)
          return i;
      }
      return -1;
    };


/**
 * Calls a function for each element in an array. Skips holes in the array.
 * See {@link http://tinyurl.com/developer-mozilla-org-array-foreach}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function takes 3 arguments (the element, the index and the
 *     array). The return value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @template T,S
 */
goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES &&
                     (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                      goog.array.ARRAY_PROTOTYPE_.forEach) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      goog.array.ARRAY_PROTOTYPE_.forEach.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          f.call(opt_obj, arr2[i], i, arr);
        }
      }
    };


/**
 * Calls a function for each element in an array, starting from the last
 * element rather than the first.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this: S, T, number, ?): ?} f The function to call for every
 *     element. This function
 *     takes 3 arguments (the element, the index and the array). The return
 *     value is ignored.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @template T,S
 */
goog.array.forEachRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; --i) {
    if (i in arr2) {
      f.call(opt_obj, arr2[i], i, arr);
    }
  }
};


/**
 * Calls a function for each element in an array, and if the function returns
 * true adds the element to a new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-filter}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?):boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and must
 *     return a Boolean. If the return value is true the element is added to the
 *     result array. If it is false the element is not included.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {!Array.<T>} a new array in which only elements that passed the test
 *     are present.
 * @template T,S
 */
goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES &&
                    (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                     goog.array.ARRAY_PROTOTYPE_.filter) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.filter.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = [];
      var resLength = 0;
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          var val = arr2[i];  // in case f mutates arr2
          if (f.call(opt_obj, val, i, arr)) {
            res[resLength++] = val;
          }
        }
      }
      return res;
    };


/**
 * Calls a function for each element in an array and inserts the result into a
 * new array.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-map}
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr Array or array like object
 *     over which to iterate.
 * @param {function(this:THIS, VALUE, number, ?): RESULT} f The function to call
 *     for every element. This function takes 3 arguments (the element,
 *     the index and the array) and should return something. The result will be
 *     inserted into a new array.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within f.
 * @return {!Array.<RESULT>} a new array with the results from f.
 * @template THIS, VALUE, RESULT
 */
goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES &&
                 (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                  goog.array.ARRAY_PROTOTYPE_.map) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.map.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var res = new Array(l);
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2) {
          res[i] = f.call(opt_obj, arr2[i], i, arr);
        }
      }
      return res;
    };


/**
 * Passes every element of an array into a function and accumulates the result.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduce}
 *
 * For example:
 * var a = [1, 2, 3, 4];
 * goog.array.reduce(a, function(r, v, i, arr) {return r + v;}, 0);
 * returns 10
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {R} Result of evaluating f repeatedly across the values of the array.
 * @template T,S,R
 */
goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES &&
                    (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                     goog.array.ARRAY_PROTOTYPE_.reduce) ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduce.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEach(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Passes every element of an array into a function and accumulates the result,
 * starting from the last element and working towards the first.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-reduceright}
 *
 * For example:
 * var a = ['a', 'b', 'c'];
 * goog.array.reduceRight(a, function(r, v, i, arr) {return r + v;}, '');
 * returns 'cba'
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, R, T, number, ?) : R} f The function to call for
 *     every element. This function
 *     takes 4 arguments (the function's previous result or the initial value,
 *     the value of the current array element, the current array index, and the
 *     array itself)
 *     function(previousValue, currentValue, index, array).
 * @param {?} val The initial value to pass into the function on the first call.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {R} Object returned as a result of evaluating f repeatedly across the
 *     values of the array.
 * @template T,S,R
 */
goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES &&
                         (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                          goog.array.ARRAY_PROTOTYPE_.reduceRight) ?
    function(arr, f, val, opt_obj) {
      goog.asserts.assert(arr.length != null);
      if (opt_obj) {
        f = goog.bind(f, opt_obj);
      }
      return goog.array.ARRAY_PROTOTYPE_.reduceRight.call(arr, f, val);
    } :
    function(arr, f, val, opt_obj) {
      var rval = val;
      goog.array.forEachRight(arr, function(val, index) {
        rval = f.call(opt_obj, rval, val, index, arr);
      });
      return rval;
    };


/**
 * Calls f for each element of an array. If any call returns true, some()
 * returns true (without checking the remaining elements). If all calls
 * return false, some() returns false.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-some}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj  The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} true if any element passes the test.
 * @template T,S
 */
goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES &&
                  (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                   goog.array.ARRAY_PROTOTYPE_.some) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.some.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
          return true;
        }
      }
      return false;
    };


/**
 * Call f for each element of an array. If all calls return true, every()
 * returns true. If any call returns false, every() returns false and
 * does not continue to check the remaining elements.
 *
 * See {@link http://tinyurl.com/developer-mozilla-org-array-every}
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within f.
 * @return {boolean} false if any element fails the test.
 * @template T,S
 */
goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES &&
                   (goog.array.ASSUME_NATIVE_FUNCTIONS ||
                    goog.array.ARRAY_PROTOTYPE_.every) ?
    function(arr, f, opt_obj) {
      goog.asserts.assert(arr.length != null);

      return goog.array.ARRAY_PROTOTYPE_.every.call(arr, f, opt_obj);
    } :
    function(arr, f, opt_obj) {
      var l = arr.length;  // must be fixed during loop... see docs
      var arr2 = goog.isString(arr) ? arr.split('') : arr;
      for (var i = 0; i < l; i++) {
        if (i in arr2 && !f.call(opt_obj, arr2[i], i, arr)) {
          return false;
        }
      }
      return true;
    };


/**
 * Counts the array elements that fulfill the predicate, i.e. for which the
 * callback function returns true. Skips holes in the array.
 *
 * @param {!(Array.<T>|goog.array.ArrayLike)} arr Array or array like object
 *     over which to iterate.
 * @param {function(this: S, T, number, ?): boolean} f The function to call for
 *     every element. Takes 3 arguments (the element, the index and the array).
 * @param {S=} opt_obj The object to be used as the value of 'this' within f.
 * @return {number} The number of the matching elements.
 * @template T,S
 */
goog.array.count = function(arr, f, opt_obj) {
  var count = 0;
  goog.array.forEach(arr, function(element, index, arr) {
    if (f.call(opt_obj, element, index, arr)) {
      ++count;
    }
  }, opt_obj);
  return count;
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {?T} The first array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.find = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array for the first element that satisfies a given condition and
 * return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call for
 *     every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the first array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndex = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = 0; i < l; i++) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return that element.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {?T} The last array element that passes the test, or null if no
 *     element is found.
 * @template T,S
 */
goog.array.findRight = function(arr, f, opt_obj) {
  var i = goog.array.findIndexRight(arr, f, opt_obj);
  return i < 0 ? null : goog.isString(arr) ? arr.charAt(i) : arr[i];
};


/**
 * Search an array (in reverse order) for the last element that satisfies a
 * given condition and return its index.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {Object=} opt_obj An optional "this" context for the function.
 * @return {number} The index of the last array element that passes the test,
 *     or -1 if no element is found.
 * @template T,S
 */
goog.array.findIndexRight = function(arr, f, opt_obj) {
  var l = arr.length;  // must be fixed during loop... see docs
  var arr2 = goog.isString(arr) ? arr.split('') : arr;
  for (var i = l - 1; i >= 0; i--) {
    if (i in arr2 && f.call(opt_obj, arr2[i], i, arr)) {
      return i;
    }
  }
  return -1;
};


/**
 * Whether the array contains the given object.
 * @param {goog.array.ArrayLike} arr The array to test for the presence of the
 *     element.
 * @param {*} obj The object for which to test.
 * @return {boolean} true if obj is present.
 */
goog.array.contains = function(arr, obj) {
  return goog.array.indexOf(arr, obj) >= 0;
};


/**
 * Whether the array is empty.
 * @param {goog.array.ArrayLike} arr The array to test.
 * @return {boolean} true if empty.
 */
goog.array.isEmpty = function(arr) {
  return arr.length == 0;
};


/**
 * Clears the array.
 * @param {goog.array.ArrayLike} arr Array or array like object to clear.
 */
goog.array.clear = function(arr) {
  // For non real arrays we don't have the magic length so we delete the
  // indices.
  if (!goog.isArray(arr)) {
    for (var i = arr.length - 1; i >= 0; i--) {
      delete arr[i];
    }
  }
  arr.length = 0;
};


/**
 * Pushes an item into an array, if it's not already in the array.
 * @param {Array.<T>} arr Array into which to insert the item.
 * @param {T} obj Value to add.
 * @template T
 */
goog.array.insert = function(arr, obj) {
  if (!goog.array.contains(arr, obj)) {
    arr.push(obj);
  }
};


/**
 * Inserts an object at the given index of the array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {*} obj The object to insert.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertAt = function(arr, obj, opt_i) {
  goog.array.splice(arr, opt_i, 0, obj);
};


/**
 * Inserts at the given index of the array, all elements of another array.
 * @param {goog.array.ArrayLike} arr The array to modify.
 * @param {goog.array.ArrayLike} elementsToAdd The array of elements to add.
 * @param {number=} opt_i The index at which to insert the object. If omitted,
 *      treated as 0. A negative index is counted from the end of the array.
 */
goog.array.insertArrayAt = function(arr, elementsToAdd, opt_i) {
  goog.partial(goog.array.splice, arr, opt_i, 0).apply(null, elementsToAdd);
};


/**
 * Inserts an object into an array before a specified object.
 * @param {Array.<T>} arr The array to modify.
 * @param {T} obj The object to insert.
 * @param {T=} opt_obj2 The object before which obj should be inserted. If obj2
 *     is omitted or not found, obj is inserted at the end of the array.
 * @template T
 */
goog.array.insertBefore = function(arr, obj, opt_obj2) {
  var i;
  if (arguments.length == 2 || (i = goog.array.indexOf(arr, opt_obj2)) < 0) {
    arr.push(obj);
  } else {
    goog.array.insertAt(arr, obj, i);
  }
};


/**
 * Removes the first occurrence of a particular value from an array.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array from which to remove
 *     value.
 * @param {T} obj Object to remove.
 * @return {boolean} True if an element was removed.
 * @template T
 */
goog.array.remove = function(arr, obj) {
  var i = goog.array.indexOf(arr, obj);
  var rv;
  if ((rv = i >= 0)) {
    goog.array.removeAt(arr, i);
  }
  return rv;
};


/**
 * Removes from an array the element at index i
 * @param {goog.array.ArrayLike} arr Array or array like object from which to
 *     remove value.
 * @param {number} i The index to remove.
 * @return {boolean} True if an element was removed.
 */
goog.array.removeAt = function(arr, i) {
  goog.asserts.assert(arr.length != null);

  // use generic form of splice
  // splice returns the removed items and if successful the length of that
  // will be 1
  return goog.array.ARRAY_PROTOTYPE_.splice.call(arr, i, 1).length == 1;
};


/**
 * Removes the first value that satisfies the given condition.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array
 *     like object over which to iterate.
 * @param {?function(this:S, T, number, ?) : boolean} f The function to call
 *     for every element. This function
 *     takes 3 arguments (the element, the index and the array) and should
 *     return a boolean.
 * @param {S=} opt_obj An optional "this" context for the function.
 * @return {boolean} True if an element was removed.
 * @template T,S
 */
goog.array.removeIf = function(arr, f, opt_obj) {
  var i = goog.array.findIndex(arr, f, opt_obj);
  if (i >= 0) {
    goog.array.removeAt(arr, i);
    return true;
  }
  return false;
};


/**
 * Returns a new array that is the result of joining the arguments.  If arrays
 * are passed then their items are added, however, if non-arrays are passed they
 * will be added to the return array as is.
 *
 * Note that ArrayLike objects will be added as is, rather than having their
 * items added.
 *
 * goog.array.concat([1, 2], [3, 4]) -> [1, 2, 3, 4]
 * goog.array.concat(0, [1, 2]) -> [0, 1, 2]
 * goog.array.concat([1, 2], null) -> [1, 2, null]
 *
 * There is bug in all current versions of IE (6, 7 and 8) where arrays created
 * in an iframe become corrupted soon (not immediately) after the iframe is
 * destroyed. This is common if loading data via goog.net.IframeIo, for example.
 * This corruption only affects the concat method which will start throwing
 * Catastrophic Errors (#-2147418113).
 *
 * See http://endoflow.com/scratch/corrupted-arrays.html for a test case.
 *
 * Internally goog.array should use this, so that all methods will continue to
 * work on these broken array objects.
 *
 * @param {...*} var_args Items to concatenate.  Arrays will have each item
 *     added, while primitives and objects will be added as is.
 * @return {!Array} The new resultant array.
 */
goog.array.concat = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Returns a new array that contains the contents of all the arrays passed.
 * @param {...!Array.<T>} var_args
 * @return {!Array.<T>}
 * @template T
 */
goog.array.join = function(var_args) {
  return goog.array.ARRAY_PROTOTYPE_.concat.apply(
      goog.array.ARRAY_PROTOTYPE_, arguments);
};


/**
 * Converts an object to an array.
 * @param {Array.<T>|goog.array.ArrayLike} object  The object to convert to an
 *     array.
 * @return {!Array.<T>} The object converted into an array. If object has a
 *     length property, every property indexed with a non-negative number
 *     less than length will be included in the result. If object does not
 *     have a length property, an empty array will be returned.
 * @template T
 */
goog.array.toArray = function(object) {
  var length = object.length;

  // If length is not a number the following it false. This case is kept for
  // backwards compatibility since there are callers that pass objects that are
  // not array like.
  if (length > 0) {
    var rv = new Array(length);
    for (var i = 0; i < length; i++) {
      rv[i] = object[i];
    }
    return rv;
  }
  return [];
};


/**
 * Does a shallow copy of an array.
 * @param {Array.<T>|goog.array.ArrayLike} arr  Array or array-like object to
 *     clone.
 * @return {!Array.<T>} Clone of the input array.
 * @template T
 */
goog.array.clone = goog.array.toArray;


/**
 * Extends an array with another array, element, or "array like" object.
 * This function operates 'in-place', it does not create a new Array.
 *
 * Example:
 * var a = [];
 * goog.array.extend(a, [0, 1]);
 * a; // [0, 1]
 * goog.array.extend(a, 2);
 * a; // [0, 1, 2]
 *
 * @param {Array.<VALUE>} arr1  The array to modify.
 * @param {...(Array.<VALUE>|VALUE)} var_args The elements or arrays of elements
 *     to add to arr1.
 * @template VALUE
 */
goog.array.extend = function(arr1, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var arr2 = arguments[i];
    // If we have an Array or an Arguments object we can just call push
    // directly.
    var isArrayLike;
    if (goog.isArray(arr2) ||
        // Detect Arguments. ES5 says that the [[Class]] of an Arguments object
        // is "Arguments" but only V8 and JSC/Safari gets this right. We instead
        // detect Arguments by checking for array like and presence of "callee".
        (isArrayLike = goog.isArrayLike(arr2)) &&
            // The getter for callee throws an exception in strict mode
            // according to section 10.6 in ES5 so check for presence instead.
            Object.prototype.hasOwnProperty.call(arr2, 'callee')) {
      arr1.push.apply(arr1, arr2);
    } else if (isArrayLike) {
      // Otherwise loop over arr2 to prevent copying the object.
      var len1 = arr1.length;
      var len2 = arr2.length;
      for (var j = 0; j < len2; j++) {
        arr1[len1 + j] = arr2[j];
      }
    } else {
      arr1.push(arr2);
    }
  }
};


/**
 * Adds or removes elements from an array. This is a generic version of Array
 * splice. This means that it might work on other objects similar to arrays,
 * such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array to modify.
 * @param {number|undefined} index The index at which to start changing the
 *     array. If not defined, treated as 0.
 * @param {number} howMany How many elements to remove (0 means no removal. A
 *     value below 0 is treated as zero and so is any other non number. Numbers
 *     are floored).
 * @param {...T} var_args Optional, additional elements to insert into the
 *     array.
 * @return {!Array.<T>} the removed elements.
 * @template T
 */
goog.array.splice = function(arr, index, howMany, var_args) {
  goog.asserts.assert(arr.length != null);

  return goog.array.ARRAY_PROTOTYPE_.splice.apply(
      arr, goog.array.slice(arguments, 1));
};


/**
 * Returns a new array from a segment of an array. This is a generic version of
 * Array slice. This means that it might work on other objects similar to
 * arrays, such as the arguments object.
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from
 * which to copy a segment.
 * @param {number} start The index of the first element to copy.
 * @param {number=} opt_end The index after the last element to copy.
 * @return {!Array.<T>} A new array containing the specified segment of the
 *     original array.
 * @template T
 */
goog.array.slice = function(arr, start, opt_end) {
  goog.asserts.assert(arr.length != null);

  // passing 1 arg to slice is not the same as passing 2 where the second is
  // null or undefined (in that case the second argument is treated as 0).
  // we could use slice on the arguments object and then use apply instead of
  // testing the length
  if (arguments.length <= 2) {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start);
  } else {
    return goog.array.ARRAY_PROTOTYPE_.slice.call(arr, start, opt_end);
  }
};


/**
 * Removes all duplicates from an array (retaining only the first
 * occurrence of each array element).  This function modifies the
 * array in place and doesn't change the order of the non-duplicate items.
 *
 * For objects, duplicates are identified as having the same unique ID as
 * defined by {@link goog.getUid}.
 *
 * Alternatively you can specify a custom hash function that returns a unique
 * value for each item in the array it should consider unique.
 *
 * Runtime: N,
 * Worstcase space: 2N (no dupes)
 *
 * @param {Array.<T>|goog.array.ArrayLike} arr The array from which to remove
 *     duplicates.
 * @param {Array=} opt_rv An optional array in which to return the results,
 *     instead of performing the removal inplace.  If specified, the original
 *     array will remain unchanged.
 * @param {function(T):string=} opt_hashFn An optional function to use to
 *     apply to every item in the array. This function should return a unique
 *     value for each item in the array it should consider unique.
 * @template T
 */
goog.array.removeDuplicates = function(arr, opt_rv, opt_hashFn) {
  var returnArray = opt_rv || arr;
  var defaultHashFn = function(item) {
    // Prefix each type with a single character representing the type to
    // prevent conflicting keys (e.g. true and 'true').
    return goog.isObject(current) ? 'o' + goog.getUid(current) :
        (typeof current).charAt(0) + current;
  };
  var hashFn = opt_hashFn || defaultHashFn;

  var seen = {}, cursorInsert = 0, cursorRead = 0;
  while (cursorRead < arr.length) {
    var current = arr[cursorRead++];
    var key = hashFn(current);
    if (!Object.prototype.hasOwnProperty.call(seen, key)) {
      seen[key] = true;
      returnArray[cursorInsert++] = current;
    }
  }
  returnArray.length = cursorInsert;
};


/**
 * Searches the specified array for the specified target using the binary
 * search algorithm.  If no opt_compareFn is specified, elements are compared
 * using <code>goog.array.defaultCompare</code>, which compares the elements
 * using the built in < and > operators.  This will produce the expected
 * behavior for homogeneous arrays of String(s) and Number(s). The array
 * specified <b>must</b> be sorted in ascending order (as defined by the
 * comparison function).  If the array is not sorted, results are undefined.
 * If the array contains multiple instances of the specified target value, any
 * of these instances may be found.
 *
 * Runtime: O(log n)
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {TARGET} target The sought value.
 * @param {function(TARGET, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template TARGET, VALUE
 */
goog.array.binarySearch = function(arr, target, opt_compareFn) {
  return goog.array.binarySearch_(arr,
      opt_compareFn || goog.array.defaultCompare, false /* isEvaluator */,
      target);
};


/**
 * Selects an index in the specified array using the binary search algorithm.
 * The evaluator receives an element and determines whether the desired index
 * is before, at, or after it.  The evaluator must be consistent (formally,
 * goog.array.map(goog.array.map(arr, evaluator, opt_obj), goog.math.sign)
 * must be monotonically non-increasing).
 *
 * Runtime: O(log n)
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {function(this:THIS, VALUE, number, ?): number} evaluator
 *     Evaluator function that receives 3 arguments (the element, the index and
 *     the array). Should return a negative number, zero, or a positive number
 *     depending on whether the desired index is before, at, or after the
 *     element passed to it.
 * @param {THIS=} opt_obj The object to be used as the value of 'this'
 *     within evaluator.
 * @return {number} Index of the leftmost element matched by the evaluator, if
 *     such exists; otherwise (-(insertion point) - 1). The insertion point is
 *     the index of the first element for which the evaluator returns negative,
 *     or arr.length if no such element exists. The return value is non-negative
 *     iff a match is found.
 * @template THIS, VALUE
 */
goog.array.binarySelect = function(arr, evaluator, opt_obj) {
  return goog.array.binarySearch_(arr, evaluator, true /* isEvaluator */,
      undefined /* opt_target */, opt_obj);
};


/**
 * Implementation of a binary search algorithm which knows how to use both
 * comparison functions and evaluators. If an evaluator is provided, will call
 * the evaluator with the given optional data object, conforming to the
 * interface defined in binarySelect. Otherwise, if a comparison function is
 * provided, will call the comparison function against the given data object.
 *
 * This implementation purposefully does not use goog.bind or goog.partial for
 * performance reasons.
 *
 * Runtime: O(log n)
 *
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to be searched.
 * @param {function(TARGET, VALUE): number|
 *         function(this:THIS, VALUE, number, ?): number} compareFn Either an
 *     evaluator or a comparison function, as defined by binarySearch
 *     and binarySelect above.
 * @param {boolean} isEvaluator Whether the function is an evaluator or a
 *     comparison function.
 * @param {TARGET=} opt_target If the function is a comparison function, then
 *     this is the target to binary search for.
 * @param {THIS=} opt_selfObj If the function is an evaluator, this is an
  *    optional this object for the evaluator.
 * @return {number} Lowest index of the target value if found, otherwise
 *     (-(insertion point) - 1). The insertion point is where the value should
 *     be inserted into arr to preserve the sorted property.  Return value >= 0
 *     iff target is found.
 * @template THIS, VALUE, TARGET
 * @private
 */
goog.array.binarySearch_ = function(arr, compareFn, isEvaluator, opt_target,
    opt_selfObj) {
  var left = 0;  // inclusive
  var right = arr.length;  // exclusive
  var found;
  while (left < right) {
    var middle = (left + right) >> 1;
    var compareResult;
    if (isEvaluator) {
      compareResult = compareFn.call(opt_selfObj, arr[middle], middle, arr);
    } else {
      compareResult = compareFn(opt_target, arr[middle]);
    }
    if (compareResult > 0) {
      left = middle + 1;
    } else {
      right = middle;
      // We are looking for the lowest index so we can't return immediately.
      found = !compareResult;
    }
  }
  // left is the index if found, or the insertion point otherwise.
  // ~left is a shorthand for -left - 1.
  return found ? left : ~left;
};


/**
 * Sorts the specified array into ascending order.  If no opt_compareFn is
 * specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s), unlike the native sort,
 * but will give unpredictable results for heterogenous lists of strings and
 * numbers with different numbers of digits.
 *
 * This sort is not guaranteed to be stable.
 *
 * Runtime: Same as <code>Array.prototype.sort</code>
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T,T):number=} opt_compareFn Optional comparison
 *     function by which the
 *     array is to be ordered. Should take 2 arguments to compare, and return a
 *     negative number, zero, or a positive number depending on whether the
 *     first argument is less than, equal to, or greater than the second.
 * @template T
 */
goog.array.sort = function(arr, opt_compareFn) {
  // TODO(arv): Update type annotation since null is not accepted.
  arr.sort(opt_compareFn || goog.array.defaultCompare);
};


/**
 * Sorts the specified array into ascending order in a stable way.  If no
 * opt_compareFn is specified, elements are compared using
 * <code>goog.array.defaultCompare</code>, which compares the elements using
 * the built in < and > operators.  This will produce the expected behavior
 * for homogeneous arrays of String(s) and Number(s).
 *
 * Runtime: Same as <code>Array.prototype.sort</code>, plus an additional
 * O(n) overhead of copying the array twice.
 *
 * @param {Array.<T>} arr The array to be sorted.
 * @param {?function(T, T): number=} opt_compareFn Optional comparison function
 *     by which the array is to be ordered. Should take 2 arguments to compare,
 *     and return a negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template T
 */
goog.array.stableSort = function(arr, opt_compareFn) {
  for (var i = 0; i < arr.length; i++) {
    arr[i] = {index: i, value: arr[i]};
  }
  var valueCompareFn = opt_compareFn || goog.array.defaultCompare;
  function stableCompareFn(obj1, obj2) {
    return valueCompareFn(obj1.value, obj2.value) || obj1.index - obj2.index;
  };
  goog.array.sort(arr, stableCompareFn);
  for (var i = 0; i < arr.length; i++) {
    arr[i] = arr[i].value;
  }
};


/**
 * Sorts an array of objects by the specified object key and compare
 * function. If no compare function is provided, the key values are
 * compared in ascending order using <code>goog.array.defaultCompare</code>.
 * This won't work for keys that get renamed by the compiler. So use
 * {'foo': 1, 'bar': 2} rather than {foo: 1, bar: 2}.
 * @param {Array.<Object>} arr An array of objects to sort.
 * @param {string} key The object key to sort by.
 * @param {Function=} opt_compareFn The function to use to compare key
 *     values.
 */
goog.array.sortObjectsByKey = function(arr, key, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  goog.array.sort(arr, function(a, b) {
    return compare(a[key], b[key]);
  });
};


/**
 * Tells if the array is sorted.
 * @param {!Array.<T>} arr The array.
 * @param {?function(T,T):number=} opt_compareFn Function to compare the
 *     array elements.
 *     Should take 2 arguments to compare, and return a negative number, zero,
 *     or a positive number depending on whether the first argument is less
 *     than, equal to, or greater than the second.
 * @param {boolean=} opt_strict If true no equal elements are allowed.
 * @return {boolean} Whether the array is sorted.
 * @template T
 */
goog.array.isSorted = function(arr, opt_compareFn, opt_strict) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  for (var i = 1; i < arr.length; i++) {
    var compareResult = compare(arr[i - 1], arr[i]);
    if (compareResult > 0 || compareResult == 0 && opt_strict) {
      return false;
    }
  }
  return true;
};


/**
 * Compares two arrays for equality. Two arrays are considered equal if they
 * have the same length and their corresponding elements are equal according to
 * the comparison function.
 *
 * @param {goog.array.ArrayLike} arr1 The first array to compare.
 * @param {goog.array.ArrayLike} arr2 The second array to compare.
 * @param {Function=} opt_equalsFn Optional comparison function.
 *     Should take 2 arguments to compare, and return true if the arguments
 *     are equal. Defaults to {@link goog.array.defaultCompareEquality} which
 *     compares the elements using the built-in '===' operator.
 * @return {boolean} Whether the two arrays are equal.
 */
goog.array.equals = function(arr1, arr2, opt_equalsFn) {
  if (!goog.isArrayLike(arr1) || !goog.isArrayLike(arr2) ||
      arr1.length != arr2.length) {
    return false;
  }
  var l = arr1.length;
  var equalsFn = opt_equalsFn || goog.array.defaultCompareEquality;
  for (var i = 0; i < l; i++) {
    if (!equalsFn(arr1[i], arr2[i])) {
      return false;
    }
  }
  return true;
};


/**
 * 3-way array compare function.
 * @param {!Array.<VALUE>|!goog.array.ArrayLike} arr1 The first array to
 *     compare.
 * @param {!Array.<VALUE>|!goog.array.ArrayLike} arr2 The second array to
 *     compare.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is to be ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {number} Negative number, zero, or a positive number depending on
 *     whether the first argument is less than, equal to, or greater than the
 *     second.
 * @template VALUE
 */
goog.array.compare3 = function(arr1, arr2, opt_compareFn) {
  var compare = opt_compareFn || goog.array.defaultCompare;
  var l = Math.min(arr1.length, arr2.length);
  for (var i = 0; i < l; i++) {
    var result = compare(arr1[i], arr2[i]);
    if (result != 0) {
      return result;
    }
  }
  return goog.array.defaultCompare(arr1.length, arr2.length);
};


/**
 * Compares its two arguments for order, using the built in < and >
 * operators.
 * @param {VALUE} a The first object to be compared.
 * @param {VALUE} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 * @template VALUE
 */
goog.array.defaultCompare = function(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};


/**
 * Compares its two arguments for equality, using the built in === operator.
 * @param {*} a The first object to compare.
 * @param {*} b The second object to compare.
 * @return {boolean} True if the two arguments are equal, false otherwise.
 */
goog.array.defaultCompareEquality = function(a, b) {
  return a === b;
};


/**
 * Inserts a value into a sorted array. The array is not modified if the
 * value is already present.
 * @param {Array.<VALUE>|goog.array.ArrayLike} array The array to modify.
 * @param {VALUE} value The object to insert.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was inserted.
 * @template VALUE
 */
goog.array.binaryInsert = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  if (index < 0) {
    goog.array.insertAt(array, value, -(index + 1));
    return true;
  }
  return false;
};


/**
 * Removes a value from a sorted array.
 * @param {!Array.<VALUE>|!goog.array.ArrayLike} array The array to modify.
 * @param {VALUE} value The object to remove.
 * @param {function(VALUE, VALUE): number=} opt_compareFn Optional comparison
 *     function by which the array is ordered. Should take 2 arguments to
 *     compare, and return a negative number, zero, or a positive number
 *     depending on whether the first argument is less than, equal to, or
 *     greater than the second.
 * @return {boolean} True if an element was removed.
 * @template VALUE
 */
goog.array.binaryRemove = function(array, value, opt_compareFn) {
  var index = goog.array.binarySearch(array, value, opt_compareFn);
  return (index >= 0) ? goog.array.removeAt(array, index) : false;
};


/**
 * Splits an array into disjoint buckets according to a splitting function.
 * @param {Array.<T>} array The array.
 * @param {function(this:S, T,number,Array.<T>):?} sorter Function to call for
 *     every element.  This takes 3 arguments (the element, the index and the
 *     array) and must return a valid object key (a string, number, etc), or
 *     undefined, if that object should not be placed in a bucket.
 * @param {S=} opt_obj The object to be used as the value of 'this' within
 *     sorter.
 * @return {!Object} An object, with keys being all of the unique return values
 *     of sorter, and values being arrays containing the items for
 *     which the splitter returned that key.
 * @template T,S
 */
goog.array.bucket = function(array, sorter, opt_obj) {
  var buckets = {};

  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    var key = sorter.call(opt_obj, value, i, array);
    if (goog.isDef(key)) {
      // Push the value to the right bucket, creating it if necessary.
      var bucket = buckets[key] || (buckets[key] = []);
      bucket.push(value);
    }
  }

  return buckets;
};


/**
 * Creates a new object built from the provided array and the key-generation
 * function.
 * @param {Array.<T>|goog.array.ArrayLike} arr Array or array like object over
 *     which to iterate whose elements will be the values in the new object.
 * @param {?function(this:S, T, number, ?) : string} keyFunc The function to
 *     call for every element. This function takes 3 arguments (the element, the
 *     index and the array) and should return a string that will be used as the
 *     key for the element in the new object. If the function returns the same
 *     key for more than one element, the value for that key is
 *     implementation-defined.
 * @param {S=} opt_obj The object to be used as the value of 'this'
 *     within keyFunc.
 * @return {!Object.<T>} The new object.
 * @template T,S
 */
goog.array.toObject = function(arr, keyFunc, opt_obj) {
  var ret = {};
  goog.array.forEach(arr, function(element, index) {
    ret[keyFunc.call(opt_obj, element, index, arr)] = element;
  });
  return ret;
};


/**
 * Creates a range of numbers in an arithmetic progression.
 *
 * Range takes 1, 2, or 3 arguments:
 * <pre>
 * range(5) is the same as range(0, 5, 1) and produces [0, 1, 2, 3, 4]
 * range(2, 5) is the same as range(2, 5, 1) and produces [2, 3, 4]
 * range(-2, -5, -1) produces [-2, -3, -4]
 * range(-2, -5, 1) produces [], since stepping by 1 wouldn't ever reach -5.
 * </pre>
 *
 * @param {number} startOrEnd The starting value of the range if an end argument
 *     is provided. Otherwise, the start value is 0, and this is the end value.
 * @param {number=} opt_end The optional end value of the range.
 * @param {number=} opt_step The step size between range values. Defaults to 1
 *     if opt_step is undefined or 0.
 * @return {!Array.<number>} An array of numbers for the requested range. May be
 *     an empty array if adding the step would not converge toward the end
 *     value.
 */
goog.array.range = function(startOrEnd, opt_end, opt_step) {
  var array = [];
  var start = 0;
  var end = startOrEnd;
  var step = opt_step || 1;
  if (opt_end !== undefined) {
    start = startOrEnd;
    end = opt_end;
  }

  if (step * (end - start) < 0) {
    // Sign mismatch: start + step will never reach the end value.
    return [];
  }

  if (step > 0) {
    for (var i = start; i < end; i += step) {
      array.push(i);
    }
  } else {
    for (var i = start; i > end; i += step) {
      array.push(i);
    }
  }
  return array;
};


/**
 * Returns an array consisting of the given value repeated N times.
 *
 * @param {VALUE} value The value to repeat.
 * @param {number} n The repeat count.
 * @return {!Array.<VALUE>} An array with the repeated value.
 * @template VALUE
 */
goog.array.repeat = function(value, n) {
  var array = [];
  for (var i = 0; i < n; i++) {
    array[i] = value;
  }
  return array;
};


/**
 * Returns an array consisting of every argument with all arrays
 * expanded in-place recursively.
 *
 * @param {...*} var_args The values to flatten.
 * @return {!Array} An array containing the flattened values.
 */
goog.array.flatten = function(var_args) {
  var result = [];
  for (var i = 0; i < arguments.length; i++) {
    var element = arguments[i];
    if (goog.isArray(element)) {
      result.push.apply(result, goog.array.flatten.apply(null, element));
    } else {
      result.push(element);
    }
  }
  return result;
};


/**
 * Rotates an array in-place. After calling this method, the element at
 * index i will be the element previously at index (i - n) %
 * array.length, for all values of i between 0 and array.length - 1,
 * inclusive.
 *
 * For example, suppose list comprises [t, a, n, k, s]. After invoking
 * rotate(array, 1) (or rotate(array, -4)), array will comprise [s, t, a, n, k].
 *
 * @param {!Array.<T>} array The array to rotate.
 * @param {number} n The amount to rotate.
 * @return {!Array.<T>} The array.
 * @template T
 */
goog.array.rotate = function(array, n) {
  goog.asserts.assert(array.length != null);

  if (array.length) {
    n %= array.length;
    if (n > 0) {
      goog.array.ARRAY_PROTOTYPE_.unshift.apply(array, array.splice(-n, n));
    } else if (n < 0) {
      goog.array.ARRAY_PROTOTYPE_.push.apply(array, array.splice(0, -n));
    }
  }
  return array;
};


/**
 * Moves one item of an array to a new position keeping the order of the rest
 * of the items. Example use case: keeping a list of JavaScript objects
 * synchronized with the corresponding list of DOM elements after one of the
 * elements has been dragged to a new position.
 * @param {!(Array|Arguments|{length:number})} arr The array to modify.
 * @param {number} fromIndex Index of the item to move between 0 and
 *     {@code arr.length - 1}.
 * @param {number} toIndex Target index between 0 and {@code arr.length - 1}.
 */
goog.array.moveItem = function(arr, fromIndex, toIndex) {
  goog.asserts.assert(fromIndex >= 0 && fromIndex < arr.length);
  goog.asserts.assert(toIndex >= 0 && toIndex < arr.length);
  // Remove 1 item at fromIndex.
  var removedItems = goog.array.ARRAY_PROTOTYPE_.splice.call(arr, fromIndex, 1);
  // Insert the removed item at toIndex.
  goog.array.ARRAY_PROTOTYPE_.splice.call(arr, toIndex, 0, removedItems[0]);
  // We don't use goog.array.insertAt and goog.array.removeAt, because they're
  // significantly slower than splice.
};


/**
 * Creates a new array for which the element at position i is an array of the
 * ith element of the provided arrays.  The returned array will only be as long
 * as the shortest array provided; additional values are ignored.  For example,
 * the result of zipping [1, 2] and [3, 4, 5] is [[1,3], [2, 4]].
 *
 * This is similar to the zip() function in Python.  See {@link
 * http://docs.python.org/library/functions.html#zip}
 *
 * @param {...!goog.array.ArrayLike} var_args Arrays to be combined.
 * @return {!Array.<!Array>} A new array of arrays created from provided arrays.
 */
goog.array.zip = function(var_args) {
  if (!arguments.length) {
    return [];
  }
  var result = [];
  for (var i = 0; true; i++) {
    var value = [];
    for (var j = 0; j < arguments.length; j++) {
      var arr = arguments[j];
      // If i is larger than the array length, this is the shortest array.
      if (i >= arr.length) {
        return result;
      }
      value.push(arr[i]);
    }
    result.push(value);
  }
};


/**
 * Shuffles the values in the specified array using the Fisher-Yates in-place
 * shuffle (also known as the Knuth Shuffle). By default, calls Math.random()
 * and so resets the state of that random number generator. Similarly, may reset
 * the state of the any other specified random number generator.
 *
 * Runtime: O(n)
 *
 * @param {!Array} arr The array to be shuffled.
 * @param {function():number=} opt_randFn Optional random function to use for
 *     shuffling.
 *     Takes no arguments, and returns a random number on the interval [0, 1).
 *     Defaults to Math.random() using JavaScript's built-in Math library.
 */
goog.array.shuffle = function(arr, opt_randFn) {
  var randFn = opt_randFn || Math.random;

  for (var i = arr.length - 1; i > 0; i--) {
    // Choose a random array index in [0, i] (inclusive with i).
    var j = Math.floor(randFn() * (i + 1));

    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
  }
};
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A map of listeners that provides utility functions to
 * deal with listeners on an event target. Used by
 * {@code goog.events.EventTarget}.
 *
 * WARNING: Do not use this class from outside goog.events package.
 *
 * @visibility {//closure/goog/bin/sizetests:__pkg__}
 * @visibility {//closure/goog/events:__pkg__}
 * @visibility {//closure/goog/labs/events:__pkg__}
 */

goog.provide('goog.events.ListenerMap');

goog.require('goog.array');
goog.require('goog.events.Listener');
goog.require('goog.object');



/**
 * Creates a new listener map.
 * @param {EventTarget|goog.events.Listenable} src The src object.
 * @constructor
 * @final
 */
goog.events.ListenerMap = function(src) {
  /** @type {EventTarget|goog.events.Listenable} */
  this.src = src;

  /**
   * Maps of event type to an array of listeners.
   * @type {Object.<string, !Array.<!goog.events.Listener>>}
   */
  this.listeners = {};

  /**
   * The count of types in this map that have registered listeners.
   * @private {number}
   */
  this.typeCount_ = 0;
};


/**
 * @return {number} The count of event types in this map that actually
 *     have registered listeners.
 */
goog.events.ListenerMap.prototype.getTypeCount = function() {
  return this.typeCount_;
};


/**
 * @return {number} Total number of registered listeners.
 */
goog.events.ListenerMap.prototype.getListenerCount = function() {
  var count = 0;
  for (var type in this.listeners) {
    count += this.listeners[type].length;
  }
  return count;
};


/**
 * Adds an event listener. A listener can only be added once to an
 * object and if it is added again the key for the listener is
 * returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {string|!goog.events.EventId} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 */
goog.events.ListenerMap.prototype.add = function(
    type, listener, callOnce, opt_useCapture, opt_listenerScope) {
  var typeStr = type.toString();
  var listenerArray = this.listeners[typeStr];
  if (!listenerArray) {
    listenerArray = this.listeners[typeStr] = [];
    this.typeCount_++;
  }

  var listenerObj;
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    listenerObj = listenerArray[index];
    if (!callOnce) {
      // Ensure that, if there is an existing callOnce listener, it is no
      // longer a callOnce listener.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = new goog.events.Listener(
        listener, null, this.src, typeStr, !!opt_useCapture, opt_listenerScope);
    listenerObj.callOnce = callOnce;
    listenerArray.push(listenerObj);
  }
  return listenerObj;
};


/**
 * Removes a matching listener.
 * @param {string|!goog.events.EventId} type The listener event type.
 * @param {!Function} listener This listener callback method.
 * @param {boolean=} opt_useCapture The capture mode of the listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {boolean} Whether any listener was removed.
 */
goog.events.ListenerMap.prototype.remove = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  var typeStr = type.toString();
  if (!(typeStr in this.listeners)) {
    return false;
  }

  var listenerArray = this.listeners[typeStr];
  var index = goog.events.ListenerMap.findListenerIndex_(
      listenerArray, listener, opt_useCapture, opt_listenerScope);
  if (index > -1) {
    var listenerObj = listenerArray[index];
    listenerObj.markAsRemoved();
    goog.array.removeAt(listenerArray, index);
    if (listenerArray.length == 0) {
      delete this.listeners[typeStr];
      this.typeCount_--;
    }
    return true;
  }
  return false;
};


/**
 * Removes the given listener object.
 * @param {goog.events.ListenableKey} listener The listener to remove.
 * @return {boolean} Whether the listener is removed.
 */
goog.events.ListenerMap.prototype.removeByKey = function(listener) {
  var type = listener.type;
  if (!(type in this.listeners)) {
    return false;
  }

  var removed = goog.array.remove(this.listeners[type], listener);
  if (removed) {
    listener.markAsRemoved();
    if (this.listeners[type].length == 0) {
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return removed;
};


/**
 * Removes all listeners from this map. If opt_type is provided, only
 * listeners that match the given type are removed.
 * @param {string|!goog.events.EventId=} opt_type Type of event to remove.
 * @return {number} Number of listeners removed.
 */
goog.events.ListenerMap.prototype.removeAll = function(opt_type) {
  var typeStr = opt_type && opt_type.toString();
  var count = 0;
  for (var type in this.listeners) {
    if (!typeStr || type == typeStr) {
      var listenerArray = this.listeners[type];
      for (var i = 0; i < listenerArray.length; i++) {
        ++count;
        listenerArray[i].markAsRemoved();
      }
      delete this.listeners[type];
      this.typeCount_--;
    }
  }
  return count;
};


/**
 * Gets all listeners that match the given type and capture mode. The
 * returned array is a copy (but the listener objects are not).
 * @param {string|!goog.events.EventId} type The type of the listeners
 *     to retrieve.
 * @param {boolean} capture The capture mode of the listeners to retrieve.
 * @return {!Array.<goog.events.ListenableKey>} An array of matching
 *     listeners.
 */
goog.events.ListenerMap.prototype.getListeners = function(type, capture) {
  var listenerArray = this.listeners[type.toString()];
  var rv = [];
  if (listenerArray) {
    for (var i = 0; i < listenerArray.length; ++i) {
      var listenerObj = listenerArray[i];
      if (listenerObj.capture == capture) {
        rv.push(listenerObj);
      }
    }
  }
  return rv;
};


/**
 * Gets the goog.events.ListenableKey for the event or null if no such
 * listener is in use.
 *
 * @param {string|!goog.events.EventId} type The type of the listener
 *     to retrieve.
 * @param {!Function} listener The listener function to get.
 * @param {boolean} capture Whether the listener is a capturing listener.
 * @param {Object=} opt_listenerScope Object in whose scope to call the
 *     listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 */
goog.events.ListenerMap.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  var listenerArray = this.listeners[type.toString()];
  var i = -1;
  if (listenerArray) {
    i = goog.events.ListenerMap.findListenerIndex_(
        listenerArray, listener, capture, opt_listenerScope);
  }
  return i > -1 ? listenerArray[i] : null;
};


/**
 * Whether there is a matching listener. If either the type or capture
 * parameters are unspecified, the function will match on the
 * remaining criteria.
 *
 * @param {string|!goog.events.EventId=} opt_type The type of the listener.
 * @param {boolean=} opt_capture The capture mode of the listener.
 * @return {boolean} Whether there is an active listener matching
 *     the requested type and/or capture phase.
 */
goog.events.ListenerMap.prototype.hasListener = function(
    opt_type, opt_capture) {
  var hasType = goog.isDef(opt_type);
  var typeStr = hasType ? opt_type.toString() : '';
  var hasCapture = goog.isDef(opt_capture);

  return goog.object.some(
      this.listeners, function(listenerArray, type) {
        for (var i = 0; i < listenerArray.length; ++i) {
          if ((!hasType || listenerArray[i].type == typeStr) &&
              (!hasCapture || listenerArray[i].capture == opt_capture)) {
            return true;
          }
        }

        return false;
      });
};


/**
 * Finds the index of a matching goog.events.Listener in the given
 * listenerArray.
 * @param {!Array.<!goog.events.Listener>} listenerArray Array of listener.
 * @param {!Function} listener The listener function.
 * @param {boolean=} opt_useCapture The capture flag for the listener.
 * @param {Object=} opt_listenerScope The listener scope.
 * @return {number} The index of the matching listener within the
 *     listenerArray.
 * @private
 */
goog.events.ListenerMap.findListenerIndex_ = function(
    listenerArray, listener, opt_useCapture, opt_listenerScope) {
  for (var i = 0; i < listenerArray.length; ++i) {
    var listenerObj = listenerArray[i];
    if (!listenerObj.removed &&
        listenerObj.listener == listener &&
        listenerObj.capture == !!opt_useCapture &&
        listenerObj.handler == opt_listenerScope) {
      return i;
    }
  }
  return -1;
};
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities used by goog.labs.userAgent tools. These functions
 * should not be used outside of goog.labs.userAgent.*.
 *
 * @visibility {//closure/goog/bin/sizetests:__pkg__}
 * @visibility {//closure/goog/dom:__subpackages__}
 * @visibility {//closure/goog/style:__pkg__}
 * @visibility {//closure/goog/testing:__pkg__}
 * @visibility {//closure/goog/useragent:__subpackages__}
 * @visibility {//testing/puppet/modules:__pkg__} *
 *
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('goog.labs.userAgent.util');

goog.require('goog.string');


/**
 * Gets the native userAgent string from navigator if it exists.
 * If navigator or navigator.userAgent string is missing, returns an empty
 * string.
 * @return {string}
 * @private
 */
goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
  var navigator = goog.labs.userAgent.util.getNavigator_();
  if (navigator) {
    var userAgent = navigator.userAgent;
    if (userAgent) {
      return userAgent;
    }
  }
  return '';
};


/**
 * Getter for the native navigator.
 * This is a separate function so it can be stubbed out in testing.
 * @return {Navigator}
 * @private
 */
goog.labs.userAgent.util.getNavigator_ = function() {
  return goog.global.navigator;
};


/**
 * A possible override for applications which wish to not check
 * navigator.userAgent but use a specified value for detection instead.
 * @private {string}
 */
goog.labs.userAgent.util.userAgent_ =
    goog.labs.userAgent.util.getNativeUserAgentString_();


/**
 * Applications may override browser detection on the built in
 * navigator.userAgent object by setting this string. Set to null to use the
 * browser object instead.
 * @param {?string=} opt_userAgent The User-Agent override.
 */
goog.labs.userAgent.util.setUserAgent = function(opt_userAgent) {
  goog.labs.userAgent.util.userAgent_ = opt_userAgent ||
      goog.labs.userAgent.util.getNativeUserAgentString_();
};


/**
 * @return {string} The user agent string.
 */
goog.labs.userAgent.util.getUserAgent = function() {
  return goog.labs.userAgent.util.userAgent_;
};


/**
 * @param {string} str
 * @return {boolean} Whether the user agent contains the given string, ignoring
 *     case.
 */
goog.labs.userAgent.util.matchUserAgent = function(str) {
  var userAgent = goog.labs.userAgent.util.getUserAgent();
  return goog.string.contains(userAgent, str);
};


/**
 * @param {string} str
 * @return {boolean} Whether the user agent contains the given string.
 */
goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(str) {
  var userAgent = goog.labs.userAgent.util.getUserAgent();
  return goog.string.caseInsensitiveContains(userAgent, str);
};


/**
 * Parses the user agent into tuples for each section.
 * @param {string} userAgent
 * @return {!Array.<!Array.<string>>} Tuples of key, version, and the contents
 *     of the parenthetical.
 */
goog.labs.userAgent.util.extractVersionTuples = function(userAgent) {
  // Matches each section of a user agent string.
  // Example UA:
  // Mozilla/5.0 (iPad; U; CPU OS 3_2_1 like Mac OS X; en-us)
  // AppleWebKit/531.21.10 (KHTML, like Gecko) Mobile/7B405
  // This has three version tuples: Mozilla, AppleWebKit, and Mobile.

  var versionRegExp = new RegExp(
      // Key. Note that a key may have a space.
      // (i.e. 'Mobile Safari' in 'Mobile Safari/5.0')
      '(\\w[\\w ]+)' +

      '/' +                // slash
      '([^\\s]+)' +        // version (i.e. '5.0b')
      '\\s*' +             // whitespace
      '(?:\\((.*?)\\))?',  // parenthetical info. parentheses not matched.
      'g');

  var data = [];
  var match;

  // Iterate and collect the version tuples.  Each iteration will be the
  // next regex match.
  while (match = versionRegExp.exec(userAgent)) {
    data.push([
      match[1],  // key
      match[2],  // value
      // || undefined as this is not undefined in IE7 and IE8
      match[3] || undefined  // info
    ]);
  }

  return data;
};

// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Closure user agent detection (Browser).
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For more information on rendering engine, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent, goog.labs.userAgent.platform,
 * goog.labs.userAgent.device respectively.)
 *
 */

goog.provide('goog.labs.userAgent.browser');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @return {boolean} Whether the user's browser is Opera.
 * @private
 */
goog.labs.userAgent.browser.matchOpera_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Opera') ||
      goog.labs.userAgent.util.matchUserAgent('OPR');
};


/**
 * @return {boolean} Whether the user's browser is IE.
 * @private
 */
goog.labs.userAgent.browser.matchIE_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Trident') ||
      goog.labs.userAgent.util.matchUserAgent('MSIE');
};


/**
 * @return {boolean} Whether the user's browser is Firefox.
 * @private
 */
goog.labs.userAgent.browser.matchFirefox_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Firefox');
};


/**
 * @return {boolean} Whether the user's browser is Safari.
 * @private
 */
goog.labs.userAgent.browser.matchSafari_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Safari') &&
      !goog.labs.userAgent.util.matchUserAgent('Chrome') &&
      !goog.labs.userAgent.util.matchUserAgent('CriOS') &&
      !goog.labs.userAgent.util.matchUserAgent('Android');
};


/**
 * @return {boolean} Whether the user's browser is Chrome.
 * @private
 */
goog.labs.userAgent.browser.matchChrome_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Chrome') ||
      goog.labs.userAgent.util.matchUserAgent('CriOS');
};


/**
 * @return {boolean} Whether the user's browser is the Android browser.
 * @private
 */
goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
  return goog.labs.userAgent.util.matchUserAgent('Android') &&
      !goog.labs.userAgent.util.matchUserAgent('Chrome') &&
      !goog.labs.userAgent.util.matchUserAgent('CriOS');
};


/**
 * @return {boolean} Whether the user's browser is Opera.
 */
goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;


/**
 * @return {boolean} Whether the user's browser is IE.
 */
goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;


/**
 * @return {boolean} Whether the user's browser is Firefox.
 */
goog.labs.userAgent.browser.isFirefox =
    goog.labs.userAgent.browser.matchFirefox_;


/**
 * @return {boolean} Whether the user's browser is Safari.
 */
goog.labs.userAgent.browser.isSafari =
    goog.labs.userAgent.browser.matchSafari_;


/**
 * @return {boolean} Whether the user's browser is Chrome.
 */
goog.labs.userAgent.browser.isChrome =
    goog.labs.userAgent.browser.matchChrome_;


/**
 * @return {boolean} Whether the user's browser is the Android browser.
 */
goog.labs.userAgent.browser.isAndroidBrowser =
    goog.labs.userAgent.browser.matchAndroidBrowser_;


/**
 * For more information, see:
 * http://docs.aws.amazon.com/silk/latest/developerguide/user-agent.html
 * @return {boolean} Whether the user's browser is Silk.
 */
goog.labs.userAgent.browser.isSilk = function() {
  return goog.labs.userAgent.util.matchUserAgent('Silk');
};


/**
 * @return {string} The browser version or empty string if version cannot be
 *     determined. Note that for Internet Explorer, this returns the version of
 *     the browser, not the version of the rendering engine. (IE 8 in
 *     compatibility mode will return 8.0 rather than 7.0. To determine the
 *     rendering engine version, look at document.documentMode instead. See
 *     http://msdn.microsoft.com/en-us/library/cc196988(v=vs.85).aspx for more
 *     details.)
 */
goog.labs.userAgent.browser.getVersion = function() {
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  // Special case IE since IE's version is inside the parenthesis and
  // without the '/'.
  if (goog.labs.userAgent.browser.isIE()) {
    return goog.labs.userAgent.browser.getIEVersion_(userAgentString);
  }

  if (goog.labs.userAgent.browser.isOpera()) {
    return goog.labs.userAgent.browser.getOperaVersion_(userAgentString);
  }

  var versionTuples =
      goog.labs.userAgent.util.extractVersionTuples(userAgentString);
  return goog.labs.userAgent.browser.getVersionFromTuples_(versionTuples);
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the browser version is higher or the same as the
 *     given version.
 */
goog.labs.userAgent.browser.isVersionOrHigher = function(version) {
  return goog.string.compareVersions(goog.labs.userAgent.browser.getVersion(),
                                     version) >= 0;
};


/**
 * Determines IE version. More information:
 * http://msdn.microsoft.com/en-us/library/ie/bg182625(v=vs.85).aspx#uaString
 * http://msdn.microsoft.com/en-us/library/hh869301(v=vs.85).aspx
 * http://blogs.msdn.com/b/ie/archive/2010/03/23/introducing-ie9-s-user-agent-string.aspx
 * http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx
 *
 * @param {string} userAgent the User-Agent.
 * @return {string}
 * @private
 */
goog.labs.userAgent.browser.getIEVersion_ = function(userAgent) {
  // IE11 may identify itself as MSIE 9.0 or MSIE 10.0 due to an IE 11 upgrade
  // bug. Example UA:
  // Mozilla/5.0 (MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; rv:11.0)
  // like Gecko.
  // See http://www.whatismybrowser.com/developers/unknown-user-agent-fragments.
  var rv = /rv: *([\d\.]*)/.exec(userAgent);
  if (rv && rv[1]) {
    return rv[1];
  }

  var version = '';
  var msie = /MSIE +([\d\.]+)/.exec(userAgent);
  if (msie && msie[1]) {
    // IE in compatibility mode usually identifies itself as MSIE 7.0; in this
    // case, use the Trident version to determine the version of IE. For more
    // details, see the links above.
    var tridentVersion = /Trident\/(\d.\d)/.exec(userAgent);
    if (msie[1] == '7.0') {
      if (tridentVersion && tridentVersion[1]) {
        switch (tridentVersion[1]) {
          case '4.0':
            version = '8.0';
            break;
          case '5.0':
            version = '9.0';
            break;
          case '6.0':
            version = '10.0';
            break;
          case '7.0':
            version = '11.0';
            break;
        }
      } else {
        version = '7.0';
      }
    } else {
      version = msie[1];
    }
  }
  return version;
};


/**
 * Determines Opera version. More information:
 * http://my.opera.com/ODIN/blog/2013/07/15/opera-user-agent-strings-opera-15-and-beyond
 *
 * @param {string} userAgent The User-Agent.
 * @return {string}
 * @private
 */
goog.labs.userAgent.browser.getOperaVersion_ = function(userAgent) {
  var versionTuples =
      goog.labs.userAgent.util.extractVersionTuples(userAgent);
  var lastTuple = goog.array.peek(versionTuples);
  if (lastTuple[0] == 'OPR' && lastTuple[1]) {
    return lastTuple[1];
  }

  return goog.labs.userAgent.browser.getVersionFromTuples_(versionTuples);
};


/**
 * Nearly all User-Agents start with Mozilla/N.0. This looks at the second tuple
 * for the actual browser version number.
 * @param {!Array.<!Array.<string>>} versionTuples
 * @return {string} The version or empty string if it cannot be determined.
 * @private
 */
goog.labs.userAgent.browser.getVersionFromTuples_ = function(versionTuples) {
  // versionTuples[2] (The first X/Y tuple after the parenthesis) contains the
  // browser version number.
  goog.asserts.assert(versionTuples.length > 2,
      'Couldn\'t extract version tuple from user agent string');
  return versionTuples[2] && versionTuples[2][1] ? versionTuples[2][1] : '';
};
// Copyright 2013 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Closure user agent detection.
 * @see http://en.wikipedia.org/wiki/User_agent
 * For more information on browser brand, platform, or device see the other
 * sub-namespaces in goog.labs.userAgent (browser, platform, and device).
 *
 */

goog.provide('goog.labs.userAgent.engine');

goog.require('goog.array');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @return {boolean} Whether the rendering engine is Presto.
 */
goog.labs.userAgent.engine.isPresto = function() {
  return goog.labs.userAgent.util.matchUserAgent('Presto');
};


/**
 * @return {boolean} Whether the rendering engine is Trident.
 */
goog.labs.userAgent.engine.isTrident = function() {
  // IE only started including the Trident token in IE8.
  return goog.labs.userAgent.util.matchUserAgent('Trident') ||
      goog.labs.userAgent.util.matchUserAgent('MSIE');
};


/**
 * @return {boolean} Whether the rendering engine is WebKit.
 */
goog.labs.userAgent.engine.isWebKit = function() {
  return goog.labs.userAgent.util.matchUserAgentIgnoreCase('WebKit');
};


/**
 * @return {boolean} Whether the rendering engine is Gecko.
 */
goog.labs.userAgent.engine.isGecko = function() {
  return goog.labs.userAgent.util.matchUserAgent('Gecko') &&
      !goog.labs.userAgent.engine.isWebKit() &&
      !goog.labs.userAgent.engine.isTrident();
};


/**
 * @return {string} The rendering engine's version or empty string if version
 *     can't be determined.
 */
goog.labs.userAgent.engine.getVersion = function() {
  var userAgentString = goog.labs.userAgent.util.getUserAgent();
  if (userAgentString) {
    var tuples = goog.labs.userAgent.util.extractVersionTuples(
        userAgentString);

    var engineTuple = tuples[1];
    if (engineTuple) {
      // In Gecko, the version string is either in the browser info or the
      // Firefox version.  See Gecko user agent string reference:
      // http://goo.gl/mULqa
      if (engineTuple[0] == 'Gecko') {
        return goog.labs.userAgent.engine.getVersionForKey_(
            tuples, 'Firefox');
      }

      return engineTuple[1];
    }

    // IE has only one version identifier, and the Trident version is
    // specified in the parenthetical.
    var browserTuple = tuples[0];
    var info;
    if (browserTuple && (info = browserTuple[2])) {
      var match = /Trident\/([^\s;]+)/.exec(info);
      if (match) {
        return match[1];
      }
    }
  }
  return '';
};


/**
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the rendering engine version is higher or the same
 *     as the given version.
 */
goog.labs.userAgent.engine.isVersionOrHigher = function(version) {
  return goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(),
                                     version) >= 0;
};


/**
 * @param {!Array.<!Array.<string>>} tuples Version tuples.
 * @param {string} key The key to look for.
 * @return {string} The version string of the given key, if present.
 *     Otherwise, the empty string.
 * @private
 */
goog.labs.userAgent.engine.getVersionForKey_ = function(tuples, key) {
  // TODO(nnaze): Move to util if useful elsewhere.

  var pair = goog.array.find(tuples, function(pair) {
    return key == pair[0];
  });

  return pair && pair[1] || '';
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Rendering engine detection.
 * @see <a href="http://www.useragentstring.com/">User agent strings</a>
 * For information on the browser brand (such as Safari versus Chrome), see
 * goog.userAgent.product.
 * @see ../demos/useragent.html
 */

goog.provide('goog.userAgent');

goog.require('goog.labs.userAgent.browser');
goog.require('goog.labs.userAgent.engine');
goog.require('goog.labs.userAgent.util');
goog.require('goog.string');


/**
 * @define {boolean} Whether we know at compile-time that the browser is IE.
 */
goog.define('goog.userAgent.ASSUME_IE', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is GECKO.
 */
goog.define('goog.userAgent.ASSUME_GECKO', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is WEBKIT.
 */
goog.define('goog.userAgent.ASSUME_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is a
 *     mobile device running WebKit e.g. iPhone or Android.
 */
goog.define('goog.userAgent.ASSUME_MOBILE_WEBKIT', false);


/**
 * @define {boolean} Whether we know at compile-time that the browser is OPERA.
 */
goog.define('goog.userAgent.ASSUME_OPERA', false);


/**
 * @define {boolean} Whether the
 *     {@code goog.userAgent.isVersionOrHigher}
 *     function will return true for any version.
 */
goog.define('goog.userAgent.ASSUME_ANY_VERSION', false);


/**
 * Whether we know the browser engine at compile-time.
 * @type {boolean}
 * @private
 */
goog.userAgent.BROWSER_KNOWN_ =
    goog.userAgent.ASSUME_IE ||
    goog.userAgent.ASSUME_GECKO ||
    goog.userAgent.ASSUME_MOBILE_WEBKIT ||
    goog.userAgent.ASSUME_WEBKIT ||
    goog.userAgent.ASSUME_OPERA;


/**
 * Returns the userAgent string for the current browser.
 *
 * @return {string} The userAgent string.
 */
goog.userAgent.getUserAgentString = function() {
  return goog.labs.userAgent.util.getUserAgent();
};


/**
 * TODO(nnaze): Change type to "Navigator" and update compilation targets.
 * @return {Object} The native navigator object.
 */
goog.userAgent.getNavigator = function() {
  // Need a local navigator reference instead of using the global one,
  // to avoid the rare case where they reference different objects.
  // (in a WorkerPool, for example).
  return goog.global['navigator'] || null;
};


/**
 * Whether the user agent is Opera.
 * @type {boolean}
 */
goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_OPERA :
    goog.labs.userAgent.browser.isOpera();


/**
 * Whether the user agent is Internet Explorer.
 * @type {boolean}
 */
goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_IE :
    goog.labs.userAgent.browser.isIE();


/**
 * Whether the user agent is Gecko. Gecko is the rendering engine used by
 * Mozilla, Firefox, and others.
 * @type {boolean}
 */
goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_GECKO :
    goog.labs.userAgent.engine.isGecko();


/**
 * Whether the user agent is WebKit. WebKit is the rendering engine that
 * Safari, Android and others use.
 * @type {boolean}
 */
goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ?
    goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT :
    goog.labs.userAgent.engine.isWebKit();


/**
 * Whether the user agent is running on a mobile device.
 *
 * This is a separate function so that the logic can be tested.
 *
 * TODO(nnaze): Investigate swapping in goog.labs.userAgent.device.isMobile().
 *
 * @return {boolean} Whether the user agent is running on a mobile device.
 * @private
 */
goog.userAgent.isMobile_ = function() {
  return goog.userAgent.WEBKIT &&
         goog.labs.userAgent.util.matchUserAgent('Mobile');
};


/**
 * Whether the user agent is running on a mobile device.
 *
 * TODO(nnaze): Consider deprecating MOBILE when labs.userAgent
 *   is promoted as the gecko/webkit logic is likely inaccurate.
 *
 * @type {boolean}
 */
goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT ||
                        goog.userAgent.isMobile_();


/**
 * Used while transitioning code to use WEBKIT instead.
 * @type {boolean}
 * @deprecated Use {@link goog.userAgent.product.SAFARI} instead.
 * TODO(nicksantos): Delete this from goog.userAgent.
 */
goog.userAgent.SAFARI = goog.userAgent.WEBKIT;


/**
 * @return {string} the platform (operating system) the user agent is running
 *     on. Default to empty string because navigator.platform may not be defined
 *     (on Rhino, for example).
 * @private
 */
goog.userAgent.determinePlatform_ = function() {
  var navigator = goog.userAgent.getNavigator();
  return navigator && navigator.platform || '';
};


/**
 * The platform (operating system) the user agent is running on. Default to
 * empty string because navigator.platform may not be defined (on Rhino, for
 * example).
 * @type {string}
 */
goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();


/**
 * @define {boolean} Whether the user agent is running on a Macintosh operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_MAC', false);


/**
 * @define {boolean} Whether the user agent is running on a Windows operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_WINDOWS', false);


/**
 * @define {boolean} Whether the user agent is running on a Linux operating
 *     system.
 */
goog.define('goog.userAgent.ASSUME_LINUX', false);


/**
 * @define {boolean} Whether the user agent is running on a X11 windowing
 *     system.
 */
goog.define('goog.userAgent.ASSUME_X11', false);


/**
 * @define {boolean} Whether the user agent is running on Android.
 */
goog.define('goog.userAgent.ASSUME_ANDROID', false);


/**
 * @define {boolean} Whether the user agent is running on an iPhone.
 */
goog.define('goog.userAgent.ASSUME_IPHONE', false);


/**
 * @define {boolean} Whether the user agent is running on an iPad.
 */
goog.define('goog.userAgent.ASSUME_IPAD', false);


/**
 * @type {boolean}
 * @private
 */
goog.userAgent.PLATFORM_KNOWN_ =
    goog.userAgent.ASSUME_MAC ||
    goog.userAgent.ASSUME_WINDOWS ||
    goog.userAgent.ASSUME_LINUX ||
    goog.userAgent.ASSUME_X11 ||
    goog.userAgent.ASSUME_ANDROID ||
    goog.userAgent.ASSUME_IPHONE ||
    goog.userAgent.ASSUME_IPAD;


/**
 * Initialize the goog.userAgent constants that define which platform the user
 * agent is running on.
 * @private
 */
goog.userAgent.initPlatform_ = function() {
  /**
   * Whether the user agent is running on a Macintosh operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedMac_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Mac');

  /**
   * Whether the user agent is running on a Windows operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedWindows_ = goog.string.contains(
      goog.userAgent.PLATFORM, 'Win');

  /**
   * Whether the user agent is running on a Linux operating system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedLinux_ = goog.string.contains(goog.userAgent.PLATFORM,
      'Linux');

  /**
   * Whether the user agent is running on a X11 windowing system.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedX11_ = !!goog.userAgent.getNavigator() &&
      goog.string.contains(goog.userAgent.getNavigator()['appVersion'] || '',
          'X11');

  // Need user agent string for Android/IOS detection
  var ua = goog.userAgent.getUserAgentString();

  /**
   * Whether the user agent is running on Android.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedAndroid_ = !!ua &&
      goog.string.contains(ua, 'Android');

  /**
   * Whether the user agent is running on an iPhone.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIPhone_ = !!ua && goog.string.contains(ua, 'iPhone');

  /**
   * Whether the user agent is running on an iPad.
   * @type {boolean}
   * @private
   */
  goog.userAgent.detectedIPad_ = !!ua && goog.string.contains(ua, 'iPad');
};


if (!goog.userAgent.PLATFORM_KNOWN_) {
  goog.userAgent.initPlatform_();
}


/**
 * Whether the user agent is running on a Macintosh operating system.
 * @type {boolean}
 */
goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_MAC : goog.userAgent.detectedMac_;


/**
 * Whether the user agent is running on a Windows operating system.
 * @type {boolean}
 */
goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_WINDOWS : goog.userAgent.detectedWindows_;


/**
 * Whether the user agent is running on a Linux operating system.
 * @type {boolean}
 */
goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_LINUX : goog.userAgent.detectedLinux_;


/**
 * Whether the user agent is running on a X11 windowing system.
 * @type {boolean}
 */
goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_X11 : goog.userAgent.detectedX11_;


/**
 * Whether the user agent is running on Android.
 * @type {boolean}
 */
goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_ANDROID : goog.userAgent.detectedAndroid_;


/**
 * Whether the user agent is running on an iPhone.
 * @type {boolean}
 */
goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPHONE : goog.userAgent.detectedIPhone_;


/**
 * Whether the user agent is running on an iPad.
 * @type {boolean}
 */
goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ?
    goog.userAgent.ASSUME_IPAD : goog.userAgent.detectedIPad_;


/**
 * @return {string} The string that describes the version number of the user
 *     agent.
 * @private
 */
goog.userAgent.determineVersion_ = function() {
  // All browsers have different ways to detect the version and they all have
  // different naming schemes.

  // version is a string rather than a number because it may contain 'b', 'a',
  // and so on.
  var version = '', re;

  if (goog.userAgent.OPERA && goog.global['opera']) {
    var operaVersion = goog.global['opera'].version;
    return goog.isFunction(operaVersion) ? operaVersion() : operaVersion;
  }

  if (goog.userAgent.GECKO) {
    re = /rv\:([^\);]+)(\)|;)/;
  } else if (goog.userAgent.IE) {
    re = /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/;
  } else if (goog.userAgent.WEBKIT) {
    // WebKit/125.4
    re = /WebKit\/(\S+)/;
  }

  if (re) {
    var arr = re.exec(goog.userAgent.getUserAgentString());
    version = arr ? arr[1] : '';
  }

  if (goog.userAgent.IE) {
    // IE9 can be in document mode 9 but be reporting an inconsistent user agent
    // version.  If it is identifying as a version lower than 9 we take the
    // documentMode as the version instead.  IE8 has similar behavior.
    // It is recommended to set the X-UA-Compatible header to ensure that IE9
    // uses documentMode 9.
    var docMode = goog.userAgent.getDocumentMode_();
    if (docMode > parseFloat(version)) {
      return String(docMode);
    }
  }

  return version;
};


/**
 * @return {number|undefined} Returns the document mode (for testing).
 * @private
 */
goog.userAgent.getDocumentMode_ = function() {
  // NOTE(user): goog.userAgent may be used in context where there is no DOM.
  var doc = goog.global['document'];
  return doc ? doc['documentMode'] : undefined;
};


/**
 * The version of the user agent. This is a string because it might contain
 * 'b' (as in beta) as well as multiple dots.
 * @type {string}
 */
goog.userAgent.VERSION = goog.userAgent.determineVersion_();


/**
 * Compares two version numbers.
 *
 * @param {string} v1 Version of first item.
 * @param {string} v2 Version of second item.
 *
 * @return {number}  1 if first argument is higher
 *                   0 if arguments are equal
 *                  -1 if second argument is higher.
 * @deprecated Use goog.string.compareVersions.
 */
goog.userAgent.compare = function(v1, v2) {
  return goog.string.compareVersions(v1, v2);
};


/**
 * Cache for {@link goog.userAgent.isVersionOrHigher}.
 * Calls to compareVersions are surprisingly expensive and, as a browser's
 * version number is unlikely to change during a session, we cache the results.
 * @const
 * @private
 */
goog.userAgent.isVersionOrHigherCache_ = {};


/**
 * Whether the user agent version is higher or the same as the given version.
 * NOTE: When checking the version numbers for Firefox and Safari, be sure to
 * use the engine's version, not the browser's version number.  For example,
 * Firefox 3.0 corresponds to Gecko 1.9 and Safari 3.0 to Webkit 522.11.
 * Opera and Internet Explorer versions match the product release number.<br>
 * @see <a href="http://en.wikipedia.org/wiki/Safari_version_history">
 *     Webkit</a>
 * @see <a href="http://en.wikipedia.org/wiki/Gecko_engine">Gecko</a>
 *
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 */
goog.userAgent.isVersionOrHigher = function(version) {
  return goog.userAgent.ASSUME_ANY_VERSION ||
      goog.userAgent.isVersionOrHigherCache_[version] ||
      (goog.userAgent.isVersionOrHigherCache_[version] =
          goog.string.compareVersions(goog.userAgent.VERSION, version) >= 0);
};


/**
 * Deprecated alias to {@code goog.userAgent.isVersionOrHigher}.
 * @param {string|number} version The version to check.
 * @return {boolean} Whether the user agent version is higher or the same as
 *     the given version.
 * @deprecated Use goog.userAgent.isVersionOrHigher().
 */
goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;


/**
 * Whether the IE effective document mode is higher or the same as the given
 * document mode version.
 * NOTE: Only for IE, return false for another browser.
 *
 * @param {number} documentMode The document mode version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *     same as the given version.
 */
goog.userAgent.isDocumentModeOrHigher = function(documentMode) {
  return goog.userAgent.IE && goog.userAgent.DOCUMENT_MODE >= documentMode;
};


/**
 * Deprecated alias to {@code goog.userAgent.isDocumentModeOrHigher}.
 * @param {number} version The version to check.
 * @return {boolean} Whether the IE effective document mode is higher or the
 *      same as the given version.
 * @deprecated Use goog.userAgent.isDocumentModeOrHigher().
 */
goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;


/**
 * For IE version < 7, documentMode is undefined, so attempt to use the
 * CSS1Compat property to see if we are in standards mode. If we are in
 * standards mode, treat the browser version as the document mode. Otherwise,
 * IE is emulating version 5.
 * @type {number|undefined}
 * @const
 */
goog.userAgent.DOCUMENT_MODE = (function() {
  var doc = goog.global['document'];
  if (!doc || !goog.userAgent.IE) {
    return undefined;
  }
  var mode = goog.userAgent.getDocumentMode_();
  return mode || (doc['compatMode'] == 'CSS1Compat' ?
      parseInt(goog.userAgent.VERSION, 10) : 5);
})();
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the events package.
 *
 */


goog.provide('goog.events.BrowserFeature');

goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.events.BrowserFeature = {
  /**
   * Whether the button attribute of the event is W3C compliant.  False in
   * Internet Explorer prior to version 9; document-version dependent.
   */
  HAS_W3C_BUTTON: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * Whether the browser supports full W3C event model.
   */
  HAS_W3C_EVENT_SUPPORT: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * To prevent default in IE7-8 for certain keydown events we need set the
   * keyCode to -1.
   */
  SET_KEY_CODE_TO_PREVENT_DEFAULT: goog.userAgent.IE &&
      !goog.userAgent.isVersionOrHigher('9'),

  /**
   * Whether the {@code navigator.onLine} property is supported.
   */
  HAS_NAVIGATOR_ONLINE_PROPERTY: !goog.userAgent.WEBKIT ||
      goog.userAgent.isVersionOrHigher('528'),

  /**
   * Whether HTML5 network online/offline events are supported.
   */
  HAS_HTML5_NETWORK_EVENT_SUPPORT:
      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9b') ||
      goog.userAgent.IE && goog.userAgent.isVersionOrHigher('8') ||
      goog.userAgent.OPERA && goog.userAgent.isVersionOrHigher('9.5') ||
      goog.userAgent.WEBKIT && goog.userAgent.isVersionOrHigher('528'),

  /**
   * Whether HTML5 network events fire on document.body, or otherwise the
   * window.
   */
  HTML5_NETWORK_EVENTS_FIRE_ON_BODY:
      goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('8') ||
      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9'),

  /**
   * Whether touch is enabled in the browser.
   */
  TOUCH_ENABLED:
      ('ontouchstart' in goog.global ||
          !!(goog.global['document'] &&
             document.documentElement &&
             'ontouchstart' in document.documentElement) ||
          // IE10 uses non-standard touch events, so it has a different check.
          !!(goog.global['navigator'] &&
              goog.global['navigator']['msMaxTouchPoints']))
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A global registry for entry points into a program,
 * so that they can be instrumented. Each module should register their
 * entry points with this registry. Designed to be compiled out
 * if no instrumentation is requested.
 *
 * Entry points may be registered before or after a call to
 * goog.debug.entryPointRegistry.monitorAll. If an entry point is registered
 * later, the existing monitor will instrument the new entry point.
 *
 * @author nicksantos@google.com (Nick Santos)
 */

goog.provide('goog.debug.EntryPointMonitor');
goog.provide('goog.debug.entryPointRegistry');

goog.require('goog.asserts');



/**
 * @interface
 */
goog.debug.EntryPointMonitor = function() {};


/**
 * Instruments a function.
 *
 * @param {!Function} fn A function to instrument.
 * @return {!Function} The instrumented function.
 */
goog.debug.EntryPointMonitor.prototype.wrap;


/**
 * Try to remove an instrumentation wrapper created by this monitor.
 * If the function passed to unwrap is not a wrapper created by this
 * monitor, then we will do nothing.
 *
 * Notice that some wrappers may not be unwrappable. For example, if other
 * monitors have applied their own wrappers, then it will be impossible to
 * unwrap them because their wrappers will have captured our wrapper.
 *
 * So it is important that entry points are unwrapped in the reverse
 * order that they were wrapped.
 *
 * @param {!Function} fn A function to unwrap.
 * @return {!Function} The unwrapped function, or {@code fn} if it was not
 *     a wrapped function created by this monitor.
 */
goog.debug.EntryPointMonitor.prototype.unwrap;


/**
 * An array of entry point callbacks.
 * @type {!Array.<function(!Function)>}
 * @private
 */
goog.debug.entryPointRegistry.refList_ = [];


/**
 * Monitors that should wrap all the entry points.
 * @type {!Array.<!goog.debug.EntryPointMonitor>}
 * @private
 */
goog.debug.entryPointRegistry.monitors_ = [];


/**
 * Whether goog.debug.entryPointRegistry.monitorAll has ever been called.
 * Checking this allows the compiler to optimize out the registrations.
 * @type {boolean}
 * @private
 */
goog.debug.entryPointRegistry.monitorsMayExist_ = false;


/**
 * Register an entry point with this module.
 *
 * The entry point will be instrumented when a monitor is passed to
 * goog.debug.entryPointRegistry.monitorAll. If this has already occurred, the
 * entry point is instrumented immediately.
 *
 * @param {function(!Function)} callback A callback function which is called
 *     with a transforming function to instrument the entry point. The callback
 *     is responsible for wrapping the relevant entry point with the
 *     transforming function.
 */
goog.debug.entryPointRegistry.register = function(callback) {
  // Don't use push(), so that this can be compiled out.
  goog.debug.entryPointRegistry.refList_[
      goog.debug.entryPointRegistry.refList_.length] = callback;
  // If no one calls monitorAll, this can be compiled out.
  if (goog.debug.entryPointRegistry.monitorsMayExist_) {
    var monitors = goog.debug.entryPointRegistry.monitors_;
    for (var i = 0; i < monitors.length; i++) {
      callback(goog.bind(monitors[i].wrap, monitors[i]));
    }
  }
};


/**
 * Configures a monitor to wrap all entry points.
 *
 * Entry points that have already been registered are immediately wrapped by
 * the monitor. When an entry point is registered in the future, it will also
 * be wrapped by the monitor when it is registered.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor An entry point monitor.
 */
goog.debug.entryPointRegistry.monitorAll = function(monitor) {
  goog.debug.entryPointRegistry.monitorsMayExist_ = true;
  var transformer = goog.bind(monitor.wrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  goog.debug.entryPointRegistry.monitors_.push(monitor);
};


/**
 * Try to unmonitor all the entry points that have already been registered. If
 * an entry point is registered in the future, it will not be wrapped by the
 * monitor when it is registered. Note that this may fail if the entry points
 * have additional wrapping.
 *
 * @param {!goog.debug.EntryPointMonitor} monitor The last monitor to wrap
 *     the entry points.
 * @throws {Error} If the monitor is not the most recently configured monitor.
 */
goog.debug.entryPointRegistry.unmonitorAllIfPossible = function(monitor) {
  var monitors = goog.debug.entryPointRegistry.monitors_;
  goog.asserts.assert(monitor == monitors[monitors.length - 1],
      'Only the most recent monitor can be unwrapped.');
  var transformer = goog.bind(monitor.unwrap, monitor);
  for (var i = 0; i < goog.debug.entryPointRegistry.refList_.length; i++) {
    goog.debug.entryPointRegistry.refList_[i](transformer);
  }
  monitors.length--;
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Event Types.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author mirkov@google.com (Mirko Visontai)
 */


goog.provide('goog.events.EventType');

goog.require('goog.userAgent');


/**
 * Returns a prefixed event name for the current browser.
 * @param {string} eventName The name of the event.
 * @return {string} The prefixed event name.
 * @suppress {missingRequire|missingProvide}
 * @private
 */
goog.events.getVendorPrefixedName_ = function(eventName) {
  return goog.userAgent.WEBKIT ? 'webkit' + eventName :
      (goog.userAgent.OPERA ? 'o' + eventName.toLowerCase() :
          eventName.toLowerCase());
};


/**
 * Constants for event names.
 * @enum {string}
 */
goog.events.EventType = {
  // Mouse events
  CLICK: 'click',
  RIGHTCLICK: 'rightclick',
  DBLCLICK: 'dblclick',
  MOUSEDOWN: 'mousedown',
  MOUSEUP: 'mouseup',
  MOUSEOVER: 'mouseover',
  MOUSEOUT: 'mouseout',
  MOUSEMOVE: 'mousemove',
  MOUSEENTER: 'mouseenter',
  MOUSELEAVE: 'mouseleave',
  // Select start is non-standard.
  // See http://msdn.microsoft.com/en-us/library/ie/ms536969(v=vs.85).aspx.
  SELECTSTART: 'selectstart', // IE, Safari, Chrome

  // Key events
  KEYPRESS: 'keypress',
  KEYDOWN: 'keydown',
  KEYUP: 'keyup',

  // Focus
  BLUR: 'blur',
  FOCUS: 'focus',
  DEACTIVATE: 'deactivate', // IE only
  // NOTE: The following two events are not stable in cross-browser usage.
  //     WebKit and Opera implement DOMFocusIn/Out.
  //     IE implements focusin/out.
  //     Gecko implements neither see bug at
  //     https://bugzilla.mozilla.org/show_bug.cgi?id=396927.
  // The DOM Events Level 3 Draft deprecates DOMFocusIn in favor of focusin:
  //     http://dev.w3.org/2006/webapi/DOM-Level-3-Events/html/DOM3-Events.html
  // You can use FOCUS in Capture phase until implementations converge.
  FOCUSIN: goog.userAgent.IE ? 'focusin' : 'DOMFocusIn',
  FOCUSOUT: goog.userAgent.IE ? 'focusout' : 'DOMFocusOut',

  // Forms
  CHANGE: 'change',
  SELECT: 'select',
  SUBMIT: 'submit',
  INPUT: 'input',
  PROPERTYCHANGE: 'propertychange', // IE only

  // Drag and drop
  DRAGSTART: 'dragstart',
  DRAG: 'drag',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DRAGLEAVE: 'dragleave',
  DROP: 'drop',
  DRAGEND: 'dragend',

  // WebKit touch events.
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  TOUCHCANCEL: 'touchcancel',

  // Misc
  BEFOREUNLOAD: 'beforeunload',
  CONSOLEMESSAGE: 'consolemessage',
  CONTEXTMENU: 'contextmenu',
  DOMCONTENTLOADED: 'DOMContentLoaded',
  ERROR: 'error',
  HELP: 'help',
  LOAD: 'load',
  LOSECAPTURE: 'losecapture',
  ORIENTATIONCHANGE: 'orientationchange',
  READYSTATECHANGE: 'readystatechange',
  RESIZE: 'resize',
  SCROLL: 'scroll',
  UNLOAD: 'unload',

  // HTML 5 History events
  // See http://www.w3.org/TR/html5/history.html#event-definitions
  HASHCHANGE: 'hashchange',
  PAGEHIDE: 'pagehide',
  PAGESHOW: 'pageshow',
  POPSTATE: 'popstate',

  // Copy and Paste
  // Support is limited. Make sure it works on your favorite browser
  // before using.
  // http://www.quirksmode.org/dom/events/cutcopypaste.html
  COPY: 'copy',
  PASTE: 'paste',
  CUT: 'cut',
  BEFORECOPY: 'beforecopy',
  BEFORECUT: 'beforecut',
  BEFOREPASTE: 'beforepaste',

  // HTML5 online/offline events.
  // http://www.w3.org/TR/offline-webapps/#related
  ONLINE: 'online',
  OFFLINE: 'offline',

  // HTML 5 worker events
  MESSAGE: 'message',
  CONNECT: 'connect',

  // CSS animation events.
  /** @suppress {missingRequire} */
  ANIMATIONSTART: goog.events.getVendorPrefixedName_('AnimationStart'),
  /** @suppress {missingRequire} */
  ANIMATIONEND: goog.events.getVendorPrefixedName_('AnimationEnd'),
  /** @suppress {missingRequire} */
  ANIMATIONITERATION: goog.events.getVendorPrefixedName_('AnimationIteration'),

  // CSS transition events. Based on the browser support described at:
  // https://developer.mozilla.org/en/css/css_transitions#Browser_compatibility
  /** @suppress {missingRequire} */
  TRANSITIONEND: goog.events.getVendorPrefixedName_('TransitionEnd'),

  // W3C Pointer Events
  // http://www.w3.org/TR/pointerevents/
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTERCANCEL: 'pointercancel',
  POINTERMOVE: 'pointermove',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  GOTPOINTERCAPTURE: 'gotpointercapture',
  LOSTPOINTERCAPTURE: 'lostpointercapture',

  // IE specific events.
  // See http://msdn.microsoft.com/en-us/library/ie/hh772103(v=vs.85).aspx
  // Note: these events will be supplanted in IE11.
  MSGESTURECHANGE: 'MSGestureChange',
  MSGESTUREEND: 'MSGestureEnd',
  MSGESTUREHOLD: 'MSGestureHold',
  MSGESTURESTART: 'MSGestureStart',
  MSGESTURETAP: 'MSGestureTap',
  MSGOTPOINTERCAPTURE: 'MSGotPointerCapture',
  MSINERTIASTART: 'MSInertiaStart',
  MSLOSTPOINTERCAPTURE: 'MSLostPointerCapture',
  MSPOINTERCANCEL: 'MSPointerCancel',
  MSPOINTERDOWN: 'MSPointerDown',
  MSPOINTERENTER: 'MSPointerEnter',
  MSPOINTERHOVER: 'MSPointerHover',
  MSPOINTERLEAVE: 'MSPointerLeave',
  MSPOINTERMOVE: 'MSPointerMove',
  MSPOINTEROUT: 'MSPointerOut',
  MSPOINTEROVER: 'MSPointerOver',
  MSPOINTERUP: 'MSPointerUp',

  // Native IMEs/input tools events.
  TEXTINPUT: 'textinput',
  COMPOSITIONSTART: 'compositionstart',
  COMPOSITIONUPDATE: 'compositionupdate',
  COMPOSITIONEND: 'compositionend',

  // Webview tag events
  // See http://developer.chrome.com/dev/apps/webview_tag.html
  EXIT: 'exit',
  LOADABORT: 'loadabort',
  LOADCOMMIT: 'loadcommit',
  LOADREDIRECT: 'loadredirect',
  LOADSTART: 'loadstart',
  LOADSTOP: 'loadstop',
  RESPONSIVE: 'responsive',
  SIZECHANGED: 'sizechanged',
  UNRESPONSIVE: 'unresponsive',

  // HTML5 Page Visibility API.  See details at
  // {@code goog.labs.dom.PageVisibilityMonitor}.
  VISIBILITYCHANGE: 'visibilitychange',

  // LocalStorage event.
  STORAGE: 'storage',

  // DOM Level 2 mutation events (deprecated).
  DOMSUBTREEMODIFIED: 'DOMSubtreeModified',
  DOMNODEINSERTED: 'DOMNodeInserted',
  DOMNODEREMOVED: 'DOMNodeRemoved',
  DOMNODEREMOVEDFROMDOCUMENT: 'DOMNodeRemovedFromDocument',
  DOMNODEINSERTEDINTODOCUMENT: 'DOMNodeInsertedIntoDocument',
  DOMATTRMODIFIED: 'DOMAttrModified',
  DOMCHARACTERDATAMODIFIED: 'DOMCharacterDataModified'
};
// Copyright 2009 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Useful compiler idioms.
 *
 */

goog.provide('goog.reflect');


/**
 * Syntax for object literal casts.
 * @see http://go/jscompiler-renaming
 * @see http://code.google.com/p/closure-compiler/wiki/
 *      ExperimentalTypeBasedPropertyRenaming
 *
 * Use this if you have an object literal whose keys need to have the same names
 * as the properties of some class even after they are renamed by the compiler.
 *
 * @param {!Function} type Type to cast to.
 * @param {Object} object Object literal to cast.
 * @return {Object} The object literal.
 */
goog.reflect.object = function(type, object) {
  return object;
};


/**
 * To assert to the compiler that an operation is needed when it would
 * otherwise be stripped. For example:
 * <code>
 *     // Force a layout
 *     goog.reflect.sinkValue(dialog.offsetHeight);
 * </code>
 * @type {!Function}
 */
goog.reflect.sinkValue = function(x) {
  goog.reflect.sinkValue[' '](x);
  return x;
};


/**
 * The compiler should optimize this function away iff no one ever uses
 * goog.reflect.sinkValue.
 */
goog.reflect.sinkValue[' '] = goog.nullFunction;


/**
 * Check if a property can be accessed without throwing an exception.
 * @param {Object} obj The owner of the property.
 * @param {string} prop The property name.
 * @return {boolean} Whether the property is accessible. Will also return true
 *     if obj is null.
 */
goog.reflect.canAccessProperty = function(obj, prop) {
  /** @preserveTry */
  try {
    goog.reflect.sinkValue(obj[prop]);
    return true;
  } catch (e) {}
  return false;
};
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A patched, standardized event object for browser events.
 *
 * <pre>
 * The patched event object contains the following members:
 * - type           {string}    Event type, e.g. 'click'
 * - timestamp      {Date}      A date object for when the event was fired
 * - target         {Object}    The element that actually triggered the event
 * - currentTarget  {Object}    The element the listener is attached to
 * - relatedTarget  {Object}    For mouseover and mouseout, the previous object
 * - offsetX        {number}    X-coordinate relative to target
 * - offsetY        {number}    Y-coordinate relative to target
 * - clientX        {number}    X-coordinate relative to viewport
 * - clientY        {number}    Y-coordinate relative to viewport
 * - screenX        {number}    X-coordinate relative to the edge of the screen
 * - screenY        {number}    Y-coordinate relative to the edge of the screen
 * - button         {number}    Mouse button. Use isButton() to test.
 * - keyCode        {number}    Key-code
 * - ctrlKey        {boolean}   Was ctrl key depressed
 * - altKey         {boolean}   Was alt key depressed
 * - shiftKey       {boolean}   Was shift key depressed
 * - metaKey        {boolean}   Was meta key depressed
 * - defaultPrevented {boolean} Whether the default action has been prevented
 * - state          {Object}    History state object
 *
 * NOTE: The keyCode member contains the raw browser keyCode. For normalized
 * key and character code use {@link goog.events.KeyHandler}.
 * </pre>
 *
 */

goog.provide('goog.events.BrowserEvent');
goog.provide('goog.events.BrowserEvent.MouseButton');

goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Event');
goog.require('goog.events.EventType');
goog.require('goog.reflect');
goog.require('goog.userAgent');



/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * The content of this object will not be initialized if no event object is
 * provided. If this is the case, init() needs to be invoked separately.
 * @param {Event=} opt_e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 * @constructor
 * @extends {goog.events.Event}
 */
goog.events.BrowserEvent = function(opt_e, opt_currentTarget) {
  goog.events.BrowserEvent.base(this, 'constructor', opt_e ? opt_e.type : '');

  /**
   * Target that fired the event.
   * @override
   * @type {Node}
   */
  this.target = null;

  /**
   * Node that had the listener attached.
   * @override
   * @type {Node|undefined}
   */
  this.currentTarget = null;

  /**
   * For mouseover and mouseout events, the related object for the event.
   * @type {Node}
   */
  this.relatedTarget = null;

  /**
   * X-coordinate relative to target.
   * @type {number}
   */
  this.offsetX = 0;

  /**
   * Y-coordinate relative to target.
   * @type {number}
   */
  this.offsetY = 0;

  /**
   * X-coordinate relative to the window.
   * @type {number}
   */
  this.clientX = 0;

  /**
   * Y-coordinate relative to the window.
   * @type {number}
   */
  this.clientY = 0;

  /**
   * X-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenX = 0;

  /**
   * Y-coordinate relative to the monitor.
   * @type {number}
   */
  this.screenY = 0;

  /**
   * Which mouse button was pressed.
   * @type {number}
   */
  this.button = 0;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.keyCode = 0;

  /**
   * Keycode of key press.
   * @type {number}
   */
  this.charCode = 0;

  /**
   * Whether control was pressed at time of event.
   * @type {boolean}
   */
  this.ctrlKey = false;

  /**
   * Whether alt was pressed at time of event.
   * @type {boolean}
   */
  this.altKey = false;

  /**
   * Whether shift was pressed at time of event.
   * @type {boolean}
   */
  this.shiftKey = false;

  /**
   * Whether the meta key was pressed at time of event.
   * @type {boolean}
   */
  this.metaKey = false;

  /**
   * History state object, only set for PopState events where it's a copy of the
   * state object provided to pushState or replaceState.
   * @type {Object}
   */
  this.state = null;

  /**
   * Whether the default platform modifier key was pressed at time of event.
   * (This is control for all platforms except Mac, where it's Meta.)
   * @type {boolean}
   */
  this.platformModifierKey = false;

  /**
   * The browser event object.
   * @private {Event}
   */
  this.event_ = null;

  if (opt_e) {
    this.init(opt_e, opt_currentTarget);
  }
};
goog.inherits(goog.events.BrowserEvent, goog.events.Event);


/**
 * Normalized button constants for the mouse.
 * @enum {number}
 */
goog.events.BrowserEvent.MouseButton = {
  LEFT: 0,
  MIDDLE: 1,
  RIGHT: 2
};


/**
 * Static data for mapping mouse buttons.
 * @type {!Array.<number>}
 */
goog.events.BrowserEvent.IEButtonMap = [
  1, // LEFT
  4, // MIDDLE
  2  // RIGHT
];


/**
 * Accepts a browser event object and creates a patched, cross browser event
 * object.
 * @param {Event} e Browser event object.
 * @param {EventTarget=} opt_currentTarget Current target for event.
 */
goog.events.BrowserEvent.prototype.init = function(e, opt_currentTarget) {
  var type = this.type = e.type;

  // TODO(nicksantos): Change this.target to type EventTarget.
  this.target = /** @type {Node} */ (e.target) || e.srcElement;

  // TODO(nicksantos): Change this.currentTarget to type EventTarget.
  this.currentTarget = /** @type {Node} */ (opt_currentTarget);

  var relatedTarget = /** @type {Node} */ (e.relatedTarget);
  if (relatedTarget) {
    // There's a bug in FireFox where sometimes, relatedTarget will be a
    // chrome element, and accessing any property of it will get a permission
    // denied exception. See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=497780
    if (goog.userAgent.GECKO) {
      if (!goog.reflect.canAccessProperty(relatedTarget, 'nodeName')) {
        relatedTarget = null;
      }
    }
    // TODO(arv): Use goog.events.EventType when it has been refactored into its
    // own file.
  } else if (type == goog.events.EventType.MOUSEOVER) {
    relatedTarget = e.fromElement;
  } else if (type == goog.events.EventType.MOUSEOUT) {
    relatedTarget = e.toElement;
  }

  this.relatedTarget = relatedTarget;

  // Webkit emits a lame warning whenever layerX/layerY is accessed.
  // http://code.google.com/p/chromium/issues/detail?id=101733
  this.offsetX = (goog.userAgent.WEBKIT || e.offsetX !== undefined) ?
      e.offsetX : e.layerX;
  this.offsetY = (goog.userAgent.WEBKIT || e.offsetY !== undefined) ?
      e.offsetY : e.layerY;

  this.clientX = e.clientX !== undefined ? e.clientX : e.pageX;
  this.clientY = e.clientY !== undefined ? e.clientY : e.pageY;
  this.screenX = e.screenX || 0;
  this.screenY = e.screenY || 0;

  this.button = e.button;

  this.keyCode = e.keyCode || 0;
  this.charCode = e.charCode || (type == 'keypress' ? e.keyCode : 0);
  this.ctrlKey = e.ctrlKey;
  this.altKey = e.altKey;
  this.shiftKey = e.shiftKey;
  this.metaKey = e.metaKey;
  this.platformModifierKey = goog.userAgent.MAC ? e.metaKey : e.ctrlKey;
  this.state = e.state;
  this.event_ = e;
  if (e.defaultPrevented) {
    this.preventDefault();
  }
};


/**
 * Tests to see which button was pressed during the event. This is really only
 * useful in IE and Gecko browsers. And in IE, it's only useful for
 * mousedown/mouseup events, because click only fires for the left mouse button.
 *
 * Safari 2 only reports the left button being clicked, and uses the value '1'
 * instead of 0. Opera only reports a mousedown event for the middle button, and
 * no mouse events for the right button. Opera has default behavior for left and
 * middle click that can only be overridden via a configuration setting.
 *
 * There's a nice table of this mess at http://www.unixpapa.com/js/mouse.html.
 *
 * @param {goog.events.BrowserEvent.MouseButton} button The button
 *     to test for.
 * @return {boolean} True if button was pressed.
 */
goog.events.BrowserEvent.prototype.isButton = function(button) {
  if (!goog.events.BrowserFeature.HAS_W3C_BUTTON) {
    if (this.type == 'click') {
      return button == goog.events.BrowserEvent.MouseButton.LEFT;
    } else {
      return !!(this.event_.button &
          goog.events.BrowserEvent.IEButtonMap[button]);
    }
  } else {
    return this.event_.button == button;
  }
};


/**
 * Whether this has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @return {boolean} The result.
 */
goog.events.BrowserEvent.prototype.isMouseActionButton = function() {
  // Webkit does not ctrl+click to be a right-click, so we
  // normalize it to behave like Gecko and Opera.
  return this.isButton(goog.events.BrowserEvent.MouseButton.LEFT) &&
      !(goog.userAgent.WEBKIT && goog.userAgent.MAC && this.ctrlKey);
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.stopPropagation = function() {
  goog.events.BrowserEvent.superClass_.stopPropagation.call(this);
  if (this.event_.stopPropagation) {
    this.event_.stopPropagation();
  } else {
    this.event_.cancelBubble = true;
  }
};


/**
 * @override
 */
goog.events.BrowserEvent.prototype.preventDefault = function() {
  goog.events.BrowserEvent.superClass_.preventDefault.call(this);
  var be = this.event_;
  if (!be.preventDefault) {
    be.returnValue = false;
    if (goog.events.BrowserFeature.SET_KEY_CODE_TO_PREVENT_DEFAULT) {
      /** @preserveTry */
      try {
        // Most keys can be prevented using returnValue. Some special keys
        // require setting the keyCode to -1 as well:
        //
        // In IE7:
        // F3, F5, F10, F11, Ctrl+P, Crtl+O, Ctrl+F (these are taken from IE6)
        //
        // In IE8:
        // Ctrl+P, Crtl+O, Ctrl+F (F1-F12 cannot be stopped through the event)
        //
        // We therefore do this for all function keys as well as when Ctrl key
        // is pressed.
        var VK_F1 = 112;
        var VK_F12 = 123;
        if (be.ctrlKey || be.keyCode >= VK_F1 && be.keyCode <= VK_F12) {
          be.keyCode = -1;
        }
      } catch (ex) {
        // IE throws an 'access denied' exception when trying to change
        // keyCode in some situations (e.g. srcElement is input[type=file],
        // or srcElement is an anchor tag rewritten by parent's innerHTML).
        // Do nothing in this case.
      }
    }
  } else {
    be.preventDefault();
  }
};


/**
 * @return {Event} The underlying browser event object.
 */
goog.events.BrowserEvent.prototype.getBrowserEvent = function() {
  return this.event_;
};


/** @override */
goog.events.BrowserEvent.prototype.disposeInternal = function() {
};
// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview An event manager for both native browser event
 * targets and custom JavaScript event targets
 * ({@code goog.events.Listenable}). This provides an abstraction
 * over browsers' event systems.
 *
 * It also provides a simulation of W3C event model's capture phase in
 * Internet Explorer (IE 8 and below). Caveat: the simulation does not
 * interact well with listeners registered directly on the elements
 * (bypassing goog.events) or even with listeners registered via
 * goog.events in a separate JS binary. In these cases, we provide
 * no ordering guarantees.
 *
 * The listeners will receive a "patched" event object. Such event object
 * contains normalized values for certain event properties that differs in
 * different browsers.
 *
 * Example usage:
 * <pre>
 * goog.events.listen(myNode, 'click', function(e) { alert('woo') });
 * goog.events.listen(myNode, 'mouseover', mouseHandler, true);
 * goog.events.unlisten(myNode, 'mouseover', mouseHandler, true);
 * goog.events.removeAll(myNode);
 * </pre>
 *
 *                                            in IE and event object patching]
 *
 * @see ../demos/events.html
 * @see ../demos/event-propagation.html
 * @see ../demos/stopevent.html
 */

// IMPLEMENTATION NOTES:
// goog.events stores an auxiliary data structure on each EventTarget
// source being listened on. This allows us to take advantage of GC,
// having the data structure GC'd when the EventTarget is GC'd. This
// GC behavior is equivalent to using W3C DOM Events directly.

goog.provide('goog.events');
goog.provide('goog.events.CaptureSimulationMode');
goog.provide('goog.events.Key');
goog.provide('goog.events.ListenableType');

goog.require('goog.asserts');
goog.require('goog.debug.entryPointRegistry');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.BrowserFeature');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');


/**
 * @typedef {number|goog.events.ListenableKey}
 */
goog.events.Key;


/**
 * @typedef {EventTarget|goog.events.Listenable}
 */
goog.events.ListenableType;


/**
 * Container for storing event listeners and their proxies
 *
 * TODO(user): Remove this when all external usage is
 * purged. goog.events no longer use goog.events.listeners_ for
 * anything meaningful.
 *
 * @private {!Object.<goog.events.ListenableKey>}
 */
goog.events.listeners_ = {};


/**
 * Property name on a native event target for the listener map
 * associated with the event target.
 * @const
 * @private
 */
goog.events.LISTENER_MAP_PROP_ = 'closure_lm_' + ((Math.random() * 1e6) | 0);


/**
 * String used to prepend to IE event types.
 * @const
 * @private
 */
goog.events.onString_ = 'on';


/**
 * Map of computed "on<eventname>" strings for IE event types. Caching
 * this removes an extra object allocation in goog.events.listen which
 * improves IE6 performance.
 * @const
 * @dict
 * @private
 */
goog.events.onStringMap_ = {};


/**
 * @enum {number} Different capture simulation mode for IE8-.
 */
goog.events.CaptureSimulationMode = {
  /**
   * Does not perform capture simulation. Will asserts in IE8- when you
   * add capture listeners.
   */
  OFF_AND_FAIL: 0,

  /**
   * Does not perform capture simulation, silently ignore capture
   * listeners.
   */
  OFF_AND_SILENT: 1,

  /**
   * Performs capture simulation.
   */
  ON: 2
};


/**
 * @define {number} The capture simulation mode for IE8-. By default,
 *     this is ON.
 */
goog.define('goog.events.CAPTURE_SIMULATION_MODE', 2);


/**
 * Estimated count of total native listeners.
 * @private {number}
 */
goog.events.listenerCountEstimate_ = 0;


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. A listener can only be added once
 * to an object and if it is added again the key for the listener is
 * returned. Note that if the existing listener is a one-off listener
 * (registered via listenOnce), it will no longer be a one-off
 * listener after a call to listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array.<string>|
 *     !goog.events.EventId.<EVENTOBJ>|!Array.<!goog.events.EventId.<EVENTOBJ>>}
 *     type Event type or array of event types.
 * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
 *     listener Callback method, or an object with a handleEvent function.
 *     WARNING: passing an Object is now softly deprecated.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T,EVENTOBJ
 */
goog.events.listen = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listen(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.listen(
        /** @type {string|!goog.events.EventId} */ (type),
        listener, opt_capt, opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {EventTarget} */ (src),
        /** @type {string|!goog.events.EventId} */ (type),
        listener, /* callOnce */ false, opt_capt, opt_handler);
  }
};


/**
 * Adds an event listener for a specific event on a native event
 * target. A listener can only be added once to an object and if it
 * is added again the key for the listener is returned.
 *
 * Note that a one-off listener will not change an existing listener,
 * if any. On the other hand a normal listener will change existing
 * one-off listener to become a normal listener.
 *
 * @param {EventTarget} src The node to listen to events on.
 * @param {string|!goog.events.EventId} type Event type.
 * @param {!Function} listener Callback function.
 * @param {boolean} callOnce Whether the listener is a one-off
 *     listener or otherwise.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} Unique key for the listener.
 * @private
 */
goog.events.listen_ = function(
    src, type, listener, callOnce, opt_capt, opt_handler) {
  if (!type) {
    throw Error('Invalid event type');
  }

  var capture = !!opt_capt;
  if (capture && !goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
    if (goog.events.CAPTURE_SIMULATION_MODE ==
        goog.events.CaptureSimulationMode.OFF_AND_FAIL) {
      goog.asserts.fail('Can not register capture listener in IE8-.');
      return null;
    } else if (goog.events.CAPTURE_SIMULATION_MODE ==
        goog.events.CaptureSimulationMode.OFF_AND_SILENT) {
      return null;
    }
  }

  var listenerMap = goog.events.getListenerMap_(src);
  if (!listenerMap) {
    src[goog.events.LISTENER_MAP_PROP_] = listenerMap =
        new goog.events.ListenerMap(src);
  }

  var listenerObj = listenerMap.add(
      type, listener, callOnce, opt_capt, opt_handler);

  // If the listenerObj already has a proxy, it has been set up
  // previously. We simply return.
  if (listenerObj.proxy) {
    return listenerObj;
  }

  var proxy = goog.events.getProxy();
  listenerObj.proxy = proxy;

  proxy.src = src;
  proxy.listener = listenerObj;

  // Attach the proxy through the browser's API
  if (src.addEventListener) {
    src.addEventListener(type.toString(), proxy, capture);
  } else {
    // The else above used to be else if (src.attachEvent) and then there was
    // another else statement that threw an exception warning the developer
    // they made a mistake. This resulted in an extra object allocation in IE6
    // due to a wrapper object that had to be implemented around the element
    // and so was removed.
    src.attachEvent(goog.events.getOnString_(type.toString()), proxy);
  }

  goog.events.listenerCountEstimate_++;
  return listenerObj;
};


/**
 * Helper function for returning a proxy function.
 * @return {!Function} A new or reused function object.
 */
goog.events.getProxy = function() {
  var proxyCallbackFunction = goog.events.handleBrowserEvent_;
  // Use a local var f to prevent one allocation.
  var f = goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT ?
      function(eventObject) {
        return proxyCallbackFunction.call(f.src, f.listener, eventObject);
      } :
      function(eventObject) {
        var v = proxyCallbackFunction.call(f.src, f.listener, eventObject);
        // NOTE(user): In IE, we hack in a capture phase. However, if
        // there is inline event handler which tries to prevent default (for
        // example <a href="..." onclick="return false">...</a>) in a
        // descendant element, the prevent default will be overridden
        // by this listener if this listener were to return true. Hence, we
        // return undefined.
        if (!v) return v;
      };
  return f;
};


/**
 * Adds an event listener for a specific event on a native event
 * target (such as a DOM element) or an object that has implemented
 * {@link goog.events.Listenable}. After the event has fired the event
 * listener is removed from the target.
 *
 * If an existing listener already exists, listenOnce will do
 * nothing. In particular, if the listener was previously registered
 * via listen(), listenOnce() will not turn the listener into a
 * one-off listener. Similarly, if there is already an existing
 * one-off listener, listenOnce does not modify the listeners (it is
 * still a once listener).
 *
 * @param {EventTarget|goog.events.Listenable} src The node to listen
 *     to events on.
 * @param {string|Array.<string>|
 *     !goog.events.EventId.<EVENTOBJ>|!Array.<!goog.events.EventId.<EVENTOBJ>>}
 *     type Event type or array of event types.
 * @param {function(this:T, EVENTOBJ):?|{handleEvent:function(?):?}|null}
 *     listener Callback method.
 * @param {boolean=} opt_capt Fire in capture phase?.
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.Key} Unique key for the listener.
 * @template T,EVENTOBJ
 */
goog.events.listenOnce = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.listenOnce(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.listenOnce(
        /** @type {string|!goog.events.EventId} */ (type),
        listener, opt_capt, opt_handler);
  } else {
    return goog.events.listen_(
        /** @type {EventTarget} */ (src),
        /** @type {string|!goog.events.EventId} */ (type),
        listener, /* callOnce */ true, opt_capt, opt_handler);
  }
};


/**
 * Adds an event listener with a specific event wrapper on a DOM Node or an
 * object that has implemented {@link goog.events.Listenable}. A listener can
 * only be added once to an object.
 *
 * @param {EventTarget|goog.events.Listenable} src The target to
 *     listen to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(this:T, ?):?|{handleEvent:function(?):?}|null} listener
 *     Callback method, or an object with a handleEvent function.
 * @param {boolean=} opt_capt Whether to fire in capture phase (defaults to
 *     false).
 * @param {T=} opt_handler Element in whose scope to call the listener.
 * @template T
 */
goog.events.listenWithWrapper = function(src, wrapper, listener, opt_capt,
    opt_handler) {
  wrapper.listen(src, listener, opt_capt, opt_handler);
};


/**
 * Removes an event listener which was added with listen().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {string|Array.<string>|
 *     !goog.events.EventId.<EVENTOBJ>|!Array.<!goog.events.EventId.<EVENTOBJ>>}
 *     type Event type or array of event types to unlisten to.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {?boolean} indicating whether the listener was there to remove.
 * @template EVENTOBJ
 */
goog.events.unlisten = function(src, type, listener, opt_capt, opt_handler) {
  if (goog.isArray(type)) {
    for (var i = 0; i < type.length; i++) {
      goog.events.unlisten(src, type[i], listener, opt_capt, opt_handler);
    }
    return null;
  }

  listener = goog.events.wrapListener(listener);
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.unlisten(
        /** @type {string|!goog.events.EventId} */ (type),
        listener, opt_capt, opt_handler);
  }

  if (!src) {
    // TODO(user): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return false;
  }

  var capture = !!opt_capt;
  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  if (listenerMap) {
    var listenerObj = listenerMap.getListener(
        /** @type {string|!goog.events.EventId} */ (type),
        listener, capture, opt_handler);
    if (listenerObj) {
      return goog.events.unlistenByKey(listenerObj);
    }
  }

  return false;
};


/**
 * Removes an event listener which was added with listen() by the key
 * returned by listen().
 *
 * @param {goog.events.Key} key The key returned by listen() for this
 *     event listener.
 * @return {boolean} indicating whether the listener was there to remove.
 */
goog.events.unlistenByKey = function(key) {
  // TODO(user): Remove this check when tests that rely on this
  // are fixed.
  if (goog.isNumber(key)) {
    return false;
  }

  var listener = /** @type {goog.events.ListenableKey} */ (key);
  if (!listener || listener.removed) {
    return false;
  }

  var src = listener.src;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.unlistenByKey(listener);
  }

  var type = listener.type;
  var proxy = listener.proxy;
  if (src.removeEventListener) {
    src.removeEventListener(type, proxy, listener.capture);
  } else if (src.detachEvent) {
    src.detachEvent(goog.events.getOnString_(type), proxy);
  }
  goog.events.listenerCountEstimate_--;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  // TODO(user): Try to remove this conditional and execute the
  // first branch always. This should be safe.
  if (listenerMap) {
    listenerMap.removeByKey(listener);
    if (listenerMap.getTypeCount() == 0) {
      // Null the src, just because this is simple to do (and useful
      // for IE <= 7).
      listenerMap.src = null;
      // We don't use delete here because IE does not allow delete
      // on a window object.
      src[goog.events.LISTENER_MAP_PROP_] = null;
    }
  } else {
    listener.markAsRemoved();
  }

  return true;
};


/**
 * Removes an event listener which was added with listenWithWrapper().
 *
 * @param {EventTarget|goog.events.Listenable} src The target to stop
 *     listening to events on.
 * @param {goog.events.EventWrapper} wrapper Event wrapper to use.
 * @param {function(?):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to remove.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase of the
 *     event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 */
goog.events.unlistenWithWrapper = function(src, wrapper, listener, opt_capt,
    opt_handler) {
  wrapper.unlisten(src, listener, opt_capt, opt_handler);
};


/**
 * Removes all listeners from an object. You can also optionally
 * remove listeners of a particular type.
 *
 * @param {Object=} opt_obj Object to remove listeners from. Not
 *     specifying opt_obj is now DEPRECATED (it used to remove all
 *     registered listeners).
 * @param {string|!goog.events.EventId=} opt_type Type of event to remove.
 *     Default is all types.
 * @return {number} Number of listeners removed.
 */
goog.events.removeAll = function(opt_obj, opt_type) {
  // TODO(user): Change the type of opt_obj from Object= to
  // !EventTarget|goog.events.Listenable). And replace this with an
  // assertion.
  if (!opt_obj) {
    return 0;
  }

  if (goog.events.Listenable.isImplementedBy(opt_obj)) {
    return opt_obj.removeAllListeners(opt_type);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (opt_obj));
  if (!listenerMap) {
    return 0;
  }

  var count = 0;
  var typeStr = opt_type && opt_type.toString();
  for (var type in listenerMap.listeners) {
    if (!typeStr || type == typeStr) {
      // Clone so that we don't need to worry about unlistenByKey
      // changing the content of the ListenerMap.
      var listeners = listenerMap.listeners[type].concat();
      for (var i = 0; i < listeners.length; ++i) {
        if (goog.events.unlistenByKey(listeners[i])) {
          ++count;
        }
      }
    }
  }
  return count;
};


/**
 * Removes all native listeners registered via goog.events. Native
 * listeners are listeners on native browser objects (such as DOM
 * elements). In particular, goog.events.Listenable and
 * goog.events.EventTarget listeners will NOT be removed.
 * @return {number} Number of listeners removed.
 * @deprecated This doesn't do anything, now that Closure no longer
 * stores a central listener registry.
 */
goog.events.removeAllNativeListeners = function() {
  goog.events.listenerCountEstimate_ = 0;
  return 0;
};


/**
 * Gets the listeners for a given object, type and capture phase.
 *
 * @param {Object} obj Object to get listeners for.
 * @param {string|!goog.events.EventId} type Event type.
 * @param {boolean} capture Capture phase?.
 * @return {Array.<goog.events.Listener>} Array of listener objects.
 */
goog.events.getListeners = function(obj, type, capture) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.getListeners(type, capture);
  } else {
    if (!obj) {
      // TODO(user): We should tighten the API to accept
      // !EventTarget|goog.events.Listenable, and add an assertion here.
      return [];
    }

    var listenerMap = goog.events.getListenerMap_(
        /** @type {EventTarget} */ (obj));
    return listenerMap ? listenerMap.getListeners(type, capture) : [];
  }
};


/**
 * Gets the goog.events.Listener for the event or null if no such listener is
 * in use.
 *
 * @param {EventTarget|goog.events.Listenable} src The target from
 *     which to get listeners.
 * @param {?string|!goog.events.EventId.<EVENTOBJ>} type The type of the event.
 * @param {function(EVENTOBJ):?|{handleEvent:function(?):?}|null} listener The
 *     listener function to get.
 * @param {boolean=} opt_capt In DOM-compliant browsers, this determines
 *                            whether the listener is fired during the
 *                            capture or bubble phase of the event.
 * @param {Object=} opt_handler Element in whose scope to call the listener.
 * @return {goog.events.ListenableKey} the found listener or null if not found.
 * @template EVENTOBJ
 */
goog.events.getListener = function(src, type, listener, opt_capt, opt_handler) {
  // TODO(user): Change type from ?string to string, or add assertion.
  type = /** @type {string} */ (type);
  listener = goog.events.wrapListener(listener);
  var capture = !!opt_capt;
  if (goog.events.Listenable.isImplementedBy(src)) {
    return src.getListener(type, listener, capture, opt_handler);
  }

  if (!src) {
    // TODO(user): We should tighten the API to only accept
    // non-null objects, or add an assertion here.
    return null;
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (src));
  if (listenerMap) {
    return listenerMap.getListener(type, listener, capture, opt_handler);
  }
  return null;
};


/**
 * Returns whether an event target has any active listeners matching the
 * specified signature. If either the type or capture parameters are
 * unspecified, the function will match on the remaining criteria.
 *
 * @param {EventTarget|goog.events.Listenable} obj Target to get
 *     listeners for.
 * @param {string|!goog.events.EventId=} opt_type Event type.
 * @param {boolean=} opt_capture Whether to check for capture or bubble-phase
 *     listeners.
 * @return {boolean} Whether an event target has one or more listeners matching
 *     the requested type and/or capture phase.
 */
goog.events.hasListener = function(obj, opt_type, opt_capture) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.hasListener(opt_type, opt_capture);
  }

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (obj));
  return !!listenerMap && listenerMap.hasListener(opt_type, opt_capture);
};


/**
 * Provides a nice string showing the normalized event objects public members
 * @param {Object} e Event Object.
 * @return {string} String of the public members of the normalized event object.
 */
goog.events.expose = function(e) {
  var str = [];
  for (var key in e) {
    if (e[key] && e[key].id) {
      str.push(key + ' = ' + e[key] + ' (' + e[key].id + ')');
    } else {
      str.push(key + ' = ' + e[key]);
    }
  }
  return str.join('\n');
};


/**
 * Returns a string with on prepended to the specified type. This is used for IE
 * which expects "on" to be prepended. This function caches the string in order
 * to avoid extra allocations in steady state.
 * @param {string} type Event type.
 * @return {string} The type string with 'on' prepended.
 * @private
 */
goog.events.getOnString_ = function(type) {
  if (type in goog.events.onStringMap_) {
    return goog.events.onStringMap_[type];
  }
  return goog.events.onStringMap_[type] = goog.events.onString_ + type;
};


/**
 * Fires an object's listeners of a particular type and phase
 *
 * @param {Object} obj Object whose listeners to call.
 * @param {string|!goog.events.EventId} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 */
goog.events.fireListeners = function(obj, type, capture, eventObject) {
  if (goog.events.Listenable.isImplementedBy(obj)) {
    return obj.fireListeners(type, capture, eventObject);
  }

  return goog.events.fireListeners_(obj, type, capture, eventObject);
};


/**
 * Fires an object's listeners of a particular type and phase.
 * @param {Object} obj Object whose listeners to call.
 * @param {string|!goog.events.EventId} type Event type.
 * @param {boolean} capture Which event phase.
 * @param {Object} eventObject Event object to be passed to listener.
 * @return {boolean} True if all listeners returned true else false.
 * @private
 */
goog.events.fireListeners_ = function(obj, type, capture, eventObject) {
  var retval = 1;

  var listenerMap = goog.events.getListenerMap_(
      /** @type {EventTarget} */ (obj));
  if (listenerMap) {
    // TODO(user): Original code avoids array creation when there
    // is no listener, so we do the same. If this optimization turns
    // out to be not required, we can replace this with
    // listenerMap.getListeners(type, capture) instead, which is simpler.
    var listenerArray = listenerMap.listeners[type.toString()];
    if (listenerArray) {
      listenerArray = listenerArray.concat();
      for (var i = 0; i < listenerArray.length; i++) {
        var listener = listenerArray[i];
        // We might not have a listener if the listener was removed.
        if (listener && listener.capture == capture && !listener.removed) {
          retval &=
              goog.events.fireListener(listener, eventObject) !== false;
        }
      }
    }
  }
  return Boolean(retval);
};


/**
 * Fires a listener with a set of arguments
 *
 * @param {goog.events.Listener} listener The listener object to call.
 * @param {Object} eventObject The event object to pass to the listener.
 * @return {boolean} Result of listener.
 */
goog.events.fireListener = function(listener, eventObject) {
  var listenerFn = listener.listener;
  var listenerHandler = listener.handler || listener.src;

  if (listener.callOnce) {
    goog.events.unlistenByKey(listener);
  }
  return listenerFn.call(listenerHandler, eventObject);
};


/**
 * Gets the total number of listeners currently in the system.
 * @return {number} Number of listeners.
 * @deprecated This returns estimated count, now that Closure no longer
 * stores a central listener registry. We still return an estimation
 * to keep existing listener-related tests passing. In the near future,
 * this function will be removed.
 */
goog.events.getTotalListenerCount = function() {
  return goog.events.listenerCountEstimate_;
};


/**
 * Dispatches an event (or event like object) and calls all listeners
 * listening for events of this type. The type of the event is decided by the
 * type property on the event object.
 *
 * If any of the listeners returns false OR calls preventDefault then this
 * function will return false.  If one of the capture listeners calls
 * stopPropagation, then the bubble listeners won't fire.
 *
 * @param {goog.events.Listenable} src The event target.
 * @param {goog.events.EventLike} e Event object.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the handlers returns false) this will also return false.
 *     If there are no handlers, or if all handlers return true, this returns
 *     true.
 */
goog.events.dispatchEvent = function(src, e) {
  goog.asserts.assert(
      goog.events.Listenable.isImplementedBy(src),
      'Can not use goog.events.dispatchEvent with ' +
      'non-goog.events.Listenable instance.');
  return src.dispatchEvent(e);
};


/**
 * Installs exception protection for the browser event entry point using the
 * given error handler.
 *
 * @param {goog.debug.ErrorHandler} errorHandler Error handler with which to
 *     protect the entry point.
 */
goog.events.protectBrowserEventEntryPoint = function(errorHandler) {
  goog.events.handleBrowserEvent_ = errorHandler.protectEntryPoint(
      goog.events.handleBrowserEvent_);
};


/**
 * Handles an event and dispatches it to the correct listeners. This
 * function is a proxy for the real listener the user specified.
 *
 * @param {goog.events.Listener} listener The listener object.
 * @param {Event=} opt_evt Optional event object that gets passed in via the
 *     native event handlers.
 * @return {boolean} Result of the event handler.
 * @this {EventTarget} The object or Element that fired the event.
 * @private
 */
goog.events.handleBrowserEvent_ = function(listener, opt_evt) {
  if (listener.removed) {
    return true;
  }

  // Synthesize event propagation if the browser does not support W3C
  // event model.
  if (!goog.events.BrowserFeature.HAS_W3C_EVENT_SUPPORT) {
    var ieEvent = opt_evt ||
        /** @type {Event} */ (goog.getObjectByName('window.event'));
    var evt = new goog.events.BrowserEvent(ieEvent, this);
    var retval = true;

    if (goog.events.CAPTURE_SIMULATION_MODE ==
            goog.events.CaptureSimulationMode.ON) {
      // If we have not marked this event yet, we should perform capture
      // simulation.
      if (!goog.events.isMarkedIeEvent_(ieEvent)) {
        goog.events.markIeEvent_(ieEvent);

        var ancestors = [];
        for (var parent = evt.currentTarget; parent;
             parent = parent.parentNode) {
          ancestors.push(parent);
        }

        // Fire capture listeners.
        var type = listener.type;
        for (var i = ancestors.length - 1; !evt.propagationStopped_ && i >= 0;
             i--) {
          evt.currentTarget = ancestors[i];
          retval &= goog.events.fireListeners_(ancestors[i], type, true, evt);
        }

        // Fire bubble listeners.
        //
        // We can technically rely on IE to perform bubble event
        // propagation. However, it turns out that IE fires events in
        // opposite order of attachEvent registration, which broke
        // some code and tests that rely on the order. (While W3C DOM
        // Level 2 Events TR leaves the event ordering unspecified,
        // modern browsers and W3C DOM Level 3 Events Working Draft
        // actually specify the order as the registration order.)
        for (var i = 0; !evt.propagationStopped_ && i < ancestors.length; i++) {
          evt.currentTarget = ancestors[i];
          retval &= goog.events.fireListeners_(ancestors[i], type, false, evt);
        }
      }
    } else {
      retval = goog.events.fireListener(listener, evt);
    }
    return retval;
  }

  // Otherwise, simply fire the listener.
  return goog.events.fireListener(
      listener, new goog.events.BrowserEvent(opt_evt, this));
};


/**
 * This is used to mark the IE event object so we do not do the Closure pass
 * twice for a bubbling event.
 * @param {Event} e The IE browser event.
 * @private
 */
goog.events.markIeEvent_ = function(e) {
  // Only the keyCode and the returnValue can be changed. We use keyCode for
  // non keyboard events.
  // event.returnValue is a bit more tricky. It is undefined by default. A
  // boolean false prevents the default action. In a window.onbeforeunload and
  // the returnValue is non undefined it will be alerted. However, we will only
  // modify the returnValue for keyboard events. We can get a problem if non
  // closure events sets the keyCode or the returnValue

  var useReturnValue = false;

  if (e.keyCode == 0) {
    // We cannot change the keyCode in case that srcElement is input[type=file].
    // We could test that that is the case but that would allocate 3 objects.
    // If we use try/catch we will only allocate extra objects in the case of a
    // failure.
    /** @preserveTry */
    try {
      e.keyCode = -1;
      return;
    } catch (ex) {
      useReturnValue = true;
    }
  }

  if (useReturnValue ||
      /** @type {boolean|undefined} */ (e.returnValue) == undefined) {
    e.returnValue = true;
  }
};


/**
 * This is used to check if an IE event has already been handled by the Closure
 * system so we do not do the Closure pass twice for a bubbling event.
 * @param {Event} e  The IE browser event.
 * @return {boolean} True if the event object has been marked.
 * @private
 */
goog.events.isMarkedIeEvent_ = function(e) {
  return e.keyCode < 0 || e.returnValue != undefined;
};


/**
 * Counter to create unique event ids.
 * @private {number}
 */
goog.events.uniqueIdCounter_ = 0;


/**
 * Creates a unique event id.
 *
 * @param {string} identifier The identifier.
 * @return {string} A unique identifier.
 * @idGenerator
 */
goog.events.getUniqueId = function(identifier) {
  return identifier + '_' + goog.events.uniqueIdCounter_++;
};


/**
 * @param {EventTarget} src The source object.
 * @return {goog.events.ListenerMap} A listener map for the given
 *     source object, or null if none exists.
 * @private
 */
goog.events.getListenerMap_ = function(src) {
  var listenerMap = src[goog.events.LISTENER_MAP_PROP_];
  // IE serializes the property as well (e.g. when serializing outer
  // HTML). So we must check that the value is of the correct type.
  return listenerMap instanceof goog.events.ListenerMap ? listenerMap : null;
};


/**
 * Expando property for listener function wrapper for Object with
 * handleEvent.
 * @const
 * @private
 */
goog.events.LISTENER_WRAPPER_PROP_ = '__closure_events_fn_' +
    ((Math.random() * 1e9) >>> 0);


/**
 * @param {Object|Function} listener The listener function or an
 *     object that contains handleEvent method.
 * @return {!Function} Either the original function or a function that
 *     calls obj.handleEvent. If the same listener is passed to this
 *     function more than once, the same function is guaranteed to be
 *     returned.
 */
goog.events.wrapListener = function(listener) {
  goog.asserts.assert(listener, 'Listener can not be null.');

  if (goog.isFunction(listener)) {
    return listener;
  }

  goog.asserts.assert(
      listener.handleEvent, 'An object listener must have handleEvent method.');
  return listener[goog.events.LISTENER_WRAPPER_PROP_] ||
      (listener[goog.events.LISTENER_WRAPPER_PROP_] = function(e) {
        return listener.handleEvent(e);
      });
};


// Register the browser event handler as an entry point, so that
// it can be monitored for exception handling, etc.
goog.debug.entryPointRegistry.register(
    /**
     * @param {function(!Function): !Function} transformer The transforming
     *     function.
     */
    function(transformer) {
      goog.events.handleBrowserEvent_ = transformer(
          goog.events.handleBrowserEvent_);
    });
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.core.Event');
goog.provide('e.Event');

goog.require('goog.events.Event');

/**
 * @constructor
 * @param {string} type of event
 * @param {Object} payload
 * @extends {goog.events.Event}
 */
lgb.core.Event = function(type, payload) {

  goog.events.Event.call(this, type);

  /**
   * The event payload
   * @type {Object}
   */
  this.payload = payload;
  
};
goog.inherits(lgb.core.Event, goog.events.Event);

e.Event = function() {};


e.Resize = 'e.Resize';
e.LayoutChange = 'e.LayoutChange';
e.ViewInitialized = 'e.ViewInitialized';
e.DataModelInitialized = 'e.DataModelInitialized';
e.RenderNotify = 'e.RenderNotify';
e.MouseClick = 'e.MouseClick';
e.MouseOut = 'e.MouseOut';
e.MouseOver = 'e.MouseOver';
e.Select = 'e.Select';
e.Activate = 'e.Activate';


e.OpenDropDown = 'e.OpenDropDown';
e.CloseDropDown = 'e.CloseDropDown';

e.AddToWorldRequest = 'e.AddToWorldRequest';

e.ViewClosed = 'e.ViewClosed';
e.WindowResize = 'e.WindowResize';

e.VisibilityNodesLoaded = 'e.VisibilityNodesLoaded';
e.ViewpointNodesLoaded = 'e.ViewpointNodesLoaded';

e.ScenarioParsed = 'e.ScenarioParsed';
e.ScenarioDataModelLoaded = 'e.ScenarioDataModelLoaded';
e.ScenarioControllerLoaded = 'e.ScenarioControllerLoaded';



e.DataModelChangedEx = 'e.DataModelChangedEx';

e.BuildingHeightChanged = 'e.BuildingHeightChanged';

e.SetFocus = 'e.SetFocus';
e.RemoveFocus = 'e.RemoveFocus';
e.EnvelopeModelChanged = 'e.EnvelopeModelChanged';

e.RequestLayoutVisibilityChange = 'e.RequestLayoutVisibilityChange';
e.RequestAddToMainInput = 'e.RequestAddToMainInput';
e.RequestAddToTestingInput = 'e.RequestAddToTestingInput';
e.RequestRemoveFromLayout = 'e.RequestRemoveFromLayout';

e.RequestAddToParentGUI = 'e.RequestAddToParentGUI';

e.RequestChangeVisibility = 'e.RequestChangeVisibility';
e.RequestGoToViewpointNode = 'e.RequestGoToViewpointNode';
e.RequestShowViewpoint = 'e.RequestShowViewpoint';

e.RequestActivateView = 'e.RequestActivateView';
e.RequestDataModelChange = 'e.RequestDataModelChange';

e.SelectableLoaded = 'e.SelectableLoaded';
e.Object3DSelected = 'e.Object3DSelected';

e.RequestSelectSystemNode = 'e.RequestSelectSystemNode';
e.SimulationEngineLoaded = 'e.SimulationEngineLoaded';

e.GuiValueChanged = 'e.GuiValueChanged';

e.SplitterResize = 'e.SplitterResize';

e.RequestLoadScenario = 'e.RequestLoadScenario';

e.SimulationInitialized = 'e.SimulationInitialized';// Copyright 2005 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A disposable implementation of a custom
 * listenable/event target. See also: documentation for
 * {@code goog.events.Listenable}.
 *
 * @author arv@google.com (Erik Arvidsson) [Original implementation]
 * @author pupius@google.com (Daniel Pupius) [Port to use goog.events]
 * @see ../demos/eventtarget.html
 * @see goog.events.Listenable
 */

goog.provide('goog.events.EventTarget');

goog.require('goog.Disposable');
goog.require('goog.asserts');
goog.require('goog.events');
goog.require('goog.events.Event');
goog.require('goog.events.Listenable');
goog.require('goog.events.ListenerMap');
goog.require('goog.object');



/**
 * An implementation of {@code goog.events.Listenable} with full W3C
 * EventTarget-like support (capture/bubble mechanism, stopping event
 * propagation, preventing default actions).
 *
 * You may subclass this class to turn your class into a Listenable.
 *
 * Unless propagation is stopped, an event dispatched by an
 * EventTarget will bubble to the parent returned by
 * {@code getParentEventTarget}. To set the parent, call
 * {@code setParentEventTarget}. Subclasses that don't support
 * changing the parent can override the setter to throw an error.
 *
 * Example usage:
 * <pre>
 *   var source = new goog.events.EventTarget();
 *   function handleEvent(e) {
 *     alert('Type: ' + e.type + '; Target: ' + e.target);
 *   }
 *   source.listen('foo', handleEvent);
 *   // Or: goog.events.listen(source, 'foo', handleEvent);
 *   ...
 *   source.dispatchEvent('foo');  // will call handleEvent
 *   ...
 *   source.unlisten('foo', handleEvent);
 *   // Or: goog.events.unlisten(source, 'foo', handleEvent);
 * </pre>
 *
 * @constructor
 * @extends {goog.Disposable}
 * @implements {goog.events.Listenable}
 */
goog.events.EventTarget = function() {
  goog.Disposable.call(this);

  /**
   * Maps of event type to an array of listeners.
   * @private {!goog.events.ListenerMap}
   */
  this.eventTargetListeners_ = new goog.events.ListenerMap(this);

  /**
   * The object to use for event.target. Useful when mixing in an
   * EventTarget to another object.
   * @private {!Object}
   */
  this.actualEventTarget_ = this;
};
goog.inherits(goog.events.EventTarget, goog.Disposable);
goog.events.Listenable.addImplementation(goog.events.EventTarget);


/**
 * An artificial cap on the number of ancestors you can have. This is mainly
 * for loop detection.
 * @const {number}
 * @private
 */
goog.events.EventTarget.MAX_ANCESTORS_ = 1000;


/**
 * Parent event target, used during event bubbling.
 *
 * TODO(user): Change this to goog.events.Listenable. This
 * currently breaks people who expect getParentEventTarget to return
 * goog.events.EventTarget.
 *
 * @type {goog.events.EventTarget}
 * @private
 */
goog.events.EventTarget.prototype.parentEventTarget_ = null;


/**
 * Returns the parent of this event target to use for bubbling.
 *
 * @return {goog.events.EventTarget} The parent EventTarget or null if
 *     there is no parent.
 * @override
 */
goog.events.EventTarget.prototype.getParentEventTarget = function() {
  return this.parentEventTarget_;
};


/**
 * Sets the parent of this event target to use for capture/bubble
 * mechanism.
 * @param {goog.events.EventTarget} parent Parent listenable (null if none).
 */
goog.events.EventTarget.prototype.setParentEventTarget = function(parent) {
  this.parentEventTarget_ = parent;
};


/**
 * Adds an event listener to the event target. The same handler can only be
 * added once per the type. Even if you add the same handler multiple times
 * using the same type then it will only be called once when the event is
 * dispatched.
 *
 * @param {string} type The type of the event to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use {@code #listen} instead, when possible. Otherwise, use
 *     {@code goog.events.listen} if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.addEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  goog.events.listen(this, type, handler, opt_capture, opt_handlerScope);
};


/**
 * Removes an event listener from the event target. The handler must be the
 * same object as the one added. If the handler has not been added then
 * nothing is done.
 *
 * @param {string} type The type of the event to listen for.
 * @param {function(?):?|{handleEvent:function(?):?}|null} handler The function
 *     to handle the event. The handler can also be an object that implements
 *     the handleEvent method which takes the event object as argument.
 * @param {boolean=} opt_capture In DOM-compliant browsers, this determines
 *     whether the listener is fired during the capture or bubble phase
 *     of the event.
 * @param {Object=} opt_handlerScope Object in whose scope to call
 *     the listener.
 * @deprecated Use {@code #unlisten} instead, when possible. Otherwise, use
 *     {@code goog.events.unlisten} if you are passing Object
 *     (instead of Function) as handler.
 */
goog.events.EventTarget.prototype.removeEventListener = function(
    type, handler, opt_capture, opt_handlerScope) {
  goog.events.unlisten(this, type, handler, opt_capture, opt_handlerScope);
};


/** @override */
goog.events.EventTarget.prototype.dispatchEvent = function(e) {
  this.assertInitialized_();

  var ancestorsTree, ancestor = this.getParentEventTarget();
  if (ancestor) {
    ancestorsTree = [];
    var ancestorCount = 1;
    for (; ancestor; ancestor = ancestor.getParentEventTarget()) {
      ancestorsTree.push(ancestor);
      goog.asserts.assert(
          (++ancestorCount < goog.events.EventTarget.MAX_ANCESTORS_),
          'infinite loop');
    }
  }

  return goog.events.EventTarget.dispatchEventInternal_(
      this.actualEventTarget_, e, ancestorsTree);
};


/**
 * Removes listeners from this object.  Classes that extend EventTarget may
 * need to override this method in order to remove references to DOM Elements
 * and additional listeners.
 * @override
 */
goog.events.EventTarget.prototype.disposeInternal = function() {
  goog.events.EventTarget.superClass_.disposeInternal.call(this);

  this.removeAllListeners();
  this.parentEventTarget_ = null;
};


/** @override */
goog.events.EventTarget.prototype.listen = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  this.assertInitialized_();
  return this.eventTargetListeners_.add(
      String(type), listener, false /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.listenOnce = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  return this.eventTargetListeners_.add(
      String(type), listener, true /* callOnce */, opt_useCapture,
      opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.unlisten = function(
    type, listener, opt_useCapture, opt_listenerScope) {
  return this.eventTargetListeners_.remove(
      String(type), listener, opt_useCapture, opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.unlistenByKey = function(key) {
  return this.eventTargetListeners_.removeByKey(key);
};


/** @override */
goog.events.EventTarget.prototype.removeAllListeners = function(opt_type) {
  // TODO(user): Previously, removeAllListeners can be called on
  // uninitialized EventTarget, so we preserve that behavior. We
  // should remove this when usages that rely on that fact are purged.
  if (!this.eventTargetListeners_) {
    return 0;
  }
  return this.eventTargetListeners_.removeAll(opt_type);
};


/** @override */
goog.events.EventTarget.prototype.fireListeners = function(
    type, capture, eventObject) {
  // TODO(user): Original code avoids array creation when there
  // is no listener, so we do the same. If this optimization turns
  // out to be not required, we can replace this with
  // getListeners(type, capture) instead, which is simpler.
  var listenerArray = this.eventTargetListeners_.listeners[String(type)];
  if (!listenerArray) {
    return true;
  }
  listenerArray = listenerArray.concat();

  var rv = true;
  for (var i = 0; i < listenerArray.length; ++i) {
    var listener = listenerArray[i];
    // We might not have a listener if the listener was removed.
    if (listener && !listener.removed && listener.capture == capture) {
      var listenerFn = listener.listener;
      var listenerHandler = listener.handler || listener.src;

      if (listener.callOnce) {
        this.unlistenByKey(listener);
      }
      rv = listenerFn.call(listenerHandler, eventObject) !== false && rv;
    }
  }

  return rv && eventObject.returnValue_ != false;
};


/** @override */
goog.events.EventTarget.prototype.getListeners = function(type, capture) {
  return this.eventTargetListeners_.getListeners(String(type), capture);
};


/** @override */
goog.events.EventTarget.prototype.getListener = function(
    type, listener, capture, opt_listenerScope) {
  return this.eventTargetListeners_.getListener(
      String(type), listener, capture, opt_listenerScope);
};


/** @override */
goog.events.EventTarget.prototype.hasListener = function(
    opt_type, opt_capture) {
  var id = goog.isDef(opt_type) ? String(opt_type) : undefined;
  return this.eventTargetListeners_.hasListener(id, opt_capture);
};


/**
 * Sets the target to be used for {@code event.target} when firing
 * event. Mainly used for testing. For example, see
 * {@code goog.testing.events.mixinListenable}.
 * @param {!Object} target The target.
 */
goog.events.EventTarget.prototype.setTargetForTesting = function(target) {
  this.actualEventTarget_ = target;
};


/**
 * Asserts that the event target instance is initialized properly.
 * @private
 */
goog.events.EventTarget.prototype.assertInitialized_ = function() {
  goog.asserts.assert(
      this.eventTargetListeners_,
      'Event target is not initialized. Did you call the superclass ' +
      '(goog.events.EventTarget) constructor?');
};


/**
 * Dispatches the given event on the ancestorsTree.
 *
 * @param {!Object} target The target to dispatch on.
 * @param {goog.events.Event|Object|string} e The event object.
 * @param {Array.<goog.events.Listenable>=} opt_ancestorsTree The ancestors
 *     tree of the target, in reverse order from the closest ancestor
 *     to the root event target. May be null if the target has no ancestor.
 * @return {boolean} If anyone called preventDefault on the event object (or
 *     if any of the listeners returns false) this will also return false.
 * @private
 */
goog.events.EventTarget.dispatchEventInternal_ = function(
    target, e, opt_ancestorsTree) {
  var type = e.type || /** @type {string} */ (e);

  // If accepting a string or object, create a custom event object so that
  // preventDefault and stopPropagation work with the event.
  if (goog.isString(e)) {
    e = new goog.events.Event(e, target);
  } else if (!(e instanceof goog.events.Event)) {
    var oldEvent = e;
    e = new goog.events.Event(type, target);
    goog.object.extend(e, oldEvent);
  } else {
    e.target = e.target || target;
  }

  var rv = true, currentTarget;

  // Executes all capture listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (var i = opt_ancestorsTree.length - 1; !e.propagationStopped_ && i >= 0;
         i--) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, true, e) && rv;
    }
  }

  // Executes capture and bubble listeners on the target.
  if (!e.propagationStopped_) {
    currentTarget = e.currentTarget = target;
    rv = currentTarget.fireListeners(type, true, e) && rv;
    if (!e.propagationStopped_) {
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  // Executes all bubble listeners on the ancestors, if any.
  if (opt_ancestorsTree) {
    for (i = 0; !e.propagationStopped_ && i < opt_ancestorsTree.length; i++) {
      currentTarget = e.currentTarget = opt_ancestorsTree[i];
      rv = currentTarget.fireListeners(type, false, e) && rv;
    }
  }

  return rv;
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Almost all classes in the 'lgb' namespace inherit
 * from this class. It is primarily concerned with Event listening
 * and dispatching.
 */
goog.provide('lgb.core.BaseClass');

goog.require('goog.events');
goog.require('goog.events.EventTarget');

goog.require('lgb.core.Event');

/**
 * MVC base class
 * @constructor
 * @extends {goog.events.EventTarget}
 */
lgb.core.BaseClass = function() {
    
  goog.events.EventTarget.call(this);
  
  this.delegateIdx = {};
  this.listenKeys = {};

};
goog.inherits(lgb.core.BaseClass, goog.events.EventTarget);


/**
 * creates a proxy function ( also known as a delegate ) using jQuery which
 * maintains the context of "this"
 * @param {!Function} theFunction The function used to create the delegate.
 * @param {*=} arg The optional argument baked into the call.
 * @return {!Function} The delagate.
 */
lgb.core.BaseClass.prototype.d = function(theFunction, arg) {
  var delegate;

  if (arg === undefined) {
    delegate = jQuery.proxy(theFunction, this);
  } else {
    delegate = jQuery.proxy(theFunction, this, arg);
  }

  return delegate;
};



/**
 * fires an event
 * "this" is the event target
 * @param {goog.events.Event} event The event object to dispatch.
 */
lgb.core.BaseClass.prototype.dispatchLocal = function(event) {
  goog.events.dispatchEvent(this, event);
};


lgb.core.BaseClass.prototype.triggerLocal = function(type, payload) {
  
  if (null == payload) {
    payload = this;
  }
  
  
  
  var event = new lgb.core.Event(type, payload);
  goog.events.dispatchEvent(this, event);
};


/**
 * binds a listener to an event
 * listens to the lgb global event bus
 * @param {!string} eventType Unique identifier for the event.
 * @param {!Function} handler Function that will be called when the event fires.
 * @return {?number} the event handler key.
 */
lgb.core.BaseClass.prototype.listen = function(eventType, handler) {
  return this.listenHelper_(lgb.globalEventBus, eventType, this, handler);
};

/**
 * binds a listener to an event
 * listens only to the specified event target
 * @param {goog.events.EventTarget} eventTarget The object to listen to.
 * @param {!string} eventType Unique identifier for the event.
 * @param {!Function} handler Function that will be called when the event fires.
 * @return {?number} the event handler key.
 */
lgb.core.BaseClass.prototype.listenTo = function(eventTarget, eventType, handler) {
  
  if (isArray (eventTarget)) {
    this.each(eventTarget, this.listenHelper_, eventType, this, handler);
  } else {
    return this.listenHelper_(eventTarget, eventType, this, handler);
  }
  

};


lgb.core.BaseClass.prototype.hasListener = function(eventTarget, eventType, handler) {
  
  
 var result = goog.events.hasListener(
    eventTarget,
    eventType,
    handler);

  return result;
  
};




/**
 * binds a listener to an event
 * @private
 * @param {goog.events.EventTarget} eventTarget Object to listen to.
 * @param {!string} eventType Unique identifier for the event.
 * @param {!Object} handlerContext The JS context to use when
 * calling the function usually "this".
 * @param {!Function} handler The function that will be called
 * when the event fires.
 * @return {?number} the event handler key.
 */
lgb.core.BaseClass.prototype.listenHelper_ = function(
  eventTarget, eventType, handlerContext, handler) {

  /**@type {Function} */
  var delegate = jQuery.proxy(handler, handlerContext);

 var key = goog.events.listen(
    eventTarget,
    eventType,
    delegate);

  return key;

};


/**
 * binds a listener to an event
 * listens to the lgb global event bus
 * After the event has fired, the event listener is removed
 * from the target
 * @param {!string} eventType Unique identifier for the event.
 * @param {!Function} handler Function that will be called when the event fires.
 */
lgb.core.BaseClass.prototype.listenOnce = function(eventType, handler) {
  this.listenOnceHelper_(lgb.globalEventBus, eventType, this, handler);
};

/**
 * binds a listener to an event
 * listens only to the specified event target
 * After the event has fired, the event listener is removed
 * from the target
 * @param {!goog.events.EventTarget} eventTarget The object to listen to.
 * @param {!string} eventType Unique identifier for the event.
 * @param {!Function} handler Function that will be called when the event fires.
 */
lgb.core.BaseClass.prototype.listenToOnce = function(
    eventTarget, eventType, handler) {

  this.listenOnceHelper_(eventTarget, eventType, this, handler);
};


/**
 * binds a listener to an event
 * After the event has fired, the event listener is removed
 * from the target
 * @param {!goog.events.EventTarget} eventTarget Object to listen to.
 * @param {!string} eventType Unique identifier for the event.
 * @param {!Object} handlerContext The JS context to use when
 * calling the function usually "this".
 * @param {!Function} handler The function that will be called
 * when the event fires.
 * @private
 */
lgb.core.BaseClass.prototype.listenOnceHelper_ = function(
  eventTarget, eventType, handlerContext, handler) {

  /**@type {Function} */
  var delegate = jQuery.proxy(handler, handlerContext);

  goog.events.listenOnce(
    eventTarget,
    eventType,
    delegate);
};

/**
 * loop though the array and
 * supply each element as an argument
 *  to the handler
 * @param {Array} ary The array to loop though.
 * @param {Function} handler The handler to call.
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @protected
 */
lgb.core.BaseClass.prototype.each = function(ary, handler) {
  var additionalArgs = null;
  var allArguments = Array.prototype.slice.call(arguments);
  var len = allArguments.length;
  if (len > 2) {
    additionalArgs = allArguments.slice(2, len);
  }
  
  var l = ary.length;
  for (var i = 0; i < l; i++) {
    var arrayElement = ary[i];
    
    var argList = [arrayElement];
    
    if(additionalArgs) {
      argList = argList.concat(additionalArgs);
    }
    
    handler.apply(this, argList);
  }
};




lgb.core.BaseClass.prototype.eachProperty = function(object, handler) {
  
  var additionalArgs = null;
  var allArguments = Array.prototype.slice.call(arguments);
  var len = allArguments.length;
  if (len > 2) {
    additionalArgs = allArguments.slice(2, len);
  }
  
  for(var propertyName in object) {

    var propertyValue = object[propertyName];
    var argList = [propertyValue];
    
    if(additionalArgs) {
      argList = argList.concat(additionalArgs);
    }
    
    handler.apply(this, argList);
  }

};

lgb.core.BaseClass.prototype.eachPropertyName = function(object, handler) {
  
  var additionalArgs = null;
  var allArguments = Array.prototype.slice.call(arguments);
  var len = allArguments.length;
  if (len > 2) {
    additionalArgs = allArguments.slice(2, len);
  }
  
  for(var propertyName in object) {

    var propertyValue = object[propertyName];
    var argList = [propertyValue, propertyName];
    
    if(additionalArgs) {
      argList = argList.concat(additionalArgs);
    }
    
    handler.apply(this, argList);
  }
  
  

};

// lgb.core.BaseClass.prototype.eachPropertyNameCall = function(object, handlerName) {
//   
// 
  // var additionalArgs = null;
  // var allArguments = Array.prototype.slice.call(arguments);
  // var len = allArguments.length;
  // if (len > 2) {
    // additionalArgs = allArguments.slice(2, len);
  // }
//   
  // for(var propertyName in object) {
// 
    // var propertyValue = object[propertyName];
    // var argList = [propertyValue, propertyName];
//     
    // if(additionalArgs) {
      // argList = argList.concat(additionalArgs);
    // }
//     
    // var handler = propertyValue[handlerName];
//     
    // handler.apply(propertyValue, argList);
  // }
// 
// };


/**
 * loop though the array and
 * supply each element as an argument
 *  to the handler
 * @param {Array} ary The array to loop though.
 * @param {Function} handler The handler to call.
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @protected
 */
lgb.core.BaseClass.prototype.eachIdx = function(ary, handler) {
  var additionalArgs = null;
  var allArguments = Array.prototype.slice.call(arguments);
  var len = allArguments.length;
  if (len > 2) {
    additionalArgs = allArguments.slice(2, len);
  }
  
  var l = ary.length;
  for (var i = 0; i < l; i++) {
    var arrayElement = ary[i];
    
    var argList = [arrayElement];
    

    argList.push(i);
    
    
    if(additionalArgs) {
      argList = argList.concat(additionalArgs);
    }
    
    handler.apply(this, argList);
  }
};



/**
 * removed an event binding
 * @param {!number} key The key for the event handler.
 */
lgb.core.BaseClass.prototype.unlisten = function(key) {
  
  if(key) {
    goog.events.unlistenByKey(key);
  }

};


lgb.core.BaseClass.prototype.getClassName = function() {
  
  var fullClassName = this.getFullClassName();
  var ary = fullClassName.split('.');
  
  var len = ary.length;
  var className = ary[len-1];
  
  return className;
};


lgb.core.BaseClass.prototype.getClassConstructor = function() {
  
  var fullClassName = this.getFullClassName();
  var classConstructor = eval(fullClassName);

  return classConstructor;
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.core.BaseController');

goog.require('goog.events.Event');
goog.require('lgb.core.BaseClass');

//TODO (Raj) change some of the listen() fucntions to 'bind'
/**
 * @constructor
 * @extends lgb.core.BaseClass
 */
lgb.core.BaseController = function() {
  lgb.core.BaseClass.call(this);
  
  this.childGUIcontrollers_ = [];
};
goog.inherits(lgb.core.BaseController, lgb.core.BaseClass);


lgb.core.BaseController.prototype.makeChildGUIcontroller_ = function(classReference, initArg) {

  var controller = new classReference();
    
  this.childGUIcontrollers_.push(controller);
  
  this.listenTo(
    controller,
    e.RequestAddToParentGUI, 
    this.onRequestAddToParentGUI_
    );
    
  
  if (undefined == initArg) {
    controller.init();
  } else {
    controller.init(initArg);
  }
  

  return controller;

};

lgb.core.BaseController.prototype.onRequestAddToParentGUI_ = function(event) {

  if (undefined == this.guiView.add) {
    debugger;
  }
  this.guiView.add(event.payload);
  
};


lgb.core.BaseController.prototype.triggerGUI = function(event) {

  this.guiView.init();
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  
};






/**
 * fires an event on the lgb global event bus
 * lgb.globalEventBus is the event target
 * @param {goog.events.Event} event The event object to dispatch.
 */
lgb.core.BaseController.prototype.dispatch = function(event) {
  goog.events.dispatchEvent(lgb.globalEventBus, event);
};


lgb.core.BaseController.prototype.trigger = function(type, payload) {
  var event = new lgb.core.Event(type, payload);
  goog.events.dispatchEvent(lgb.globalEventBus, event);
};


lgb.core.BaseClass.prototype.relayLocal = function(eventTarget, eventType) {
  this.listenTo(eventTarget, eventType, this.onRelayLocal_);
};


lgb.core.BaseClass.prototype.onRelayLocal_ = function(event) {
  this.dispatchLocal(event);
};


lgb.core.BaseClass.prototype.relay = function(eventTarget, eventType) {
  
  if (isArray(eventType)) {
    var that = this;
    eventType.forEach(
      function(oneEventType, idx, ary) {
        that.listenTo(eventTarget, oneEventType, that.onRelay_);
      }
    );
  } else {
    this.listenTo(eventTarget, eventType, this.onRelay_);
  }

};

lgb.core.BaseClass.prototype.onRelay_ = function(event) {
  this.dispatch(event);
};



// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the collection interface.
 *
 * @author nnaze@google.com (Nathan Naze)
 */

goog.provide('goog.structs.Collection');



/**
 * An interface for a collection of values.
 * @interface
 * @template T
 */
goog.structs.Collection = function() {};


/**
 * @param {T} value Value to add to the collection.
 */
goog.structs.Collection.prototype.add;


/**
 * @param {T} value Value to remove from the collection.
 */
goog.structs.Collection.prototype.remove;


/**
 * @param {T} value Value to find in the collection.
 * @return {boolean} Whether the collection contains the specified value.
 */
goog.structs.Collection.prototype.contains;


/**
 * @return {number} The number of values stored in the collection.
 */
goog.structs.Collection.prototype.getCount;

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Generics method for collection-like classes and objects.
 *
 * @author arv@google.com (Erik Arvidsson)
 *
 * This file contains functions to work with collections. It supports using
 * Map, Set, Array and Object and other classes that implement collection-like
 * methods.
 */


goog.provide('goog.structs');

goog.require('goog.array');
goog.require('goog.object');


// We treat an object as a dictionary if it has getKeys or it is an object that
// isn't arrayLike.


/**
 * Returns the number of values in the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {number} The number of values in the collection-like object.
 */
goog.structs.getCount = function(col) {
  if (typeof col.getCount == 'function') {
    return col.getCount();
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return col.length;
  }
  return goog.object.getCount(col);
};


/**
 * Returns the values of the collection-like object.
 * @param {Object} col The collection-like object.
 * @return {!Array} The values in the collection-like object.
 */
goog.structs.getValues = function(col) {
  if (typeof col.getValues == 'function') {
    return col.getValues();
  }
  if (goog.isString(col)) {
    return col.split('');
  }
  if (goog.isArrayLike(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(col[i]);
    }
    return rv;
  }
  return goog.object.getValues(col);
};


/**
 * Returns the keys of the collection. Some collections have no notion of
 * keys/indexes and this function will return undefined in those cases.
 * @param {Object} col The collection-like object.
 * @return {!Array|undefined} The keys in the collection.
 */
goog.structs.getKeys = function(col) {
  if (typeof col.getKeys == 'function') {
    return col.getKeys();
  }
  // if we have getValues but no getKeys we know this is a key-less collection
  if (typeof col.getValues == 'function') {
    return undefined;
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    var rv = [];
    var l = col.length;
    for (var i = 0; i < l; i++) {
      rv.push(i);
    }
    return rv;
  }

  return goog.object.getKeys(col);
};


/**
 * Whether the collection contains the given value. This is O(n) and uses
 * equals (==) to test the existence.
 * @param {Object} col The collection-like object.
 * @param {*} val The value to check for.
 * @return {boolean} True if the map contains the value.
 */
goog.structs.contains = function(col, val) {
  if (typeof col.contains == 'function') {
    return col.contains(val);
  }
  if (typeof col.containsValue == 'function') {
    return col.containsValue(val);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.contains(/** @type {Array} */ (col), val);
  }
  return goog.object.containsValue(col, val);
};


/**
 * Whether the collection is empty.
 * @param {Object} col The collection-like object.
 * @return {boolean} True if empty.
 */
goog.structs.isEmpty = function(col) {
  if (typeof col.isEmpty == 'function') {
    return col.isEmpty();
  }

  // We do not use goog.string.isEmpty because here we treat the string as
  // collection and as such even whitespace matters

  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.isEmpty(/** @type {Array} */ (col));
  }
  return goog.object.isEmpty(col);
};


/**
 * Removes all the elements from the collection.
 * @param {Object} col The collection-like object.
 */
goog.structs.clear = function(col) {
  // NOTE(arv): This should not contain strings because strings are immutable
  if (typeof col.clear == 'function') {
    col.clear();
  } else if (goog.isArrayLike(col)) {
    goog.array.clear(/** @type {goog.array.ArrayLike} */ (col));
  } else {
    goog.object.clear(col);
  }
};


/**
 * Calls a function for each value in a collection. The function takes
 * three arguments; the value, the key and the collection.
 *
 * NOTE: This will be deprecated soon! Please use a more specific method if
 * possible, e.g. goog.array.forEach, goog.object.forEach, etc.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):?} f The function to call for every value.
 *     This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and the return value is irrelevant.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @template T,S
 */
goog.structs.forEach = function(col, f, opt_obj) {
  if (typeof col.forEach == 'function') {
    col.forEach(f, opt_obj);
  } else if (goog.isArrayLike(col) || goog.isString(col)) {
    goog.array.forEach(/** @type {Array} */ (col), f, opt_obj);
  } else {
    var keys = goog.structs.getKeys(col);
    var values = goog.structs.getValues(col);
    var l = values.length;
    for (var i = 0; i < l; i++) {
      f.call(opt_obj, values[i], keys && keys[i], col);
    }
  }
};


/**
 * Calls a function for every value in the collection. When a call returns true,
 * adds the value to a new collection (Array is returned by default).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes
 *     3 arguments (the value, the key or undefined if the collection has no
 *     notion of keys, and the collection) and should return a Boolean. If the
 *     return value is true the value is added to the result collection. If it
 *     is false the value is not included.
 * @param {T=} opt_obj The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object|!Array} A new collection where the passed values are
 *     present. If col is a key-less collection an array is returned.  If col
 *     has keys and values a plain old JS object is returned.
 * @template T,S
 */
goog.structs.filter = function(col, f, opt_obj) {
  if (typeof col.filter == 'function') {
    return col.filter(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.filter(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], keys[i], col)) {
        rv[keys[i]] = values[i];
      }
    }
  } else {
    // We should not use goog.array.filter here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      if (f.call(opt_obj, values[i], undefined, col)) {
        rv.push(values[i]);
      }
    }
  }
  return rv;
};


/**
 * Calls a function for every value in the collection and adds the result into a
 * new collection (defaults to creating a new Array).
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):V} f The function to call for every value.
 *     This function takes 3 arguments (the value, the key or undefined if the
 *     collection has no notion of keys, and the collection) and should return
 *     something. The result will be used as the value in the new collection.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {!Object.<V>|!Array.<V>} A new collection with the new values.  If
 *     col is a key-less collection an array is returned.  If col has keys and
 *     values a plain old JS object is returned.
 * @template T,S,V
 */
goog.structs.map = function(col, f, opt_obj) {
  if (typeof col.map == 'function') {
    return col.map(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.map(/** @type {!Array} */ (col), f, opt_obj);
  }

  var rv;
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  if (keys) {
    rv = {};
    for (var i = 0; i < l; i++) {
      rv[keys[i]] = f.call(opt_obj, values[i], keys[i], col);
    }
  } else {
    // We should not use goog.array.map here since we want to make sure that
    // the index is undefined as well as make sure that col is passed to the
    // function.
    rv = [];
    for (var i = 0; i < l; i++) {
      rv[i] = f.call(opt_obj, values[i], undefined, col);
    }
  }
  return rv;
};


/**
 * Calls f for each value in a collection. If any call returns true this returns
 * true (without checking the rest). If all returns false this returns false.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or undefined
 *     if the collection has no notion of keys, and the collection) and should
 *     return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if any value passes the test.
 * @template T,S
 */
goog.structs.some = function(col, f, opt_obj) {
  if (typeof col.some == 'function') {
    return col.some(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.some(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (f.call(opt_obj, values[i], keys && keys[i], col)) {
      return true;
    }
  }
  return false;
};


/**
 * Calls f for each value in a collection. If all calls return true this return
 * true this returns true. If any returns false this returns false at this point
 *  and does not continue to check the remaining values.
 *
 * @param {S} col The collection-like object.
 * @param {function(this:T,?,?,S):boolean} f The function to call for every
 *     value. This function takes 3 arguments (the value, the key or
 *     undefined if the collection has no notion of keys, and the collection)
 *     and should return a boolean.
 * @param {T=} opt_obj  The object to be used as the value of 'this'
 *     within {@code f}.
 * @return {boolean} True if all key-value pairs pass the test.
 * @template T,S
 */
goog.structs.every = function(col, f, opt_obj) {
  if (typeof col.every == 'function') {
    return col.every(f, opt_obj);
  }
  if (goog.isArrayLike(col) || goog.isString(col)) {
    return goog.array.every(/** @type {!Array} */ (col), f, opt_obj);
  }
  var keys = goog.structs.getKeys(col);
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    if (!f.call(opt_obj, values[i], keys && keys[i], col)) {
      return false;
    }
  }
  return true;
};
// Copyright 2008 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for creating functions. Loosely inspired by the
 * java classes: http://goo.gl/GM0Hmu and http://goo.gl/6k7nI8.
 *
 * @author nicksantos@google.com (Nick Santos)
 */


goog.provide('goog.functions');


/**
 * Creates a function that always returns the same value.
 * @param {T} retValue The value to return.
 * @return {function():T} The new function.
 * @template T
 */
goog.functions.constant = function(retValue) {
  return function() {
    return retValue;
  };
};


/**
 * Always returns false.
 * @type {function(...): boolean}
 */
goog.functions.FALSE = goog.functions.constant(false);


/**
 * Always returns true.
 * @type {function(...): boolean}
 */
goog.functions.TRUE = goog.functions.constant(true);


/**
 * Always returns NULL.
 * @type {function(...): null}
 */
goog.functions.NULL = goog.functions.constant(null);


/**
 * A simple function that returns the first argument of whatever is passed
 * into it.
 * @param {T=} opt_returnValue The single value that will be returned.
 * @param {...*} var_args Optional trailing arguments. These are ignored.
 * @return {T} The first argument passed in, or undefined if nothing was passed.
 * @template T
 */
goog.functions.identity = function(opt_returnValue, var_args) {
  return opt_returnValue;
};


/**
 * Creates a function that always throws an error with the given message.
 * @param {string} message The error message.
 * @return {!Function} The error-throwing function.
 */
goog.functions.error = function(message) {
  return function() {
    throw Error(message);
  };
};


/**
 * Creates a function that throws the given object.
 * @param {*} err An object to be thrown.
 * @return {!Function} The error-throwing function.
 */
goog.functions.fail = function(err) {
  return function() {
    throw err;
  }
};


/**
 * Given a function, create a function that keeps opt_numArgs arguments and
 * silently discards all additional arguments.
 * @param {Function} f The original function.
 * @param {number=} opt_numArgs The number of arguments to keep. Defaults to 0.
 * @return {!Function} A version of f that only keeps the first opt_numArgs
 *     arguments.
 */
goog.functions.lock = function(f, opt_numArgs) {
  opt_numArgs = opt_numArgs || 0;
  return function() {
    return f.apply(this, Array.prototype.slice.call(arguments, 0, opt_numArgs));
  };
};


/**
 * Creates a function that returns its nth argument.
 * @param {number} n The position of the return argument.
 * @return {!Function} A new function.
 */
goog.functions.nth = function(n) {
  return function() {
    return arguments[n];
  };
};


/**
 * Given a function, create a new function that swallows its return value
 * and replaces it with a new one.
 * @param {Function} f A function.
 * @param {T} retValue A new return value.
 * @return {function(...[?]):T} A new function.
 * @template T
 */
goog.functions.withReturnValue = function(f, retValue) {
  return goog.functions.sequence(f, goog.functions.constant(retValue));
};


/**
 * Creates the composition of the functions passed in.
 * For example, (goog.functions.compose(f, g))(a) is equivalent to f(g(a)).
 * @param {function(...[?]):T} fn The final function.
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):T} The composition of all inputs.
 * @template T
 */
goog.functions.compose = function(fn, var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    var result;
    if (length) {
      result = functions[length - 1].apply(this, arguments);
    }

    for (var i = length - 2; i >= 0; i--) {
      result = functions[i].call(this, result);
    }
    return result;
  };
};


/**
 * Creates a function that calls the functions passed in in sequence, and
 * returns the value of the last function. For example,
 * (goog.functions.sequence(f, g))(x) is equivalent to f(x),g(x).
 * @param {...Function} var_args A list of functions.
 * @return {!Function} A function that calls all inputs in sequence.
 */
goog.functions.sequence = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    var result;
    for (var i = 0; i < length; i++) {
      result = functions[i].apply(this, arguments);
    }
    return result;
  };
};


/**
 * Creates a function that returns true if each of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns false.
 * For example, (goog.functions.and(f, g))(x) is equivalent to f(x) && g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ANDs its component
 *      functions.
 */
goog.functions.and = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    for (var i = 0; i < length; i++) {
      if (!functions[i].apply(this, arguments)) {
        return false;
      }
    }
    return true;
  };
};


/**
 * Creates a function that returns true if any of its components evaluates
 * to true. The components are evaluated in order, and the evaluation will be
 * short-circuited as soon as a function returns true.
 * For example, (goog.functions.or(f, g))(x) is equivalent to f(x) || g(x).
 * @param {...Function} var_args A list of functions.
 * @return {function(...[?]):boolean} A function that ORs its component
 *    functions.
 */
goog.functions.or = function(var_args) {
  var functions = arguments;
  var length = functions.length;
  return function() {
    for (var i = 0; i < length; i++) {
      if (functions[i].apply(this, arguments)) {
        return true;
      }
    }
    return false;
  };
};


/**
 * Creates a function that returns the Boolean opposite of a provided function.
 * For example, (goog.functions.not(f))(x) is equivalent to !f(x).
 * @param {!Function} f The original function.
 * @return {function(...[?]):boolean} A function that delegates to f and returns
 * opposite.
 */
goog.functions.not = function(f) {
  return function() {
    return !f.apply(this, arguments);
  };
};


/**
 * Generic factory function to construct an object given the constructor
 * and the arguments. Intended to be bound to create object factories.
 *
 * Callers should cast the result to the appropriate type for proper type
 * checking by the compiler.
 * @param {!Function} constructor The constructor for the Object.
 * @param {...*} var_args The arguments to be passed to the constructor.
 * @return {!Object} A new instance of the class given in {@code constructor}.
 */
goog.functions.create = function(constructor, var_args) {
  /**
 * @constructor
 * @final
 */
  var temp = function() {};
  temp.prototype = constructor.prototype;

  // obj will have constructor's prototype in its chain and
  // 'obj instanceof constructor' will be true.
  var obj = new temp();

  // obj is initialized by constructor.
  // arguments is only array-like so lacks shift(), but can be used with
  // the Array prototype function.
  constructor.apply(obj, Array.prototype.slice.call(arguments, 1));
  return obj;
};


/**
 * @define {boolean} Whether the return value cache should be used.
 *    This should only be used to disable caches when testing.
 */
goog.define('goog.functions.CACHE_RETURN_VALUE', true);


/**
 * Gives a wrapper function that caches the return value of a parameterless
 * function when first called.
 *
 * When called for the first time, the given function is called and its
 * return value is cached (thus this is only appropriate for idempotent
 * functions).  Subsequent calls will return the cached return value. This
 * allows the evaluation of expensive functions to be delayed until first used.
 *
 * To cache the return values of functions with parameters, see goog.memoize.
 *
 * @param {!function():T} fn A function to lazily evaluate.
 * @return {!function():T} A wrapped version the function.
 * @template T
 */
goog.functions.cacheReturnValue = function(fn) {
  var called = false;
  var value;

  return function() {
    if (!goog.functions.CACHE_RETURN_VALUE) {
      return fn();
    }

    if (!called) {
      value = fn();
      called = true;
    }

    return value;
  }
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Additional mathematical functions.
 */

goog.provide('goog.math');

goog.require('goog.array');
goog.require('goog.asserts');


/**
 * Returns a random integer greater than or equal to 0 and less than {@code a}.
 * @param {number} a  The upper bound for the random integer (exclusive).
 * @return {number} A random integer N such that 0 <= N < a.
 */
goog.math.randomInt = function(a) {
  return Math.floor(Math.random() * a);
};


/**
 * Returns a random number greater than or equal to {@code a} and less than
 * {@code b}.
 * @param {number} a  The lower bound for the random number (inclusive).
 * @param {number} b  The upper bound for the random number (exclusive).
 * @return {number} A random number N such that a <= N < b.
 */
goog.math.uniformRandom = function(a, b) {
  return a + Math.random() * (b - a);
};


/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
goog.math.clamp = function(value, min, max) {
  return Math.min(Math.max(value, min), max);
};


/**
 * The % operator in JavaScript returns the remainder of a / b, but differs from
 * some other languages in that the result will have the same sign as the
 * dividend. For example, -1 % 8 == -1, whereas in some other languages
 * (such as Python) the result would be 7. This function emulates the more
 * correct modulo behavior, which is useful for certain applications such as
 * calculating an offset index in a circular list.
 *
 * @param {number} a The dividend.
 * @param {number} b The divisor.
 * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
 *     or b < x <= 0, depending on the sign of b).
 */
goog.math.modulo = function(a, b) {
  var r = a % b;
  // If r and b differ in sign, add b to wrap the result to the correct sign.
  return (r * b < 0) ? r + b : r;
};


/**
 * Performs linear interpolation between values a and b. Returns the value
 * between a and b proportional to x (when x is between 0 and 1. When x is
 * outside this range, the return value is a linear extrapolation).
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number} x The proportion between a and b.
 * @return {number} The interpolated value between a and b.
 */
goog.math.lerp = function(a, b, x) {
  return a + x * (b - a);
};


/**
 * Tests whether the two values are equal to each other, within a certain
 * tolerance to adjust for floating point errors.
 * @param {number} a A number.
 * @param {number} b A number.
 * @param {number=} opt_tolerance Optional tolerance range. Defaults
 *     to 0.000001. If specified, should be greater than 0.
 * @return {boolean} Whether {@code a} and {@code b} are nearly equal.
 */
goog.math.nearlyEquals = function(a, b, opt_tolerance) {
  return Math.abs(a - b) <= (opt_tolerance || 0.000001);
};


// TODO(user): Rename to normalizeAngle, retaining old name as deprecated
// alias.
/**
 * Normalizes an angle to be in range [0-360). Angles outside this range will
 * be normalized to be the equivalent angle with that range.
 * @param {number} angle Angle in degrees.
 * @return {number} Standardized angle.
 */
goog.math.standardAngle = function(angle) {
  return goog.math.modulo(angle, 360);
};


/**
 * Normalizes an angle to be in range [0-2*PI). Angles outside this range will
 * be normalized to be the equivalent angle with that range.
 * @param {number} angle Angle in radians.
 * @return {number} Standardized angle.
 */
goog.math.standardAngleInRadians = function(angle) {
  return goog.math.modulo(angle, 2 * Math.PI);
};


/**
 * Converts degrees to radians.
 * @param {number} angleDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
goog.math.toRadians = function(angleDegrees) {
  return angleDegrees * Math.PI / 180;
};


/**
 * Converts radians to degrees.
 * @param {number} angleRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
goog.math.toDegrees = function(angleRadians) {
  return angleRadians * 180 / Math.PI;
};


/**
 * For a given angle and radius, finds the X portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The x-distance for the angle and radius.
 */
goog.math.angleDx = function(degrees, radius) {
  return radius * Math.cos(goog.math.toRadians(degrees));
};


/**
 * For a given angle and radius, finds the Y portion of the offset.
 * @param {number} degrees Angle in degrees (zero points in +X direction).
 * @param {number} radius Radius.
 * @return {number} The y-distance for the angle and radius.
 */
goog.math.angleDy = function(degrees, radius) {
  return radius * Math.sin(goog.math.toRadians(degrees));
};


/**
 * Computes the angle between two points (x1,y1) and (x2,y2).
 * Angle zero points in the +X direction, 90 degrees points in the +Y
 * direction (down) and from there we grow clockwise towards 360 degrees.
 * @param {number} x1 x of first point.
 * @param {number} y1 y of first point.
 * @param {number} x2 x of second point.
 * @param {number} y2 y of second point.
 * @return {number} Standardized angle in degrees of the vector from
 *     x1,y1 to x2,y2.
 */
goog.math.angle = function(x1, y1, x2, y2) {
  return goog.math.standardAngle(goog.math.toDegrees(Math.atan2(y2 - y1,
                                                                x2 - x1)));
};


/**
 * Computes the difference between startAngle and endAngle (angles in degrees).
 * @param {number} startAngle  Start angle in degrees.
 * @param {number} endAngle  End angle in degrees.
 * @return {number} The number of degrees that when added to
 *     startAngle will result in endAngle. Positive numbers mean that the
 *     direction is clockwise. Negative numbers indicate a counter-clockwise
 *     direction.
 *     The shortest route (clockwise vs counter-clockwise) between the angles
 *     is used.
 *     When the difference is 180 degrees, the function returns 180 (not -180)
 *     angleDifference(30, 40) is 10, and angleDifference(40, 30) is -10.
 *     angleDifference(350, 10) is 20, and angleDifference(10, 350) is -20.
 */
goog.math.angleDifference = function(startAngle, endAngle) {
  var d = goog.math.standardAngle(endAngle) -
          goog.math.standardAngle(startAngle);
  if (d > 180) {
    d = d - 360;
  } else if (d <= -180) {
    d = 360 + d;
  }
  return d;
};


/**
 * Returns the sign of a number as per the "sign" or "signum" function.
 * @param {number} x The number to take the sign of.
 * @return {number} -1 when negative, 1 when positive, 0 when 0.
 */
goog.math.sign = function(x) {
  return x == 0 ? 0 : (x < 0 ? -1 : 1);
};


/**
 * JavaScript implementation of Longest Common Subsequence problem.
 * http://en.wikipedia.org/wiki/Longest_common_subsequence
 *
 * Returns the longest possible array that is subarray of both of given arrays.
 *
 * @param {Array.<Object>} array1 First array of objects.
 * @param {Array.<Object>} array2 Second array of objects.
 * @param {Function=} opt_compareFn Function that acts as a custom comparator
 *     for the array ojects. Function should return true if objects are equal,
 *     otherwise false.
 * @param {Function=} opt_collectorFn Function used to decide what to return
 *     as a result subsequence. It accepts 2 arguments: index of common element
 *     in the first array and index in the second. The default function returns
 *     element from the first array.
 * @return {!Array.<Object>} A list of objects that are common to both arrays
 *     such that there is no common subsequence with size greater than the
 *     length of the list.
 */
goog.math.longestCommonSubsequence = function(
    array1, array2, opt_compareFn, opt_collectorFn) {

  var compare = opt_compareFn || function(a, b) {
    return a == b;
  };

  var collect = opt_collectorFn || function(i1, i2) {
    return array1[i1];
  };

  var length1 = array1.length;
  var length2 = array2.length;

  var arr = [];
  for (var i = 0; i < length1 + 1; i++) {
    arr[i] = [];
    arr[i][0] = 0;
  }

  for (var j = 0; j < length2 + 1; j++) {
    arr[0][j] = 0;
  }

  for (i = 1; i <= length1; i++) {
    for (j = 1; j <= length2; j++) {
      if (compare(array1[i - 1], array2[j - 1])) {
        arr[i][j] = arr[i - 1][j - 1] + 1;
      } else {
        arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]);
      }
    }
  }

  // Backtracking
  var result = [];
  var i = length1, j = length2;
  while (i > 0 && j > 0) {
    if (compare(array1[i - 1], array2[j - 1])) {
      result.unshift(collect(i - 1, j - 1));
      i--;
      j--;
    } else {
      if (arr[i - 1][j] > arr[i][j - 1]) {
        i--;
      } else {
        j--;
      }
    }
  }

  return result;
};


/**
 * Returns the sum of the arguments.
 * @param {...number} var_args Numbers to add.
 * @return {number} The sum of the arguments (0 if no arguments were provided,
 *     {@code NaN} if any of the arguments is not a valid number).
 */
goog.math.sum = function(var_args) {
  return /** @type {number} */ (goog.array.reduce(arguments,
      function(sum, value) {
        return sum + value;
      }, 0));
};


/**
 * Returns the arithmetic mean of the arguments.
 * @param {...number} var_args Numbers to average.
 * @return {number} The average of the arguments ({@code NaN} if no arguments
 *     were provided or any of the arguments is not a valid number).
 */
goog.math.average = function(var_args) {
  return goog.math.sum.apply(null, arguments) / arguments.length;
};


/**
 * Returns the unbiased sample variance of the arguments. For a definition,
 * see e.g. http://en.wikipedia.org/wiki/Variance
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The unbiased sample variance of the arguments (0 if fewer
 *     than two samples were provided, or {@code NaN} if any of the samples is
 *     not a valid number).
 */
goog.math.sampleVariance = function(var_args) {
  var sampleSize = arguments.length;
  if (sampleSize < 2) {
    return 0;
  }

  var mean = goog.math.average.apply(null, arguments);
  var variance = goog.math.sum.apply(null, goog.array.map(arguments,
      function(val) {
        return Math.pow(val - mean, 2);
      })) / (sampleSize - 1);

  return variance;
};


/**
 * Returns the sample standard deviation of the arguments.  For a definition of
 * sample standard deviation, see e.g.
 * http://en.wikipedia.org/wiki/Standard_deviation
 * @param {...number} var_args Number samples to analyze.
 * @return {number} The sample standard deviation of the arguments (0 if fewer
 *     than two samples were provided, or {@code NaN} if any of the samples is
 *     not a valid number).
 */
goog.math.standardDeviation = function(var_args) {
  return Math.sqrt(goog.math.sampleVariance.apply(null, arguments));
};


/**
 * Returns whether the supplied number represents an integer, i.e. that is has
 * no fractional component.  No range-checking is performed on the number.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is an integer.
 */
goog.math.isInt = function(num) {
  return isFinite(num) && num % 1 == 0;
};


/**
 * Returns whether the supplied number is finite and not NaN.
 * @param {number} num The number to test.
 * @return {boolean} Whether {@code num} is a finite number.
 */
goog.math.isFiniteNumber = function(num) {
  return isFinite(num) && !isNaN(num);
};


/**
 * Returns the precise value of floor(log10(num)).
 * Simpler implementations didn't work because of floating point rounding
 * errors. For example
 * <ul>
 * <li>Math.floor(Math.log(num) / Math.LN10) is off by one for num == 1e+3.
 * <li>Math.floor(Math.log(num) * Math.LOG10E) is off by one for num == 1e+15.
 * <li>Math.floor(Math.log10(num)) is off by one for num == 1e+15 - 1.
 * </ul>
 * @param {number} num A floating point number.
 * @return {number} Its logarithm to base 10 rounded down to the nearest
 *     integer if num > 0. -Infinity if num == 0. NaN if num < 0.
 */
goog.math.log10Floor = function(num) {
  if (num > 0) {
    var x = Math.round(Math.log(num) * Math.LOG10E);
    return x - (parseFloat('1e' + x) > num);
  }
  return num == 0 ? -Infinity : NaN;
};


/**
 * A tweaked variant of {@code Math.floor} which tolerates if the passed number
 * is infinitesimally smaller than the closest integer. It often happens with
 * the results of floating point calculations because of the finite precision
 * of the intermediate results. For example {@code Math.floor(Math.log(1000) /
 * Math.LN10) == 2}, not 3 as one would expect.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The largest integer less than or equal to {@code num}.
 */
goog.math.safeFloor = function(num, opt_epsilon) {
  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
  return Math.floor(num + (opt_epsilon || 2e-15));
};


/**
 * A tweaked variant of {@code Math.ceil}. See {@code goog.math.safeFloor} for
 * details.
 * @param {number} num A number.
 * @param {number=} opt_epsilon An infinitesimally small positive number, the
 *     rounding error to tolerate.
 * @return {number} The smallest integer greater than or equal to {@code num}.
 */
goog.math.safeCeil = function(num, opt_epsilon) {
  goog.asserts.assert(!goog.isDef(opt_epsilon) || opt_epsilon > 0);
  return Math.ceil(num - (opt_epsilon || 2e-15));
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Python style iteration utilities.
 * @author arv@google.com (Erik Arvidsson)
 */


goog.provide('goog.iter');
goog.provide('goog.iter.Iterable');
goog.provide('goog.iter.Iterator');
goog.provide('goog.iter.StopIteration');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.functions');
goog.require('goog.math');


/**
 * @typedef {goog.iter.Iterator|{length:number}|{__iterator__}}
 */
goog.iter.Iterable;


// For script engines that already support iterators.
if ('StopIteration' in goog.global) {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   */
  goog.iter.StopIteration = goog.global['StopIteration'];
} else {
  /**
   * Singleton Error object that is used to terminate iterations.
   * @type {Error}
   * @suppress {duplicate}
   */
  goog.iter.StopIteration = Error('StopIteration');
}



/**
 * Class/interface for iterators.  An iterator needs to implement a {@code next}
 * method and it needs to throw a {@code goog.iter.StopIteration} when the
 * iteration passes beyond the end.  Iterators have no {@code hasNext} method.
 * It is recommended to always use the helper functions to iterate over the
 * iterator or in case you are only targeting JavaScript 1.7 for in loops.
 * @constructor
 * @template VALUE
 */
goog.iter.Iterator = function() {};


/**
 * Returns the next value of the iteration.  This will throw the object
 * {@see goog.iter#StopIteration} when the iteration passes the end.
 * @return {VALUE} Any object or value.
 */
goog.iter.Iterator.prototype.next = function() {
  throw goog.iter.StopIteration;
};


/**
 * Returns the {@code Iterator} object itself.  This is used to implement
 * the iterator protocol in JavaScript 1.7
 * @param {boolean=} opt_keys  Whether to return the keys or values. Default is
 *     to only return the values.  This is being used by the for-in loop (true)
 *     and the for-each-in loop (false).  Even though the param gives a hint
 *     about what the iterator will return there is no guarantee that it will
 *     return the keys when true is passed.
 * @return {!goog.iter.Iterator.<VALUE>} The object itself.
 */
goog.iter.Iterator.prototype.__iterator__ = function(opt_keys) {
  return this;
};


/**
 * Returns an iterator that knows how to iterate over the values in the object.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable  If the
 *     object is an iterator it will be returned as is.  If the object has an
 *     {@code __iterator__} method that will be called to get the value
 *     iterator.  If the object is an array-like object we create an iterator
 *     for that.
 * @return {!goog.iter.Iterator.<VALUE>} An iterator that knows how to iterate
 *     over the values in {@code iterable}.
 * @template VALUE
 */
goog.iter.toIterator = function(iterable) {
  if (iterable instanceof goog.iter.Iterator) {
    return iterable;
  }
  if (typeof iterable.__iterator__ == 'function') {
    return iterable.__iterator__(false);
  }
  if (goog.isArrayLike(iterable)) {
    var i = 0;
    var newIter = new goog.iter.Iterator;
    newIter.next = function() {
      while (true) {
        if (i >= iterable.length) {
          throw goog.iter.StopIteration;
        }
        // Don't include deleted elements.
        if (!(i in iterable)) {
          i++;
          continue;
        }
        return iterable[i++];
      }
    };
    return newIter;
  }


  // TODO(arv): Should we fall back on goog.structs.getValues()?
  throw Error('Not implemented');
};


/**
 * Calls a function for each element in the iterator with the element of the
 * iterator passed as argument.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable  The iterator
 *     to iterate over. If the iterable is an object {@code toIterator} will be
 *     called on it.
 * @param {function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>)|
 *         function(this:THIS,number,undefined,goog.iter.Iterator.<VALUE>)} f
 *     The function to call for every element.  This function takes 3 arguments
 *     (the element, undefined, and the iterator) and the return value is
 *     irrelevant.  The reason for passing undefined as the second argument is
 *     so that the same function can be used in {@see goog.array#forEach} as
 *     well as others.
 * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
 *     {@code f}.
 * @template THIS, VALUE
 */
goog.iter.forEach = function(iterable, f, opt_obj) {
  if (goog.isArrayLike(iterable)) {
    /** @preserveTry */
    try {
      // NOTES: this passes the index number to the second parameter
      // of the callback contrary to the documentation above.
      goog.array.forEach(/** @type {goog.array.ArrayLike} */(iterable), f,
                         opt_obj);
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  } else {
    iterable = goog.iter.toIterator(iterable);
    /** @preserveTry */
    try {
      while (true) {
        f.call(opt_obj, iterable.next(), undefined, iterable);
      }
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
    }
  }
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns true adds the element to a new iterator.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every element. This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a boolean.
 *     If the return value is true the element will be included in the returned
 *     iterator.  If it is false the element is not included.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator in which only elements
 *     that passed the test are present.
 * @template THIS, VALUE
 */
goog.iter.filter = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (f.call(opt_obj, val, undefined, iterator)) {
        return val;
      }
    }
  };
  return newIter;
};


/**
 * Calls a function for every element in the iterator, and if the function
 * returns false adds the element to a new iterator.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every element. This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a boolean.
 *     If the return value is false the element will be included in the returned
 *     iterator.  If it is true the element is not included.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator in which only elements
 *     that did not pass the test are present.
 * @template THIS, VALUE
 */
goog.iter.filterFalse = function(iterable, f, opt_obj) {
  return goog.iter.filter(iterable, goog.functions.not(f), opt_obj);
};


/**
 * Creates a new iterator that returns the values in a range.  This function
 * can take 1, 2 or 3 arguments:
 * <pre>
 * range(5) same as range(0, 5, 1)
 * range(2, 5) same as range(2, 5, 1)
 * </pre>
 *
 * @param {number} startOrStop  The stop value if only one argument is provided.
 *     The start value if 2 or more arguments are provided.  If only one
 *     argument is used the start value is 0.
 * @param {number=} opt_stop  The stop value.  If left out then the first
 *     argument is used as the stop value.
 * @param {number=} opt_step  The number to increment with between each call to
 *     next.  This can be negative.
 * @return {!goog.iter.Iterator.<number>} A new iterator that returns the values
 *     in the range.
 */
goog.iter.range = function(startOrStop, opt_stop, opt_step) {
  var start = 0;
  var stop = startOrStop;
  var step = opt_step || 1;
  if (arguments.length > 1) {
    start = startOrStop;
    stop = opt_stop;
  }
  if (step == 0) {
    throw Error('Range step argument must not be zero');
  }

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    if (step > 0 && start >= stop || step < 0 && start <= stop) {
      throw goog.iter.StopIteration;
    }
    var rv = start;
    start += step;
    return rv;
  };
  return newIter;
};


/**
 * Joins the values in a iterator with a delimiter.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to get the values from.
 * @param {string} deliminator  The text to put between the values.
 * @return {string} The joined value string.
 * @template VALUE
 */
goog.iter.join = function(iterable, deliminator) {
  return goog.iter.toArray(iterable).join(deliminator);
};


/**
 * For every element in the iterator call a function and return a new iterator
 * with that value.
 *
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterator to iterate over.
 * @param {
 *     function(this:THIS,VALUE,undefined,!goog.iter.Iterator.<VALUE>):RESULT} f
 *     The function to call for every element.  This function takes 3 arguments
 *     (the element, undefined, and the iterator) and should return a new value.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<RESULT>} A new iterator that returns the
 *     results of applying the function to each element in the original
 *     iterator.
 * @template THIS, VALUE, RESULT
 */
goog.iter.map = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    var val = iterator.next();
    return f.call(opt_obj, val, undefined, iterator);
  };
  return newIter;
};


/**
 * Passes every element of an iterator into a function and accumulates the
 * result.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to iterate over.
 * @param {function(this:THIS,VALUE,VALUE):VALUE} f The function to call for
 *     every element. This function takes 2 arguments (the function's previous
 *     result or the initial value, and the value of the current element).
 *     function(previousValue, currentElement) : newValue.
 * @param {VALUE} val The initial value to pass into the function on the first
 *     call.
 * @param {THIS=} opt_obj  The object to be used as the value of 'this' within
 *     f.
 * @return {VALUE} Result of evaluating f repeatedly across the values of
 *     the iterator.
 * @template THIS, VALUE
 */
goog.iter.reduce = function(iterable, f, val, opt_obj) {
  var rval = val;
  goog.iter.forEach(iterable, function(val) {
    rval = f.call(opt_obj, rval, val);
  });
  return rval;
};


/**
 * Goes through the values in the iterator. Calls f for each of these, and if
 * any of them returns true, this returns true (without checking the rest). If
 * all return false this will return false.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if any value passes the test.
 * @template THIS, VALUE
 */
goog.iter.some = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return true;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return false;
};


/**
 * Goes through the values in the iterator. Calls f for each of these and if any
 * of them returns false this returns false (without checking the rest). If all
 * return true this will return true.
 *
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {boolean} true if every value passes the test.
 * @template THIS, VALUE
 */
goog.iter.every = function(iterable, f, opt_obj) {
  iterable = goog.iter.toIterator(iterable);
  /** @preserveTry */
  try {
    while (true) {
      if (!f.call(opt_obj, iterable.next(), undefined, iterable)) {
        return false;
      }
    }
  } catch (ex) {
    if (ex !== goog.iter.StopIteration) {
      throw ex;
    }
  }
  return true;
};


/**
 * Takes zero or more iterables and returns one iterator that will iterate over
 * them in the order chained.
 * @param {...!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator.<VALUE>} Returns a new iterator that will
 *     iterate over all the given iterables' contents.
 * @template VALUE
 */
goog.iter.chain = function(var_args) {
  var iterator = goog.iter.toIterator(arguments);
  var iter = new goog.iter.Iterator();
  var current = null;

  iter.next = function() {
    while (true) {
      if (current == null) {
        var it = iterator.next();
        current = goog.iter.toIterator(it);
      }
      try {
        return current.next();
      } catch (ex) {
        if (ex !== goog.iter.StopIteration) {
          throw ex;
        }
        current = null;
      }
    }
  };

  return iter;
};


/**
 * Takes a single iterable containing zero or more iterables and returns one
 * iterator that will iterate over each one in the order given.
 * @see http://docs.python.org/2/library/itertools.html#itertools.chain.from_iterable
 * @param {goog.iter.Iterable} iterable The iterable of iterables to chain.
 * @return {!goog.iter.Iterator.<VALUE>} Returns a new iterator that will
 *     iterate over all the contents of the iterables contained within
 *     {@code iterable}.
 * @template VALUE
 */
goog.iter.chainFromIterable = function(iterable) {
  return goog.iter.chain.apply(undefined, iterable);
};


/**
 * Builds a new iterator that iterates over the original, but skips elements as
 * long as a supplied function returns true.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that drops elements from
 *     the original iterator as long as {@code f} is true.
 * @template THIS, VALUE
 */
goog.iter.dropWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var dropping = true;
  newIter.next = function() {
    while (true) {
      var val = iterator.next();
      if (dropping && f.call(opt_obj, val, undefined, iterator)) {
        continue;
      } else {
        dropping = false;
      }
      return val;
    }
  };
  return newIter;
};


/**
 * Builds a new iterator that iterates over the original, but only as long as a
 * supplied function returns true.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     object.
 * @param {
 *     function(this:THIS,VALUE,undefined,goog.iter.Iterator.<VALUE>):boolean} f
 *     The function to call for every value. This function takes 3 arguments
 *     (the value, undefined, and the iterator) and should return a boolean.
 * @param {THIS=} opt_obj This is used as the 'this' object in f when called.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that keeps elements in
 *     the original iterator as long as the function is true.
 * @template THIS, VALUE
 */
goog.iter.takeWhile = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var newIter = new goog.iter.Iterator;
  var taking = true;
  newIter.next = function() {
    while (true) {
      if (taking) {
        var val = iterator.next();
        if (f.call(opt_obj, val, undefined, iterator)) {
          return val;
        } else {
          taking = false;
        }
      } else {
        throw goog.iter.StopIteration;
      }
    }
  };
  return newIter;
};


/**
 * Converts the iterator to an array
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterator
 *     to convert to an array.
 * @return {!Array.<VALUE>} An array of the elements the iterator iterates over.
 * @template VALUE
 */
goog.iter.toArray = function(iterable) {
  // Fast path for array-like.
  if (goog.isArrayLike(iterable)) {
    return goog.array.toArray(/** @type {!goog.array.ArrayLike} */(iterable));
  }
  iterable = goog.iter.toIterator(iterable);
  var array = [];
  goog.iter.forEach(iterable, function(val) {
    array.push(val);
  });
  return array;
};


/**
 * Iterates over two iterables and returns true if they contain the same
 * sequence of elements and have the same length.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable1 The first
 *     iterable object.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable2 The second
 *     iterable object.
 * @return {boolean} true if the iterables contain the same sequence of elements
 *     and have the same length.
 * @template VALUE
 */
goog.iter.equals = function(iterable1, iterable2) {
  var fillValue = {};
  var pairs = goog.iter.zipLongest(fillValue, iterable1, iterable2);
  return goog.iter.every(pairs, function(pair) {
    return pair[0] == pair[1];
  });
};


/**
 * Advances the iterator to the next position, returning the given default value
 * instead of throwing an exception if the iterator has no more entries.
 * @param {goog.iter.Iterator.<VALUE>|goog.iter.Iterable} iterable The iterable
 *     object.
 * @param {VALUE} defaultValue The value to return if the iterator is empty.
 * @return {VALUE} The next item in the iteration, or defaultValue if the
 *     iterator was empty.
 * @template VALUE
 */
goog.iter.nextOrValue = function(iterable, defaultValue) {
  try {
    return goog.iter.toIterator(iterable).next();
  } catch (e) {
    if (e != goog.iter.StopIteration) {
      throw e;
    }
    return defaultValue;
  }
};


/**
 * Cartesian product of zero or more sets.  Gives an iterator that gives every
 * combination of one element chosen from each set.  For example,
 * ([1, 2], [3, 4]) gives ([1, 3], [1, 4], [2, 3], [2, 4]).
 * @see http://docs.python.org/library/itertools.html#itertools.product
 * @param {...!goog.array.ArrayLike.<VALUE>} var_args Zero or more sets, as
 *     arrays.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} An iterator that gives each
 *     n-tuple (as an array).
 * @template VALUE
 */
goog.iter.product = function(var_args) {
  var someArrayEmpty = goog.array.some(arguments, function(arr) {
    return !arr.length;
  });

  // An empty set in a cartesian product gives an empty set.
  if (someArrayEmpty || !arguments.length) {
    return new goog.iter.Iterator();
  }

  var iter = new goog.iter.Iterator();
  var arrays = arguments;

  // The first indices are [0, 0, ...]
  var indicies = goog.array.repeat(0, arrays.length);

  iter.next = function() {

    if (indicies) {
      var retVal = goog.array.map(indicies, function(valueIndex, arrayIndex) {
        return arrays[arrayIndex][valueIndex];
      });

      // Generate the next-largest indices for the next call.
      // Increase the rightmost index. If it goes over, increase the next
      // rightmost (like carry-over addition).
      for (var i = indicies.length - 1; i >= 0; i--) {
        // Assertion prevents compiler warning below.
        goog.asserts.assert(indicies);
        if (indicies[i] < arrays[i].length - 1) {
          indicies[i]++;
          break;
        }

        // We're at the last indices (the last element of every array), so
        // the iteration is over on the next call.
        if (i == 0) {
          indicies = null;
          break;
        }
        // Reset the index in this column and loop back to increment the
        // next one.
        indicies[i] = 0;
      }
      return retVal;
    }

    throw goog.iter.StopIteration;
  };

  return iter;
};


/**
 * Create an iterator to cycle over the iterable's elements indefinitely.
 * For example, ([1, 2, 3]) would return : 1, 2, 3, 1, 2, 3, ...
 * @see: http://docs.python.org/library/itertools.html#itertools.cycle.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable object.
 * @return {!goog.iter.Iterator.<VALUE>} An iterator that iterates indefinitely
 *     over the values in {@code iterable}.
 * @template VALUE
 */
goog.iter.cycle = function(iterable) {
  var baseIterator = goog.iter.toIterator(iterable);

  // We maintain a cache to store the iterable elements as we iterate
  // over them. The cache is used to return elements once we have
  // iterated over the iterable once.
  var cache = [];
  var cacheIndex = 0;

  var iter = new goog.iter.Iterator();

  // This flag is set after the iterable is iterated over once
  var useCache = false;

  iter.next = function() {
    var returnElement = null;

    // Pull elements off the original iterator if not using cache
    if (!useCache) {
      try {
        // Return the element from the iterable
        returnElement = baseIterator.next();
        cache.push(returnElement);
        return returnElement;
      } catch (e) {
        // If an exception other than StopIteration is thrown
        // or if there are no elements to iterate over (the iterable was empty)
        // throw an exception
        if (e != goog.iter.StopIteration || goog.array.isEmpty(cache)) {
          throw e;
        }
        // set useCache to true after we know that a 'StopIteration' exception
        // was thrown and the cache is not empty (to handle the 'empty iterable'
        // use case)
        useCache = true;
      }
    }

    returnElement = cache[cacheIndex];
    cacheIndex = (cacheIndex + 1) % cache.length;

    return returnElement;
  };

  return iter;
};


/**
 * Creates an iterator that counts indefinitely from a starting value.
 * @see http://docs.python.org/2/library/itertools.html#itertools.count
 * @param {number=} opt_start The starting value. Default is 0.
 * @param {number=} opt_step The number to increment with between each call to
 *     next. Negative and floating point numbers are allowed. Default is 1.
 * @return {!goog.iter.Iterator.<number>} A new iterator that returns the values
 *     in the series.
 */
goog.iter.count = function(opt_start, opt_step) {
  var counter = opt_start || 0;
  var step = goog.isDef(opt_step) ? opt_step : 1;
  var iter = new goog.iter.Iterator();

  iter.next = function() {
    var returnValue = counter;
    counter += step;
    return returnValue;
  };

  return iter;
};


/**
 * Creates an iterator that returns the same object or value repeatedly.
 * @param {VALUE} value Any object or value to repeat.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that returns the
 *     repeated value.
 * @template VALUE
 */
goog.iter.repeat = function(value) {
  var iter = new goog.iter.Iterator();

  iter.next = goog.functions.constant(value);

  return iter;
};


/**
 * Creates an iterator that returns running totals from the numbers in
 * {@code iterable}. For example, the array {@code [1, 2, 3, 4, 5]} yields
 * {@code 1 -> 3 -> 6 -> 10 -> 15}.
 * @see http://docs.python.org/3.2/library/itertools.html#itertools.accumulate
 * @param {!goog.iter.Iterable.<number>} iterable The iterable of numbers to
 *     accumulate.
 * @return {!goog.iter.Iterator.<number>} A new iterator that returns the
 *     numbers in the series.
 */
goog.iter.accumulate = function(iterable) {
  var iterator = goog.iter.toIterator(iterable);
  var total = 0;
  var iter = new goog.iter.Iterator();

  iter.next = function() {
    total += iterator.next();
    return total;
  };

  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in {@code var_args}. Once the shortest iterable is
 * exhausted, subsequent calls to {@code next()} will throw
 * {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip
 * @param {...!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator that returns
 *     arrays of elements from the provided iterables.
 * @template VALUE
 */
goog.iter.zip = function(var_args) {
  var args = arguments;
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);
    iter.next = function() {
      var arr = goog.array.map(iterators, function(it) {
        return it.next();
      });
      return arr;
    };
  }

  return iter;
};


/**
 * Creates an iterator that returns arrays containing the ith elements from the
 * provided iterables. The returned arrays will be the same size as the number
 * of iterables given in {@code var_args}. Shorter iterables will be extended
 * with {@code fillValue}. Once the longest iterable is exhausted, subsequent
 * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.izip_longest
 * @param {VALUE} fillValue The object or value used to fill shorter iterables.
 * @param {...!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} var_args Any
 *     number of iterable objects.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator that returns
 *     arrays of elements from the provided iterables.
 * @template VALUE
 */
goog.iter.zipLongest = function(fillValue, var_args) {
  var args = goog.array.slice(arguments, 1);
  var iter = new goog.iter.Iterator();

  if (args.length > 0) {
    var iterators = goog.array.map(args, goog.iter.toIterator);

    iter.next = function() {
      var iteratorsHaveValues = false;  // false when all iterators are empty.
      var arr = goog.array.map(iterators, function(it) {
        var returnValue;
        try {
          returnValue = it.next();
          // Iterator had a value, so we've not exhausted the iterators.
          // Set flag accordingly.
          iteratorsHaveValues = true;
        } catch (ex) {
          if (ex !== goog.iter.StopIteration) {
            throw ex;
          }
          returnValue = fillValue;
        }
        return returnValue;
      });

      if (!iteratorsHaveValues) {
        throw goog.iter.StopIteration;
      }
      return arr;
    };
  }

  return iter;
};


/**
 * Creates an iterator that filters {@code iterable} based on a series of
 * {@code selectors}. On each call to {@code next()}, one item is taken from
 * both the {@code iterable} and {@code selectors} iterators. If the item from
 * {@code selectors} evaluates to true, the item from {@code iterable} is given.
 * Otherwise, it is skipped. Once either {@code iterable} or {@code selectors}
 * is exhausted, subsequent calls to {@code next()} will throw
 * {@code goog.iter.StopIteration}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.compress
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to filter.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} selectors An
 *     iterable of items to be evaluated in a boolean context to determine if
 *     the corresponding element in {@code iterable} should be included in the
 *     result.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator that returns the
 *     filtered values.
 * @template VALUE
 */
goog.iter.compress = function(iterable, selectors) {
  var selectorIterator = goog.iter.toIterator(selectors);

  return goog.iter.filter(iterable, function() {
    return !!selectorIterator.next();
  });
};



/**
 * Implements the {@code goog.iter.groupBy} iterator.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to group.
 * @param {function(...[VALUE]): KEY=} opt_keyFunc  Optional function for
 *     determining the key value for each group in the {@code iterable}. Default
 *     is the identity function.
 * @constructor
 * @extends {goog.iter.Iterator.<!Array>}
 * @template KEY, VALUE
 * @private
 */
goog.iter.GroupByIterator_ = function(iterable, opt_keyFunc) {

  /**
   * The iterable to group, coerced to an iterator.
   * @type {!goog.iter.Iterator}
   */
  this.iterator = goog.iter.toIterator(iterable);

  /**
   * A function for determining the key value for each element in the iterable.
   * If no function is provided, the identity function is used and returns the
   * element unchanged.
   * @type {function(...[VALUE]): KEY}
   */
  this.keyFunc = opt_keyFunc || goog.functions.identity;

  /**
   * The target key for determining the start of a group.
   * @type {KEY}
   */
  this.targetKey;

  /**
   * The current key visited during iteration.
   * @type {KEY}
   */
  this.currentKey;

  /**
   * The current value being added to the group.
   * @type {VALUE}
   */
  this.currentValue;
};
goog.inherits(goog.iter.GroupByIterator_, goog.iter.Iterator);


/** @override */
goog.iter.GroupByIterator_.prototype.next = function() {
  while (this.currentKey == this.targetKey) {
    this.currentValue = this.iterator.next();  // Exits on StopIteration
    this.currentKey = this.keyFunc(this.currentValue);
  }
  this.targetKey = this.currentKey;
  return [this.currentKey, this.groupItems_(this.targetKey)];
};


/**
 * Performs the grouping of objects using the given key.
 * @param {KEY} targetKey  The target key object for the group.
 * @return {!Array.<VALUE>} An array of grouped objects.
 * @private
 */
goog.iter.GroupByIterator_.prototype.groupItems_ = function(targetKey) {
  var arr = [];
  while (this.currentKey == targetKey) {
    arr.push(this.currentValue);
    try {
      this.currentValue = this.iterator.next();
    } catch (ex) {
      if (ex !== goog.iter.StopIteration) {
        throw ex;
      }
      break;
    }
    this.currentKey = this.keyFunc(this.currentValue);
  }
  return arr;
};


/**
 * Creates an iterator that returns arrays containing elements from the
 * {@code iterable} grouped by a key value. For iterables with repeated
 * elements (i.e. sorted according to a particular key function), this function
 * has a {@code uniq}-like effect. For example, grouping the array:
 * {@code [A, B, B, C, C, A]} produces
 * {@code [A, [A]], [B, [B, B]], [C, [C, C]], [A, [A]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.groupby
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to group.
 * @param {function(...[VALUE]): KEY=} opt_keyFunc  Optional function for
 *     determining the key value for each group in the {@code iterable}. Default
 *     is the identity function.
 * @return {!goog.iter.Iterator.<!Array>} A new iterator that returns arrays of
 *     consecutive key and groups.
 * @template KEY, VALUE
 */
goog.iter.groupBy = function(iterable, opt_keyFunc) {
  return new goog.iter.GroupByIterator_(iterable, opt_keyFunc);
};


/**
 * Gives an iterator that gives the result of calling the given function
 * <code>f</code> with the arguments taken from the next element from
 * <code>iterable</code> (the elements are expected to also be iterables).
 *
 * Similar to {@see goog.iter#map} but allows the function to accept multiple
 * arguments from the iterable.
 *
 * @param {!goog.iter.Iterable.<!goog.iter.Iterable>} iterable The iterable of
 *     iterables to iterate over.
 * @param {function(this:THIS,...[*]):RESULT} f The function to call for every
 *     element.  This function takes N+2 arguments, where N represents the
 *     number of items from the next element of the iterable. The two
 *     additional arguments passed to the function are undefined and the
 *     iterator itself. The function should return a new value.
 * @param {THIS=} opt_obj The object to be used as the value of 'this' within
 *     {@code f}.
 * @return {!goog.iter.Iterator.<RESULT>} A new iterator that returns the
 *     results of applying the function to each element in the original
 *     iterator.
 * @template THIS, RESULT
 */
goog.iter.starMap = function(iterable, f, opt_obj) {
  var iterator = goog.iter.toIterator(iterable);
  var iter = new goog.iter.Iterator();

  iter.next = function() {
    var args = goog.iter.toArray(iterator.next());
    return f.apply(opt_obj, goog.array.concat(args, undefined, iterator));
  };

  return iter;
};


/**
 * Returns an array of iterators each of which can iterate over the values in
 * {@code iterable} without advancing the others.
 * @see http://docs.python.org/2/library/itertools.html#itertools.tee
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to tee.
 * @param {number=} opt_num  The number of iterators to create. Default is 2.
 * @return {!Array.<goog.iter.Iterator.<VALUE>>} An array of iterators.
 * @template VALUE
 */
goog.iter.tee = function(iterable, opt_num) {
  var iterator = goog.iter.toIterator(iterable);
  var num = goog.isNumber(opt_num) ? opt_num : 2;
  var buffers = goog.array.map(goog.array.range(num), function() {
    return [];
  });

  var addNextIteratorValueToBuffers = function() {
    var val = iterator.next();
    goog.array.forEach(buffers, function(buffer) {
      buffer.push(val);
    });
  };

  var createIterator = function(buffer) {
    // Each tee'd iterator has an associated buffer (initially empty). When a
    // tee'd iterator's buffer is empty, it calls
    // addNextIteratorValueToBuffers(), adding the next value to all tee'd
    // iterators' buffers, and then returns that value. This allows each
    // iterator to be advanced independently.
    var iter = new goog.iter.Iterator();

    iter.next = function() {
      if (goog.array.isEmpty(buffer)) {
        addNextIteratorValueToBuffers();
      }
      goog.asserts.assert(!goog.array.isEmpty(buffer));
      return buffer.shift();
    };

    return iter;
  };

  return goog.array.map(buffers, createIterator);
};


/**
 * Creates an iterator that returns arrays containing a count and an element
 * obtained from the given {@code iterable}.
 * @see http://docs.python.org/2/library/functions.html#enumerate
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to enumerate.
 * @param {number=} opt_start  Optional starting value. Default is 0.
 * @return {!goog.iter.Iterator.<!Array>} A new iterator containing count/item
 *     pairs.
 * @template VALUE
 */
goog.iter.enumerate = function(iterable, opt_start) {
  return goog.iter.zip(goog.iter.count(opt_start), iterable);
};


/**
 * Creates an iterator that returns the first {@code limitSize} elements from an
 * iterable. If this number is greater than the number of elements in the
 * iterable, all the elements are returned.
 * @see http://goo.gl/V0sihp Inspired by the limit iterator in Guava.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to limit.
 * @param {number} limitSize  The maximum number of elements to return.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator containing
 *     {@code limitSize} elements.
 * @template VALUE
 */
goog.iter.limit = function(iterable, limitSize) {
  goog.asserts.assert(goog.math.isInt(limitSize) && limitSize >= 0);

  var iterator = goog.iter.toIterator(iterable);

  var iter = new goog.iter.Iterator();
  var remaining = limitSize;

  iter.next = function() {
    if (remaining-- > 0) {
      return iterator.next();
    }
    throw goog.iter.StopIteration;
  };

  return iter;
};


/**
 * Creates an iterator that is advanced {@code count} steps ahead. Consumed
 * values are silently discarded. If {@code count} is greater than the number
 * of elements in {@code iterable}, an empty iterator is returned. Subsequent
 * calls to {@code next()} will throw {@code goog.iter.StopIteration}.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to consume.
 * @param {number} count  The number of elements to consume from the iterator.
 * @return {!goog.iter.Iterator.<VALUE>} An iterator advanced zero or more steps
 *     ahead.
 * @template VALUE
 */
goog.iter.consume = function(iterable, count) {
  goog.asserts.assert(goog.math.isInt(count) && count >= 0);

  var iterator = goog.iter.toIterator(iterable);

  while (count-- > 0) {
    goog.iter.nextOrValue(iterator, null);
  }

  return iterator;
};


/**
 * Creates an iterator that returns a range of elements from an iterable.
 * Similar to {@see goog.array#slice} but does not support negative indexes.
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to slice.
 * @param {number} start  The index of the first element to return.
 * @param {number=} opt_end  The index after the last element to return. If
 *     defined, must be greater than or equal to {@code start}.
 * @return {!goog.iter.Iterator.<VALUE>} A new iterator containing a slice of
 *     the original.
 * @template VALUE
 */
goog.iter.slice = function(iterable, start, opt_end) {
  goog.asserts.assert(goog.math.isInt(start) && start >= 0);

  var iterator = goog.iter.consume(iterable, start);

  if (goog.isNumber(opt_end)) {
    goog.asserts.assert(
        goog.math.isInt(/** @type {number} */ (opt_end)) && opt_end >= start);
    iterator = goog.iter.limit(iterator, opt_end - start /* limitSize */);
  }

  return iterator;
};


/**
 * Checks an array for duplicate elements.
 * @param {Array.<VALUE>|goog.array.ArrayLike} arr The array to check for
 *     duplicates.
 * @return {boolean} True, if the array contains duplicates, false otherwise.
 * @private
 * @template VALUE
 */
// TODO(user): Consider moving this into goog.array as a public function.
goog.iter.hasDuplicates_ = function(arr) {
  var deduped = [];
  goog.array.removeDuplicates(arr, deduped);
  return arr.length != deduped.length;
};


/**
 * Creates an iterator that returns permutations of elements in
 * {@code iterable}.
 *
 * Permutations are obtained by taking the Cartesian product of
 * {@code opt_length} iterables and filtering out those with repeated
 * elements. For example, the permutations of {@code [1,2,3]} are
 * {@code [[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.permutations
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable from which to generate permutations.
 * @param {number=} opt_length Length of each permutation. If omitted, defaults
 *     to the length of {@code iterable}.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator containing the
 *     permutations of {@code iterable}.
 * @template VALUE
 */
goog.iter.permutations = function(iterable, opt_length) {
  var elements = goog.iter.toArray(iterable);
  var length = goog.isNumber(opt_length) ? opt_length : elements.length;

  var sets = goog.array.repeat(elements, length);
  var product = goog.iter.product.apply(undefined, sets);

  return goog.iter.filter(product, function(arr) {
    return !goog.iter.hasDuplicates_(arr);
  });
};


/**
 * Creates an iterator that returns combinations of elements from
 * {@code iterable}.
 *
 * Combinations are obtained by taking the {@see goog.iter#permutations} of
 * {@code iterable} and filtering those whose elements appear in the order they
 * are encountered in {@code iterable}. For example, the 3-length combinations
 * of {@code [0,1,2,3]} are {@code [[0,1,2], [0,1,3], [0,2,3], [1,2,3]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.combinations
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable from which to generate combinations.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator containing
 *     combinations from the {@code iterable}.
 * @template VALUE
 */
goog.iter.combinations = function(iterable, length) {
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.iter.range(elements.length);
  var indexIterator = goog.iter.permutations(indexes, length);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.next = function() {
    return goog.array.map(
        /** @type {!Array.<number>} */
        (sortedIndexIterator.next()), getIndexFromElements);
  };

  return iter;
};


/**
 * Creates an iterator that returns combinations of elements from
 * {@code iterable}, with repeated elements possible.
 *
 * Combinations are obtained by taking the Cartesian product of {@code length}
 * iterables and filtering those whose elements appear in the order they are
 * encountered in {@code iterable}. For example, the 2-length combinations of
 * {@code [1,2,3]} are {@code [[1,1], [1,2], [1,3], [2,2], [2,3], [3,3]]}.
 * @see http://docs.python.org/2/library/itertools.html#itertools.combinations_with_replacement
 * @see http://en.wikipedia.org/wiki/Combination#Number_of_combinations_with_repetition
 * @param {!goog.iter.Iterator.<VALUE>|!goog.iter.Iterable} iterable The
 *     iterable to combine.
 * @param {number} length The length of each combination.
 * @return {!goog.iter.Iterator.<!Array.<VALUE>>} A new iterator containing
 *     combinations from the {@code iterable}.
 * @template VALUE
 */
goog.iter.combinationsWithReplacement = function(iterable, length) {
  var elements = goog.iter.toArray(iterable);
  var indexes = goog.array.range(elements.length);
  var sets = goog.array.repeat(indexes, length);
  var indexIterator = goog.iter.product.apply(undefined, sets);
  // sortedIndexIterator will now give arrays of with the given length that
  // indicate what indexes into "elements" should be returned on each iteration.
  var sortedIndexIterator = goog.iter.filter(indexIterator, function(arr) {
    return goog.array.isSorted(arr);
  });

  var iter = new goog.iter.Iterator();

  function getIndexFromElements(index) {
    return elements[index];
  }

  iter.next = function() {
    return goog.array.map(
        /** @type {!Array.<number>} */
        (sortedIndexIterator.next()), getIndexFromElements);
  };

  return iter;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Hash Map.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author jonp@google.com (Jon Perlow) Optimized for IE6
 *
 * This file contains an implementation of a Map structure. It implements a lot
 * of the methods used in goog.structs so those functions work on hashes. This
 * is best suited for complex key types. For simple keys such as numbers and
 * strings, and where special names like __proto__ are not a concern, consider
 * using the lighter-weight utilities in goog.object.
 */


goog.provide('goog.structs.Map');

goog.require('goog.iter.Iterator');
goog.require('goog.iter.StopIteration');
goog.require('goog.object');



/**
 * Class for Hash Map datastructure.
 * @param {*=} opt_map Map or Object to initialize the map with.
 * @param {...*} var_args If 2 or more arguments are present then they
 *     will be used as key-value pairs.
 * @constructor
 * @template K, V
 */
goog.structs.Map = function(opt_map, var_args) {

  /**
   * Underlying JS object used to implement the map.
   * @private {!Object}
   */
  this.map_ = {};

  /**
   * An array of keys. This is necessary for two reasons:
   *   1. Iterating the keys using for (var key in this.map_) allocates an
   *      object for every key in IE which is really bad for IE6 GC perf.
   *   2. Without a side data structure, we would need to escape all the keys
   *      as that would be the only way we could tell during iteration if the
   *      key was an internal key or a property of the object.
   *
   * This array can contain deleted keys so it's necessary to check the map
   * as well to see if the key is still in the map (this doesn't require a
   * memory allocation in IE).
   * @private {!Array.<string>}
   */
  this.keys_ = [];

  /**
   * The number of key value pairs in the map.
   * @private {number}
   */
  this.count_ = 0;

  /**
   * Version used to detect changes while iterating.
   * @private {number}
   */
  this.version_ = 0;

  var argLength = arguments.length;

  if (argLength > 1) {
    if (argLength % 2) {
      throw Error('Uneven number of arguments');
    }
    for (var i = 0; i < argLength; i += 2) {
      this.set(arguments[i], arguments[i + 1]);
    }
  } else if (opt_map) {
    this.addAll(/** @type {Object} */ (opt_map));
  }
};


/**
 * @return {number} The number of key-value pairs in the map.
 */
goog.structs.Map.prototype.getCount = function() {
  return this.count_;
};


/**
 * Returns the values of the map.
 * @return {!Array.<V>} The values in the map.
 */
goog.structs.Map.prototype.getValues = function() {
  this.cleanupKeysArray_();

  var rv = [];
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    rv.push(this.map_[key]);
  }
  return rv;
};


/**
 * Returns the keys of the map.
 * @return {!Array.<string>} Array of string values.
 */
goog.structs.Map.prototype.getKeys = function() {
  this.cleanupKeysArray_();
  return /** @type {!Array.<string>} */ (this.keys_.concat());
};


/**
 * Whether the map contains the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the map contains the key.
 */
goog.structs.Map.prototype.containsKey = function(key) {
  return goog.structs.Map.hasKey_(this.map_, key);
};


/**
 * Whether the map contains the given value. This is O(n).
 * @param {V} val The value to check for.
 * @return {boolean} Whether the map contains the value.
 */
goog.structs.Map.prototype.containsValue = function(val) {
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    if (goog.structs.Map.hasKey_(this.map_, key) && this.map_[key] == val) {
      return true;
    }
  }
  return false;
};


/**
 * Whether this map is equal to the argument map.
 * @param {goog.structs.Map} otherMap The map against which to test equality.
 * @param {function(V, V): boolean=} opt_equalityFn Optional equality function
 *     to test equality of values. If not specified, this will test whether
 *     the values contained in each map are identical objects.
 * @return {boolean} Whether the maps are equal.
 */
goog.structs.Map.prototype.equals = function(otherMap, opt_equalityFn) {
  if (this === otherMap) {
    return true;
  }

  if (this.count_ != otherMap.getCount()) {
    return false;
  }

  var equalityFn = opt_equalityFn || goog.structs.Map.defaultEquals;

  this.cleanupKeysArray_();
  for (var key, i = 0; key = this.keys_[i]; i++) {
    if (!equalityFn(this.get(key), otherMap.get(key))) {
      return false;
    }
  }

  return true;
};


/**
 * Default equality test for values.
 * @param {*} a The first value.
 * @param {*} b The second value.
 * @return {boolean} Whether a and b reference the same object.
 */
goog.structs.Map.defaultEquals = function(a, b) {
  return a === b;
};


/**
 * @return {boolean} Whether the map is empty.
 */
goog.structs.Map.prototype.isEmpty = function() {
  return this.count_ == 0;
};


/**
 * Removes all key-value pairs from the map.
 */
goog.structs.Map.prototype.clear = function() {
  this.map_ = {};
  this.keys_.length = 0;
  this.count_ = 0;
  this.version_ = 0;
};


/**
 * Removes a key-value pair based on the key. This is O(logN) amortized due to
 * updating the keys array whenever the count becomes half the size of the keys
 * in the keys array.
 * @param {*} key  The key to remove.
 * @return {boolean} Whether object was removed.
 */
goog.structs.Map.prototype.remove = function(key) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    delete this.map_[key];
    this.count_--;
    this.version_++;

    // clean up the keys array if the threshhold is hit
    if (this.keys_.length > 2 * this.count_) {
      this.cleanupKeysArray_();
    }

    return true;
  }
  return false;
};


/**
 * Cleans up the temp keys array by removing entries that are no longer in the
 * map.
 * @private
 */
goog.structs.Map.prototype.cleanupKeysArray_ = function() {
  if (this.count_ != this.keys_.length) {
    // First remove keys that are no longer in the map.
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (goog.structs.Map.hasKey_(this.map_, key)) {
        this.keys_[destIndex++] = key;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }

  if (this.count_ != this.keys_.length) {
    // If the count still isn't correct, that means we have duplicates. This can
    // happen when the same key is added and removed multiple times. Now we have
    // to allocate one extra Object to remove the duplicates. This could have
    // been done in the first pass, but in the common case, we can avoid
    // allocating an extra object by only doing this when necessary.
    var seen = {};
    var srcIndex = 0;
    var destIndex = 0;
    while (srcIndex < this.keys_.length) {
      var key = this.keys_[srcIndex];
      if (!(goog.structs.Map.hasKey_(seen, key))) {
        this.keys_[destIndex++] = key;
        seen[key] = 1;
      }
      srcIndex++;
    }
    this.keys_.length = destIndex;
  }
};


/**
 * Returns the value for the given key.  If the key is not found and the default
 * value is not given this will return {@code undefined}.
 * @param {*} key The key to get the value for.
 * @param {DEFAULT=} opt_val The value to return if no item is found for the
 *     given key, defaults to undefined.
 * @return {V|DEFAULT} The value for the given key.
 * @template DEFAULT
 */
goog.structs.Map.prototype.get = function(key, opt_val) {
  if (goog.structs.Map.hasKey_(this.map_, key)) {
    return this.map_[key];
  }
  return opt_val;
};


/**
 * Adds a key-value pair to the map.
 * @param {*} key The key.
 * @param {V} value The value to add.
 * @return {*} Some subclasses return a value.
 */
goog.structs.Map.prototype.set = function(key, value) {
  if (!(goog.structs.Map.hasKey_(this.map_, key))) {
    this.count_++;
    this.keys_.push(key);
    // Only change the version if we add a new key.
    this.version_++;
  }
  this.map_[key] = value;
};


/**
 * Adds multiple key-value pairs from another goog.structs.Map or Object.
 * @param {Object} map  Object containing the data to add.
 */
goog.structs.Map.prototype.addAll = function(map) {
  var keys, values;
  if (map instanceof goog.structs.Map) {
    keys = map.getKeys();
    values = map.getValues();
  } else {
    keys = goog.object.getKeys(map);
    values = goog.object.getValues(map);
  }
  // we could use goog.array.forEach here but I don't want to introduce that
  // dependency just for this.
  for (var i = 0; i < keys.length; i++) {
    this.set(keys[i], values[i]);
  }
};


/**
 * Calls the given function on each entry in the map.
 * @param {function(this:T, V, K, goog.structs.Map.<K,V>)} f
 * @param {T=} opt_obj The value of "this" inside f.
 * @template T
 */
goog.structs.Map.prototype.forEach = function(f, opt_obj) {
  var keys = this.getKeys();
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var value = this.get(key);
    f.call(opt_obj, value, key, this);
  }
};


/**
 * Clones a map and returns a new map.
 * @return {!goog.structs.Map} A new map with the same key-value pairs.
 */
goog.structs.Map.prototype.clone = function() {
  return new goog.structs.Map(this);
};


/**
 * Returns a new map in which all the keys and values are interchanged
 * (keys become values and values become keys). If multiple keys map to the
 * same value, the chosen transposed value is implementation-dependent.
 *
 * It acts very similarly to {goog.object.transpose(Object)}.
 *
 * @return {!goog.structs.Map} The transposed map.
 */
goog.structs.Map.prototype.transpose = function() {
  var transposed = new goog.structs.Map();
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    var value = this.map_[key];
    transposed.set(value, key);
  }

  return transposed;
};


/**
 * @return {!Object} Object representation of the map.
 */
goog.structs.Map.prototype.toObject = function() {
  this.cleanupKeysArray_();
  var obj = {};
  for (var i = 0; i < this.keys_.length; i++) {
    var key = this.keys_[i];
    obj[key] = this.map_[key];
  }
  return obj;
};


/**
 * Returns an iterator that iterates over the keys in the map.  Removal of keys
 * while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the keys in the map.
 */
goog.structs.Map.prototype.getKeyIterator = function() {
  return this.__iterator__(true);
};


/**
 * Returns an iterator that iterates over the values in the map.  Removal of
 * keys while iterating might have undesired side effects.
 * @return {!goog.iter.Iterator} An iterator over the values in the map.
 */
goog.structs.Map.prototype.getValueIterator = function() {
  return this.__iterator__(false);
};


/**
 * Returns an iterator that iterates over the values or the keys in the map.
 * This throws an exception if the map was mutated since the iterator was
 * created.
 * @param {boolean=} opt_keys True to iterate over the keys. False to iterate
 *     over the values.  The default value is false.
 * @return {!goog.iter.Iterator} An iterator over the values or keys in the map.
 */
goog.structs.Map.prototype.__iterator__ = function(opt_keys) {
  // Clean up keys to minimize the risk of iterating over dead keys.
  this.cleanupKeysArray_();

  var i = 0;
  var keys = this.keys_;
  var map = this.map_;
  var version = this.version_;
  var selfObj = this;

  var newIter = new goog.iter.Iterator;
  newIter.next = function() {
    while (true) {
      if (version != selfObj.version_) {
        throw Error('The map has changed since the iterator was created');
      }
      if (i >= keys.length) {
        throw goog.iter.StopIteration;
      }
      var key = keys[i++];
      return opt_keys ? key : map[key];
    }
  };
  return newIter;
};


/**
 * Safe way to test for hasOwnProperty.  It even allows testing for
 * 'hasOwnProperty'.
 * @param {Object} obj The object to test for presence of the given key.
 * @param {*} key The key to check for.
 * @return {boolean} Whether the object has the key.
 * @private
 */
goog.structs.Map.hasKey_ = function(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Datastructure: Set.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @author pallosp@google.com (Peter Pallos)
 *
 * This class implements a set data structure. Adding and removing is O(1). It
 * supports both object and primitive values. Be careful because you can add
 * both 1 and new Number(1), because these are not the same. You can even add
 * multiple new Number(1) because these are not equal.
 */


goog.provide('goog.structs.Set');

goog.require('goog.structs');
goog.require('goog.structs.Collection');
goog.require('goog.structs.Map');



/**
 * A set that can contain both primitives and objects.  Adding and removing
 * elements is O(1).  Primitives are treated as identical if they have the same
 * type and convert to the same string.  Objects are treated as identical only
 * if they are references to the same object.  WARNING: A goog.structs.Set can
 * contain both 1 and (new Number(1)), because they are not the same.  WARNING:
 * Adding (new Number(1)) twice will yield two distinct elements, because they
 * are two different objects.  WARNING: Any object that is added to a
 * goog.structs.Set will be modified!  Because goog.getUid() is used to
 * identify objects, every object in the set will be mutated.
 * @param {Array.<T>|Object.<?,T>=} opt_values Initial values to start with.
 * @constructor
 * @implements {goog.structs.Collection.<T>}
 * @final
 * @template T
 */
goog.structs.Set = function(opt_values) {
  this.map_ = new goog.structs.Map;
  if (opt_values) {
    this.addAll(opt_values);
  }
};


/**
 * Obtains a unique key for an element of the set.  Primitives will yield the
 * same key if they have the same type and convert to the same string.  Object
 * references will yield the same key only if they refer to the same object.
 * @param {*} val Object or primitive value to get a key for.
 * @return {string} A unique key for this value/object.
 * @private
 */
goog.structs.Set.getKey_ = function(val) {
  var type = typeof val;
  if (type == 'object' && val || type == 'function') {
    return 'o' + goog.getUid(/** @type {Object} */ (val));
  } else {
    return type.substr(0, 1) + val;
  }
};


/**
 * @return {number} The number of elements in the set.
 * @override
 */
goog.structs.Set.prototype.getCount = function() {
  return this.map_.getCount();
};


/**
 * Add a primitive or an object to the set.
 * @param {T} element The primitive or object to add.
 * @override
 */
goog.structs.Set.prototype.add = function(element) {
  this.map_.set(goog.structs.Set.getKey_(element), element);
};


/**
 * Adds all the values in the given collection to this set.
 * @param {Array.<T>|goog.structs.Collection.<T>|Object.<?,T>} col A collection
 *     containing the elements to add.
 */
goog.structs.Set.prototype.addAll = function(col) {
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.add(values[i]);
  }
};


/**
 * Removes all values in the given collection from this set.
 * @param {Array.<T>|goog.structs.Collection.<T>|Object.<?,T>} col A collection
 *     containing the elements to remove.
 */
goog.structs.Set.prototype.removeAll = function(col) {
  var values = goog.structs.getValues(col);
  var l = values.length;
  for (var i = 0; i < l; i++) {
    this.remove(values[i]);
  }
};


/**
 * Removes the given element from this set.
 * @param {T} element The primitive or object to remove.
 * @return {boolean} Whether the element was found and removed.
 * @override
 */
goog.structs.Set.prototype.remove = function(element) {
  return this.map_.remove(goog.structs.Set.getKey_(element));
};


/**
 * Removes all elements from this set.
 */
goog.structs.Set.prototype.clear = function() {
  this.map_.clear();
};


/**
 * Tests whether this set is empty.
 * @return {boolean} True if there are no elements in this set.
 */
goog.structs.Set.prototype.isEmpty = function() {
  return this.map_.isEmpty();
};


/**
 * Tests whether this set contains the given element.
 * @param {T} element The primitive or object to test for.
 * @return {boolean} True if this set contains the given element.
 * @override
 */
goog.structs.Set.prototype.contains = function(element) {
  return this.map_.containsKey(goog.structs.Set.getKey_(element));
};


/**
 * Tests whether this set contains all the values in a given collection.
 * Repeated elements in the collection are ignored, e.g.  (new
 * goog.structs.Set([1, 2])).containsAll([1, 1]) is True.
 * @param {goog.structs.Collection.<T>|Object} col A collection-like object.
 * @return {boolean} True if the set contains all elements.
 */
goog.structs.Set.prototype.containsAll = function(col) {
  return goog.structs.every(col, this.contains, this);
};


/**
 * Finds all values that are present in both this set and the given collection.
 * @param {Array.<S>|Object.<?,S>} col A collection.
 * @return {!goog.structs.Set.<T|S>} A new set containing all the values
 *     (primitives or objects) present in both this set and the given
 *     collection.
 * @template S
 */
goog.structs.Set.prototype.intersection = function(col) {
  var result = new goog.structs.Set();

  var values = goog.structs.getValues(col);
  for (var i = 0; i < values.length; i++) {
    var value = values[i];
    if (this.contains(value)) {
      result.add(value);
    }
  }

  return result;
};


/**
 * Finds all values that are present in this set and not in the given
 * collection.
 * @param {Array.<T>|goog.structs.Collection.<T>|Object.<?,T>} col A collection.
 * @return {!goog.structs.Set} A new set containing all the values
 *     (primitives or objects) present in this set but not in the given
 *     collection.
 */
goog.structs.Set.prototype.difference = function(col) {
  var result = this.clone();
  result.removeAll(col);
  return result;
};


/**
 * Returns an array containing all the elements in this set.
 * @return {!Array.<T>} An array containing all the elements in this set.
 */
goog.structs.Set.prototype.getValues = function() {
  return this.map_.getValues();
};


/**
 * Creates a shallow clone of this set.
 * @return {!goog.structs.Set.<T>} A new set containing all the same elements as
 *     this set.
 */
goog.structs.Set.prototype.clone = function() {
  return new goog.structs.Set(this);
};


/**
 * Tests whether the given collection consists of the same elements as this set,
 * regardless of order, without repetition.  Primitives are treated as equal if
 * they have the same type and convert to the same string; objects are treated
 * as equal if they are references to the same object.  This operation is O(n).
 * @param {goog.structs.Collection.<T>|Object} col A collection.
 * @return {boolean} True if the given collection consists of the same elements
 *     as this set, regardless of order, without repetition.
 */
goog.structs.Set.prototype.equals = function(col) {
  return this.getCount() == goog.structs.getCount(col) && this.isSubsetOf(col);
};


/**
 * Tests whether the given collection contains all the elements in this set.
 * Primitives are treated as equal if they have the same type and convert to the
 * same string; objects are treated as equal if they are references to the same
 * object.  This operation is O(n).
 * @param {goog.structs.Collection.<T>|Object} col A collection.
 * @return {boolean} True if this set is a subset of the given collection.
 */
goog.structs.Set.prototype.isSubsetOf = function(col) {
  var colCount = goog.structs.getCount(col);
  if (this.getCount() > colCount) {
    return false;
  }
  // TODO(user) Find the minimal collection size where the conversion makes
  // the contains() method faster.
  if (!(col instanceof goog.structs.Set) && colCount > 5) {
    // Convert to a goog.structs.Set so that goog.structs.contains runs in
    // O(1) time instead of O(n) time.
    col = new goog.structs.Set(col);
  }
  return goog.structs.every(this, function(value) {
    return goog.structs.contains(col, value);
  });
};


/**
 * Returns an iterator that iterates over the elements in this set.
 * @param {boolean=} opt_keys This argument is ignored.
 * @return {!goog.iter.Iterator} An iterator over the elements in this set.
 */
goog.structs.Set.prototype.__iterator__ = function(opt_keys) {
  return this.map_.__iterator__(false);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Logging and debugging utilities.
 *
 * @see ../demos/debug.html
 */

goog.provide('goog.debug');

goog.require('goog.array');
goog.require('goog.string');
goog.require('goog.structs.Set');
goog.require('goog.userAgent');


/** @define {boolean} Whether logging should be enabled. */
goog.define('goog.debug.LOGGING_ENABLED', goog.DEBUG);


/**
 * Catches onerror events fired by windows and similar objects.
 * @param {function(Object)} logFunc The function to call with the error
 *    information.
 * @param {boolean=} opt_cancel Whether to stop the error from reaching the
 *    browser.
 * @param {Object=} opt_target Object that fires onerror events.
 */
goog.debug.catchErrors = function(logFunc, opt_cancel, opt_target) {
  var target = opt_target || goog.global;
  var oldErrorHandler = target.onerror;
  var retVal = !!opt_cancel;

  // Chrome interprets onerror return value backwards (http://crbug.com/92062)
  // until it was fixed in webkit revision r94061 (Webkit 535.3). This
  // workaround still needs to be skipped in Safari after the webkit change
  // gets pushed out in Safari.
  // See https://bugs.webkit.org/show_bug.cgi?id=67119
  if (goog.userAgent.WEBKIT &&
      !goog.userAgent.isVersionOrHigher('535.3')) {
    retVal = !retVal;
  }

  /**
   * New onerror handler for this target. This onerror handler follows the spec
   * according to
   * http://www.whatwg.org/specs/web-apps/current-work/#runtime-script-errors
   * The spec was changed in August 2013 to support receiving column information
   * and an error object for all scripts on the same origin or cross origin
   * scripts with the proper headers. See
   * https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
   *
   * @param {string} message The error message. For cross-origin errors, this
   *     will be scrubbed to just "Script error.". For new browsers that have
   *     updated to follow the latest spec, errors that come from origins that
   *     have proper cross origin headers will not be scrubbed.
   * @param {string} url The URL of the script that caused the error. The URL
   *     will be scrubbed to "" for cross origin scripts unless the script has
   *     proper cross origin headers and the browser has updated to the latest
   *     spec.
   * @param {number} line The line number in the script that the error
   *     occurred on.
   * @param {number=} opt_col The optional column number that the error
   *     occurred on. Only browsers that have updated to the latest spec will
   *     include this.
   * @param {Error=} opt_error The optional actual error object for this
   *     error that should include the stack. Only browsers that have updated
   *     to the latest spec will inlude this parameter.
   * @return {boolean} Whether to prevent the error from reaching the browser.
   */
  target.onerror = function(message, url, line, opt_col, opt_error) {
    if (oldErrorHandler) {
      oldErrorHandler(message, url, line, opt_col, opt_error);
    }
    logFunc({
      message: message,
      fileName: url,
      line: line,
      col: opt_col,
      error: opt_error
    });
    return retVal;
  };
};


/**
 * Creates a string representing an object and all its properties.
 * @param {Object|null|undefined} obj Object to expose.
 * @param {boolean=} opt_showFn Show the functions as well as the properties,
 *     default is false.
 * @return {string} The string representation of {@code obj}.
 */
goog.debug.expose = function(obj, opt_showFn) {
  if (typeof obj == 'undefined') {
    return 'undefined';
  }
  if (obj == null) {
    return 'NULL';
  }
  var str = [];

  for (var x in obj) {
    if (!opt_showFn && goog.isFunction(obj[x])) {
      continue;
    }
    var s = x + ' = ';
    /** @preserveTry */
    try {
      s += obj[x];
    } catch (e) {
      s += '*** ' + e + ' ***';
    }
    str.push(s);
  }
  return str.join('\n');
};


/**
 * Creates a string representing a given primitive or object, and for an
 * object, all its properties and nested objects.  WARNING: If an object is
 * given, it and all its nested objects will be modified.  To detect reference
 * cycles, this method identifies objects using goog.getUid() which mutates the
 * object.
 * @param {*} obj Object to expose.
 * @param {boolean=} opt_showFn Also show properties that are functions (by
 *     default, functions are omitted).
 * @return {string} A string representation of {@code obj}.
 */
goog.debug.deepExpose = function(obj, opt_showFn) {
  var str = [];

  var helper = function(obj, space, parentSeen) {
    var nestspace = space + '  ';
    var seen = new goog.structs.Set(parentSeen);

    var indentMultiline = function(str) {
      return str.replace(/\n/g, '\n' + space);
    };

    /** @preserveTry */
    try {
      if (!goog.isDef(obj)) {
        str.push('undefined');
      } else if (goog.isNull(obj)) {
        str.push('NULL');
      } else if (goog.isString(obj)) {
        str.push('"' + indentMultiline(obj) + '"');
      } else if (goog.isFunction(obj)) {
        str.push(indentMultiline(String(obj)));
      } else if (goog.isObject(obj)) {
        if (seen.contains(obj)) {
          str.push('*** reference loop detected ***');
        } else {
          seen.add(obj);
          str.push('{');
          for (var x in obj) {
            if (!opt_showFn && goog.isFunction(obj[x])) {
              continue;
            }
            str.push('\n');
            str.push(nestspace);
            str.push(x + ' = ');
            helper(obj[x], nestspace, seen);
          }
          str.push('\n' + space + '}');
        }
      } else {
        str.push(obj);
      }
    } catch (e) {
      str.push('*** ' + e + ' ***');
    }
  };

  helper(obj, '', new goog.structs.Set());
  return str.join('');
};


/**
 * Recursively outputs a nested array as a string.
 * @param {Array} arr The array.
 * @return {string} String representing nested array.
 */
goog.debug.exposeArray = function(arr) {
  var str = [];
  for (var i = 0; i < arr.length; i++) {
    if (goog.isArray(arr[i])) {
      str.push(goog.debug.exposeArray(arr[i]));
    } else {
      str.push(arr[i]);
    }
  }
  return '[ ' + str.join(', ') + ' ]';
};


/**
 * Exposes an exception that has been caught by a try...catch and outputs the
 * error with a stack trace.
 * @param {Object} err Error object or string.
 * @param {Function=} opt_fn Optional function to start stack trace from.
 * @return {string} Details of exception.
 */
goog.debug.exposeException = function(err, opt_fn) {
  /** @preserveTry */
  try {
    var e = goog.debug.normalizeErrorObject(err);

    // Create the error message
    var error = 'Message: ' + goog.string.htmlEscape(e.message) +
        '\nUrl: <a href="view-source:' + e.fileName + '" target="_new">' +
        e.fileName + '</a>\nLine: ' + e.lineNumber + '\n\nBrowser stack:\n' +
        goog.string.htmlEscape(e.stack + '-> ') +
        '[end]\n\nJS stack traversal:\n' + goog.string.htmlEscape(
            goog.debug.getStacktrace(opt_fn) + '-> ');
    return error;
  } catch (e2) {
    return 'Exception trying to expose exception! You win, we lose. ' + e2;
  }
};


/**
 * Normalizes the error/exception object between browsers.
 * @param {Object} err Raw error object.
 * @return {!Object} Normalized error object.
 */
goog.debug.normalizeErrorObject = function(err) {
  var href = goog.getObjectByName('window.location.href');
  if (goog.isString(err)) {
    return {
      'message': err,
      'name': 'Unknown error',
      'lineNumber': 'Not available',
      'fileName': href,
      'stack': 'Not available'
    };
  }

  var lineNumber, fileName;
  var threwError = false;

  try {
    lineNumber = err.lineNumber || err.line || 'Not available';
  } catch (e) {
    // Firefox 2 sometimes throws an error when accessing 'lineNumber':
    // Message: Permission denied to get property UnnamedClass.lineNumber
    lineNumber = 'Not available';
    threwError = true;
  }

  try {
    fileName = err.fileName || err.filename || err.sourceURL ||
        // $googDebugFname may be set before a call to eval to set the filename
        // that the eval is supposed to present.
        goog.global['$googDebugFname'] || href;
  } catch (e) {
    // Firefox 2 may also throw an error when accessing 'filename'.
    fileName = 'Not available';
    threwError = true;
  }

  // The IE Error object contains only the name and the message.
  // The Safari Error object uses the line and sourceURL fields.
  if (threwError || !err.lineNumber || !err.fileName || !err.stack ||
      !err.message || !err.name) {
    return {
      'message': err.message || 'Not available',
      'name': err.name || 'UnknownError',
      'lineNumber': lineNumber,
      'fileName': fileName,
      'stack': err.stack || 'Not available'
    };
  }

  // Standards error object
  return err;
};


/**
 * Converts an object to an Error if it's a String,
 * adds a stacktrace if there isn't one,
 * and optionally adds an extra message.
 * @param {Error|string} err  the original thrown object or string.
 * @param {string=} opt_message  optional additional message to add to the
 *     error.
 * @return {!Error} If err is a string, it is used to create a new Error,
 *     which is enhanced and returned.  Otherwise err itself is enhanced
 *     and returned.
 */
goog.debug.enhanceError = function(err, opt_message) {
  var error;
  if (typeof err == 'string') {
    error = Error(err);
    if (Error.captureStackTrace) {
      // Trim this function off the call stack, if we can.
      Error.captureStackTrace(error, goog.debug.enhanceError);
    }
  } else {
    error = err;
  }

  if (!error.stack) {
    error.stack = goog.debug.getStacktrace(goog.debug.enhanceError);
  }
  if (opt_message) {
    // find the first unoccupied 'messageX' property
    var x = 0;
    while (error['message' + x]) {
      ++x;
    }
    error['message' + x] = String(opt_message);
  }
  return error;
};


/**
 * Gets the current stack trace. Simple and iterative - doesn't worry about
 * catching circular references or getting the args.
 * @param {number=} opt_depth Optional maximum depth to trace back to.
 * @return {string} A string with the function names of all functions in the
 *     stack, separated by \n.
 * @suppress {es5Strict}
 */
goog.debug.getStacktraceSimple = function(opt_depth) {
  if (goog.STRICT_MODE_COMPATIBLE) {
    var stack = goog.debug.getNativeStackTrace_(goog.debug.getStacktraceSimple);
    if (stack) {
      return stack;
    }
    // NOTE: browsers that have strict mode support also have native "stack"
    // properties.  Fall-through for legacy browser support.
  }

  var sb = [];
  var fn = arguments.callee.caller;
  var depth = 0;

  while (fn && (!opt_depth || depth < opt_depth)) {
    sb.push(goog.debug.getFunctionName(fn));
    sb.push('()\n');
    /** @preserveTry */
    try {
      fn = fn.caller;
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
      break;
    }
    depth++;
    if (depth >= goog.debug.MAX_STACK_DEPTH) {
      sb.push('[...long stack...]');
      break;
    }
  }
  if (opt_depth && depth >= opt_depth) {
    sb.push('[...reached max depth limit...]');
  } else {
    sb.push('[end]');
  }

  return sb.join('');
};


/**
 * Max length of stack to try and output
 * @type {number}
 */
goog.debug.MAX_STACK_DEPTH = 50;


/**
 * @param {Function} fn The function to start getting the trace from.
 * @return {?string}
 * @private
 */
goog.debug.getNativeStackTrace_ = function(fn) {
  var tempErr = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(tempErr, fn);
    return String(tempErr.stack);
  } else {
    // IE10, only adds stack traces when an exception is thrown.
    try {
      throw tempErr;
    } catch (e) {
      tempErr = e;
    }
    var stack = tempErr.stack;
    if (stack) {
      return String(stack);
    }
  }
  return null;
};


/**
 * Gets the current stack trace, either starting from the caller or starting
 * from a specified function that's currently on the call stack.
 * @param {Function=} opt_fn Optional function to start getting the trace from.
 *     If not provided, defaults to the function that called this.
 * @return {string} Stack trace.
 * @suppress {es5Strict}
 */
goog.debug.getStacktrace = function(opt_fn) {
  var stack;
  if (goog.STRICT_MODE_COMPATIBLE) {
    // Try to get the stack trace from the environment if it is available.
    var contextFn = opt_fn || goog.debug.getStacktrace;
    stack = goog.debug.getNativeStackTrace_(contextFn);
  }
  if (!stack) {
    // NOTE: browsers that have strict mode support also have native "stack"
    // properties. This function will throw in strict mode.
    stack = goog.debug.getStacktraceHelper_(
        opt_fn || arguments.callee.caller, []);
  }
  return stack;
};


/**
 * Private helper for getStacktrace().
 * @param {Function} fn Function to start getting the trace from.
 * @param {Array} visited List of functions visited so far.
 * @return {string} Stack trace starting from function fn.
 * @suppress {es5Strict}
 * @private
 */
goog.debug.getStacktraceHelper_ = function(fn, visited) {
  var sb = [];

  // Circular reference, certain functions like bind seem to cause a recursive
  // loop so we need to catch circular references
  if (goog.array.contains(visited, fn)) {
    sb.push('[...circular reference...]');

  // Traverse the call stack until function not found or max depth is reached
  } else if (fn && visited.length < goog.debug.MAX_STACK_DEPTH) {
    sb.push(goog.debug.getFunctionName(fn) + '(');
    var args = fn.arguments;
    // Args may be null for some special functions such as host objects or eval.
    for (var i = 0; args && i < args.length; i++) {
      if (i > 0) {
        sb.push(', ');
      }
      var argDesc;
      var arg = args[i];
      switch (typeof arg) {
        case 'object':
          argDesc = arg ? 'object' : 'null';
          break;

        case 'string':
          argDesc = arg;
          break;

        case 'number':
          argDesc = String(arg);
          break;

        case 'boolean':
          argDesc = arg ? 'true' : 'false';
          break;

        case 'function':
          argDesc = goog.debug.getFunctionName(arg);
          argDesc = argDesc ? argDesc : '[fn]';
          break;

        case 'undefined':
        default:
          argDesc = typeof arg;
          break;
      }

      if (argDesc.length > 40) {
        argDesc = argDesc.substr(0, 40) + '...';
      }
      sb.push(argDesc);
    }
    visited.push(fn);
    sb.push(')\n');
    /** @preserveTry */
    try {
      sb.push(goog.debug.getStacktraceHelper_(fn.caller, visited));
    } catch (e) {
      sb.push('[exception trying to get caller]\n');
    }

  } else if (fn) {
    sb.push('[...long stack...]');
  } else {
    sb.push('[end]');
  }
  return sb.join('');
};


/**
 * Set a custom function name resolver.
 * @param {function(Function): string} resolver Resolves functions to their
 *     names.
 */
goog.debug.setFunctionResolver = function(resolver) {
  goog.debug.fnNameResolver_ = resolver;
};


/**
 * Gets a function name
 * @param {Function} fn Function to get name of.
 * @return {string} Function's name.
 */
goog.debug.getFunctionName = function(fn) {
  if (goog.debug.fnNameCache_[fn]) {
    return goog.debug.fnNameCache_[fn];
  }
  if (goog.debug.fnNameResolver_) {
    var name = goog.debug.fnNameResolver_(fn);
    if (name) {
      goog.debug.fnNameCache_[fn] = name;
      return name;
    }
  }

  // Heuristically determine function name based on code.
  var functionSource = String(fn);
  if (!goog.debug.fnNameCache_[functionSource]) {
    var matches = /function ([^\(]+)/.exec(functionSource);
    if (matches) {
      var method = matches[1];
      goog.debug.fnNameCache_[functionSource] = method;
    } else {
      goog.debug.fnNameCache_[functionSource] = '[Anonymous]';
    }
  }

  return goog.debug.fnNameCache_[functionSource];
};


/**
 * Makes whitespace visible by replacing it with printable characters.
 * This is useful in finding diffrences between the expected and the actual
 * output strings of a testcase.
 * @param {string} string whose whitespace needs to be made visible.
 * @return {string} string whose whitespace is made visible.
 */
goog.debug.makeWhitespaceVisible = function(string) {
  return string.replace(/ /g, '[_]')
      .replace(/\f/g, '[f]')
      .replace(/\n/g, '[n]\n')
      .replace(/\r/g, '[r]')
      .replace(/\t/g, '[t]');
};


/**
 * Hash map for storing function names that have already been looked up.
 * @type {Object}
 * @private
 */
goog.debug.fnNameCache_ = {};


/**
 * Resolves functions to their names.  Resolved function names will be cached.
 * @type {function(Function):string}
 * @private
 */
goog.debug.fnNameResolver_;
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the LogRecord class. Please minimize
 * dependencies this file has on other closure classes as any dependency it
 * takes won't be able to use the logging infrastructure.
 *
 */

goog.provide('goog.debug.LogRecord');



/**
 * LogRecord objects are used to pass logging requests between
 * the logging framework and individual log Handlers.
 * @constructor
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @param {number=} opt_time Time this log record was created if other than now.
 *     If 0, we use #goog.now.
 * @param {number=} opt_sequenceNumber Sequence number of this log record. This
 *     should only be passed in when restoring a log record from persistence.
 */
goog.debug.LogRecord = function(level, msg, loggerName,
    opt_time, opt_sequenceNumber) {
  this.reset(level, msg, loggerName, opt_time, opt_sequenceNumber);
};


/**
 * Time the LogRecord was created.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.prototype.time_;


/**
 * Level of the LogRecord
 * @type {goog.debug.Logger.Level}
 * @private
 */
goog.debug.LogRecord.prototype.level_;


/**
 * Message associated with the record
 * @type {string}
 * @private
 */
goog.debug.LogRecord.prototype.msg_;


/**
 * Name of the logger that created the record.
 * @type {string}
 * @private
 */
goog.debug.LogRecord.prototype.loggerName_;


/**
 * Sequence number for the LogRecord. Each record has a unique sequence number
 * that is greater than all log records created before it.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.prototype.sequenceNumber_ = 0;


/**
 * Exception associated with the record
 * @type {Object}
 * @private
 */
goog.debug.LogRecord.prototype.exception_ = null;


/**
 * Exception text associated with the record
 * @type {?string}
 * @private
 */
goog.debug.LogRecord.prototype.exceptionText_ = null;


/**
 * @define {boolean} Whether to enable log sequence numbers.
 */
goog.define('goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS', true);


/**
 * A sequence counter for assigning increasing sequence numbers to LogRecord
 * objects.
 * @type {number}
 * @private
 */
goog.debug.LogRecord.nextSequenceNumber_ = 0;


/**
 * Sets all fields of the log record.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @param {number=} opt_time Time this log record was created if other than now.
 *     If 0, we use #goog.now.
 * @param {number=} opt_sequenceNumber Sequence number of this log record. This
 *     should only be passed in when restoring a log record from persistence.
 */
goog.debug.LogRecord.prototype.reset = function(level, msg, loggerName,
    opt_time, opt_sequenceNumber) {
  if (goog.debug.LogRecord.ENABLE_SEQUENCE_NUMBERS) {
    this.sequenceNumber_ = typeof opt_sequenceNumber == 'number' ?
        opt_sequenceNumber : goog.debug.LogRecord.nextSequenceNumber_++;
  }

  this.time_ = opt_time || goog.now();
  this.level_ = level;
  this.msg_ = msg;
  this.loggerName_ = loggerName;
  delete this.exception_;
  delete this.exceptionText_;
};


/**
 * Get the source Logger's name.
 *
 * @return {string} source logger name (may be null).
 */
goog.debug.LogRecord.prototype.getLoggerName = function() {
  return this.loggerName_;
};


/**
 * Get the exception that is part of the log record.
 *
 * @return {Object} the exception.
 */
goog.debug.LogRecord.prototype.getException = function() {
  return this.exception_;
};


/**
 * Set the exception that is part of the log record.
 *
 * @param {Object} exception the exception.
 */
goog.debug.LogRecord.prototype.setException = function(exception) {
  this.exception_ = exception;
};


/**
 * Get the exception text that is part of the log record.
 *
 * @return {?string} Exception text.
 */
goog.debug.LogRecord.prototype.getExceptionText = function() {
  return this.exceptionText_;
};


/**
 * Set the exception text that is part of the log record.
 *
 * @param {string} text The exception text.
 */
goog.debug.LogRecord.prototype.setExceptionText = function(text) {
  this.exceptionText_ = text;
};


/**
 * Get the source Logger's name.
 *
 * @param {string} loggerName source logger name (may be null).
 */
goog.debug.LogRecord.prototype.setLoggerName = function(loggerName) {
  this.loggerName_ = loggerName;
};


/**
 * Get the logging message level, for example Level.SEVERE.
 * @return {goog.debug.Logger.Level} the logging message level.
 */
goog.debug.LogRecord.prototype.getLevel = function() {
  return this.level_;
};


/**
 * Set the logging message level, for example Level.SEVERE.
 * @param {goog.debug.Logger.Level} level the logging message level.
 */
goog.debug.LogRecord.prototype.setLevel = function(level) {
  this.level_ = level;
};


/**
 * Get the "raw" log message, before localization or formatting.
 *
 * @return {string} the raw message string.
 */
goog.debug.LogRecord.prototype.getMessage = function() {
  return this.msg_;
};


/**
 * Set the "raw" log message, before localization or formatting.
 *
 * @param {string} msg the raw message string.
 */
goog.debug.LogRecord.prototype.setMessage = function(msg) {
  this.msg_ = msg;
};


/**
 * Get event time in milliseconds since 1970.
 *
 * @return {number} event time in millis since 1970.
 */
goog.debug.LogRecord.prototype.getMillis = function() {
  return this.time_;
};


/**
 * Set event time in milliseconds since 1970.
 *
 * @param {number} time event time in millis since 1970.
 */
goog.debug.LogRecord.prototype.setMillis = function(time) {
  this.time_ = time;
};


/**
 * Get the sequence number.
 * <p>
 * Sequence numbers are normally assigned in the LogRecord
 * constructor, which assigns unique sequence numbers to
 * each new LogRecord in increasing order.
 * @return {number} the sequence number.
 */
goog.debug.LogRecord.prototype.getSequenceNumber = function() {
  return this.sequenceNumber_;
};

// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A buffer for log records. The purpose of this is to improve
 * logging performance by re-using old objects when the buffer becomes full and
 * to eliminate the need for each app to implement their own log buffer. The
 * disadvantage to doing this is that log handlers cannot maintain references to
 * log records and expect that they are not overwriten at a later point.
 *
 * @author agrieve@google.com (Andrew Grieve)
 */

goog.provide('goog.debug.LogBuffer');

goog.require('goog.asserts');
goog.require('goog.debug.LogRecord');



/**
 * Creates the log buffer.
 * @constructor
 * @final
 */
goog.debug.LogBuffer = function() {
  goog.asserts.assert(goog.debug.LogBuffer.isBufferingEnabled(),
      'Cannot use goog.debug.LogBuffer without defining ' +
      'goog.debug.LogBuffer.CAPACITY.');
  this.clear();
};


/**
 * A static method that always returns the same instance of LogBuffer.
 * @return {!goog.debug.LogBuffer} The LogBuffer singleton instance.
 */
goog.debug.LogBuffer.getInstance = function() {
  if (!goog.debug.LogBuffer.instance_) {
    // This function is written with the return statement after the assignment
    // to avoid the jscompiler StripCode bug described in http://b/2608064.
    // After that bug is fixed this can be refactored.
    goog.debug.LogBuffer.instance_ = new goog.debug.LogBuffer();
  }
  return goog.debug.LogBuffer.instance_;
};


/**
 * @define {number} The number of log records to buffer. 0 means disable
 * buffering.
 */
goog.define('goog.debug.LogBuffer.CAPACITY', 0);


/**
 * The array to store the records.
 * @type {!Array.<!goog.debug.LogRecord|undefined>}
 * @private
 */
goog.debug.LogBuffer.prototype.buffer_;


/**
 * The index of the most recently added record or -1 if there are no records.
 * @type {number}
 * @private
 */
goog.debug.LogBuffer.prototype.curIndex_;


/**
 * Whether the buffer is at capacity.
 * @type {boolean}
 * @private
 */
goog.debug.LogBuffer.prototype.isFull_;


/**
 * Adds a log record to the buffer, possibly overwriting the oldest record.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {string} loggerName The name of the source logger.
 * @return {!goog.debug.LogRecord} The log record.
 */
goog.debug.LogBuffer.prototype.addRecord = function(level, msg, loggerName) {
  var curIndex = (this.curIndex_ + 1) % goog.debug.LogBuffer.CAPACITY;
  this.curIndex_ = curIndex;
  if (this.isFull_) {
    var ret = this.buffer_[curIndex];
    ret.reset(level, msg, loggerName);
    return ret;
  }
  this.isFull_ = curIndex == goog.debug.LogBuffer.CAPACITY - 1;
  return this.buffer_[curIndex] =
      new goog.debug.LogRecord(level, msg, loggerName);
};


/**
 * @return {boolean} Whether the log buffer is enabled.
 */
goog.debug.LogBuffer.isBufferingEnabled = function() {
  return goog.debug.LogBuffer.CAPACITY > 0;
};


/**
 * Removes all buffered log records.
 */
goog.debug.LogBuffer.prototype.clear = function() {
  this.buffer_ = new Array(goog.debug.LogBuffer.CAPACITY);
  this.curIndex_ = -1;
  this.isFull_ = false;
};


/**
 * Calls the given function for each buffered log record, starting with the
 * oldest one.
 * @param {function(!goog.debug.LogRecord)} func The function to call.
 */
goog.debug.LogBuffer.prototype.forEachRecord = function(func) {
  var buffer = this.buffer_;
  // Corner case: no records.
  if (!buffer[0]) {
    return;
  }
  var curIndex = this.curIndex_;
  var i = this.isFull_ ? curIndex : -1;
  do {
    i = (i + 1) % goog.debug.LogBuffer.CAPACITY;
    func(/** @type {!goog.debug.LogRecord} */ (buffer[i]));
  } while (i != curIndex);
};

// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of the Logger class. Please minimize dependencies
 * this file has on other closure classes as any dependency it takes won't be
 * able to use the logging infrastructure.
 *
 * @see ../demos/debug.html
 */

goog.provide('goog.debug.LogManager');
goog.provide('goog.debug.Loggable');
goog.provide('goog.debug.Logger');
goog.provide('goog.debug.Logger.Level');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.debug');
goog.require('goog.debug.LogBuffer');
goog.require('goog.debug.LogRecord');


/**
 * A message value that can be handled by a Logger.
 *
 * Functions are treated like callbacks, but are only called when the event's
 * log level is enabled. This is useful for logging messages that are expensive
 * to construct.
 *
 * @typedef {string|function(): string}
 */
goog.debug.Loggable;



/**
 * The Logger is an object used for logging debug messages. Loggers are
 * normally named, using a hierarchical dot-separated namespace. Logger names
 * can be arbitrary strings, but they should normally be based on the package
 * name or class name of the logged component, such as goog.net.BrowserChannel.
 *
 * The Logger object is loosely based on the java class
 * java.util.logging.Logger. It supports different levels of filtering for
 * different loggers.
 *
 * The logger object should never be instantiated by application code. It
 * should always use the goog.debug.Logger.getLogger function.
 *
 * @constructor
 * @param {string} name The name of the Logger.
 * @final
 */
goog.debug.Logger = function(name) {
  /**
   * Name of the Logger. Generally a dot-separated namespace
   * @private {string}
   */
  this.name_ = name;

  /**
   * Parent Logger.
   * @private {goog.debug.Logger}
   */
  this.parent_ = null;

  /**
   * Level that this logger only filters above. Null indicates it should
   * inherit from the parent.
   * @private {goog.debug.Logger.Level}
   */
  this.level_ = null;

  /**
   * Map of children loggers. The keys are the leaf names of the children and
   * the values are the child loggers.
   * @private {Object}
   */
  this.children_ = null;

  /**
   * Handlers that are listening to this logger.
   * @private {Array.<Function>}
   */
  this.handlers_ = null;
};


/** @const */
goog.debug.Logger.ROOT_LOGGER_NAME = '';


/**
 * @define {boolean} Toggles whether loggers other than the root logger can have
 *     log handlers attached to them and whether they can have their log level
 *     set. Logging is a bit faster when this is set to false.
 */
goog.define('goog.debug.Logger.ENABLE_HIERARCHY', true);


if (!goog.debug.Logger.ENABLE_HIERARCHY) {
  /**
   * @type {!Array.<Function>}
   * @private
   */
  goog.debug.Logger.rootHandlers_ = [];


  /**
   * @type {goog.debug.Logger.Level}
   * @private
   */
  goog.debug.Logger.rootLevel_;
}



/**
 * The Level class defines a set of standard logging levels that
 * can be used to control logging output.  The logging Level objects
 * are ordered and are specified by ordered integers.  Enabling logging
 * at a given level also enables logging at all higher levels.
 * <p>
 * Clients should normally use the predefined Level constants such
 * as Level.SEVERE.
 * <p>
 * The levels in descending order are:
 * <ul>
 * <li>SEVERE (highest value)
 * <li>WARNING
 * <li>INFO
 * <li>CONFIG
 * <li>FINE
 * <li>FINER
 * <li>FINEST  (lowest value)
 * </ul>
 * In addition there is a level OFF that can be used to turn
 * off logging, and a level ALL that can be used to enable
 * logging of all messages.
 *
 * @param {string} name The name of the level.
 * @param {number} value The numeric value of the level.
 * @constructor
 * @final
 */
goog.debug.Logger.Level = function(name, value) {
  /**
   * The name of the level
   * @type {string}
   */
  this.name = name;

  /**
   * The numeric value of the level
   * @type {number}
   */
  this.value = value;
};


/**
 * @return {string} String representation of the logger level.
 * @override
 */
goog.debug.Logger.Level.prototype.toString = function() {
  return this.name;
};


/**
 * OFF is a special level that can be used to turn off logging.
 * This level is initialized to <CODE>Infinity</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.OFF =
    new goog.debug.Logger.Level('OFF', Infinity);


/**
 * SHOUT is a message level for extra debugging loudness.
 * This level is initialized to <CODE>1200</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.SHOUT = new goog.debug.Logger.Level('SHOUT', 1200);


/**
 * SEVERE is a message level indicating a serious failure.
 * This level is initialized to <CODE>1000</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.SEVERE = new goog.debug.Logger.Level('SEVERE', 1000);


/**
 * WARNING is a message level indicating a potential problem.
 * This level is initialized to <CODE>900</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.WARNING = new goog.debug.Logger.Level('WARNING', 900);


/**
 * INFO is a message level for informational messages.
 * This level is initialized to <CODE>800</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.INFO = new goog.debug.Logger.Level('INFO', 800);


/**
 * CONFIG is a message level for static configuration messages.
 * This level is initialized to <CODE>700</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.CONFIG = new goog.debug.Logger.Level('CONFIG', 700);


/**
 * FINE is a message level providing tracing information.
 * This level is initialized to <CODE>500</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.FINE = new goog.debug.Logger.Level('FINE', 500);


/**
 * FINER indicates a fairly detailed tracing message.
 * This level is initialized to <CODE>400</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.FINER = new goog.debug.Logger.Level('FINER', 400);

/**
 * FINEST indicates a highly detailed tracing message.
 * This level is initialized to <CODE>300</CODE>.
 * @type {!goog.debug.Logger.Level}
 */

goog.debug.Logger.Level.FINEST = new goog.debug.Logger.Level('FINEST', 300);


/**
 * ALL indicates that all messages should be logged.
 * This level is initialized to <CODE>0</CODE>.
 * @type {!goog.debug.Logger.Level}
 */
goog.debug.Logger.Level.ALL = new goog.debug.Logger.Level('ALL', 0);


/**
 * The predefined levels.
 * @type {!Array.<!goog.debug.Logger.Level>}
 * @final
 */
goog.debug.Logger.Level.PREDEFINED_LEVELS = [
  goog.debug.Logger.Level.OFF,
  goog.debug.Logger.Level.SHOUT,
  goog.debug.Logger.Level.SEVERE,
  goog.debug.Logger.Level.WARNING,
  goog.debug.Logger.Level.INFO,
  goog.debug.Logger.Level.CONFIG,
  goog.debug.Logger.Level.FINE,
  goog.debug.Logger.Level.FINER,
  goog.debug.Logger.Level.FINEST,
  goog.debug.Logger.Level.ALL];


/**
 * A lookup map used to find the level object based on the name or value of
 * the level object.
 * @type {Object}
 * @private
 */
goog.debug.Logger.Level.predefinedLevelsCache_ = null;


/**
 * Creates the predefined levels cache and populates it.
 * @private
 */
goog.debug.Logger.Level.createPredefinedLevelsCache_ = function() {
  goog.debug.Logger.Level.predefinedLevelsCache_ = {};
  for (var i = 0, level; level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
       i++) {
    goog.debug.Logger.Level.predefinedLevelsCache_[level.value] = level;
    goog.debug.Logger.Level.predefinedLevelsCache_[level.name] = level;
  }
};


/**
 * Gets the predefined level with the given name.
 * @param {string} name The name of the level.
 * @return {goog.debug.Logger.Level} The level, or null if none found.
 */
goog.debug.Logger.Level.getPredefinedLevel = function(name) {
  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
    goog.debug.Logger.Level.createPredefinedLevelsCache_();
  }

  return goog.debug.Logger.Level.predefinedLevelsCache_[name] || null;
};


/**
 * Gets the highest predefined level <= #value.
 * @param {number} value Level value.
 * @return {goog.debug.Logger.Level} The level, or null if none found.
 */
goog.debug.Logger.Level.getPredefinedLevelByValue = function(value) {
  if (!goog.debug.Logger.Level.predefinedLevelsCache_) {
    goog.debug.Logger.Level.createPredefinedLevelsCache_();
  }

  if (value in goog.debug.Logger.Level.predefinedLevelsCache_) {
    return goog.debug.Logger.Level.predefinedLevelsCache_[value];
  }

  for (var i = 0; i < goog.debug.Logger.Level.PREDEFINED_LEVELS.length; ++i) {
    var level = goog.debug.Logger.Level.PREDEFINED_LEVELS[i];
    if (level.value <= value) {
      return level;
    }
  }
  return null;
};


/**
 * Finds or creates a logger for a named subsystem. If a logger has already been
 * created with the given name it is returned. Otherwise a new logger is
 * created. If a new logger is created its log level will be configured based
 * on the LogManager configuration and it will configured to also send logging
 * output to its parent's handlers. It will be registered in the LogManager
 * global namespace.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 * name and should normally be based on the package name or class name of the
 * subsystem, such as goog.net.BrowserChannel.
 * @return {!goog.debug.Logger} The named logger.
 * @deprecated use goog.log instead. http://go/goog-debug-logger-deprecated
 */
goog.debug.Logger.getLogger = function(name) {
  return goog.debug.LogManager.getLogger(name);
};


/**
 * Logs a message to profiling tools, if available.
 * {@see https://developers.google.com/web-toolkit/speedtracer/logging-api}
 * {@see http://msdn.microsoft.com/en-us/library/dd433074(VS.85).aspx}
 * @param {string} msg The message to log.
 */
goog.debug.Logger.logToProfilers = function(msg) {
  // Using goog.global, as loggers might be used in window-less contexts.
  if (goog.global['console']) {
    if (goog.global['console']['timeStamp']) {
      // Logs a message to Firebug, Web Inspector, SpeedTracer, etc.
      goog.global['console']['timeStamp'](msg);
    } else if (goog.global['console']['markTimeline']) {
      // TODO(user): markTimeline is deprecated. Drop this else clause entirely
      // after Chrome M14 hits stable.
      goog.global['console']['markTimeline'](msg);
    }
  }

  if (goog.global['msWriteProfilerMark']) {
    // Logs a message to the Microsoft profiler
    goog.global['msWriteProfilerMark'](msg);
  }
};


/**
 * Gets the name of this logger.
 * @return {string} The name of this logger.
 */
goog.debug.Logger.prototype.getName = function() {
  return this.name_;
};


/**
 * Adds a handler to the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {Function} handler Handler function to add.
 */
goog.debug.Logger.prototype.addHandler = function(handler) {
  if (goog.debug.LOGGING_ENABLED) {
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
      if (!this.handlers_) {
        this.handlers_ = [];
      }
      this.handlers_.push(handler);
    } else {
      goog.asserts.assert(!this.name_,
          'Cannot call addHandler on a non-root logger when ' +
          'goog.debug.Logger.ENABLE_HIERARCHY is false.');
      goog.debug.Logger.rootHandlers_.push(handler);
    }
  }
};


/**
 * Removes a handler from the logger. This doesn't use the event system because
 * we want to be able to add logging to the event system.
 * @param {Function} handler Handler function to remove.
 * @return {boolean} Whether the handler was removed.
 */
goog.debug.Logger.prototype.removeHandler = function(handler) {
  if (goog.debug.LOGGING_ENABLED) {
    var handlers = goog.debug.Logger.ENABLE_HIERARCHY ? this.handlers_ :
        goog.debug.Logger.rootHandlers_;
    return !!handlers && goog.array.remove(handlers, handler);
  } else {
    return false;
  }
};


/**
 * Returns the parent of this logger.
 * @return {goog.debug.Logger} The parent logger or null if this is the root.
 */
goog.debug.Logger.prototype.getParent = function() {
  return this.parent_;
};


/**
 * Returns the children of this logger as a map of the child name to the logger.
 * @return {!Object} The map where the keys are the child leaf names and the
 *     values are the Logger objects.
 */
goog.debug.Logger.prototype.getChildren = function() {
  if (!this.children_) {
    this.children_ = {};
  }
  return this.children_;
};


/**
 * Set the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value Level.OFF can be used to turn off logging. If the new level
 * is null, it means that this node should inherit its level from its nearest
 * ancestor with a specific (non-null) level value.
 *
 * @param {goog.debug.Logger.Level} level The new level.
 */
goog.debug.Logger.prototype.setLevel = function(level) {
  if (goog.debug.LOGGING_ENABLED) {
    if (goog.debug.Logger.ENABLE_HIERARCHY) {
      this.level_ = level;
    } else {
      goog.asserts.assert(!this.name_,
          'Cannot call setLevel() on a non-root logger when ' +
          'goog.debug.Logger.ENABLE_HIERARCHY is false.');
      goog.debug.Logger.rootLevel_ = level;
    }
  }
};


/**
 * Gets the log level specifying which message levels will be logged by this
 * logger. Message levels lower than this value will be discarded.
 * The level value Level.OFF can be used to turn off logging. If the level
 * is null, it means that this node should inherit its level from its nearest
 * ancestor with a specific (non-null) level value.
 *
 * @return {goog.debug.Logger.Level} The level.
 */
goog.debug.Logger.prototype.getLevel = function() {
  return goog.debug.LOGGING_ENABLED ?
      this.level_ : goog.debug.Logger.Level.OFF;
};


/**
 * Returns the effective level of the logger based on its ancestors' levels.
 * @return {goog.debug.Logger.Level} The level.
 */
goog.debug.Logger.prototype.getEffectiveLevel = function() {
  if (!goog.debug.LOGGING_ENABLED) {
    return goog.debug.Logger.Level.OFF;
  }

  if (!goog.debug.Logger.ENABLE_HIERARCHY) {
    return goog.debug.Logger.rootLevel_;
  }
  if (this.level_) {
    return this.level_;
  }
  if (this.parent_) {
    return this.parent_.getEffectiveLevel();
  }
  goog.asserts.fail('Root logger has no level set.');
  return null;
};


/**
 * Checks if a message of the given level would actually be logged by this
 * logger. This check is based on the Loggers effective level, which may be
 * inherited from its parent.
 * @param {goog.debug.Logger.Level} level The level to check.
 * @return {boolean} Whether the message would be logged.
 */
goog.debug.Logger.prototype.isLoggable = function(level) {
  return goog.debug.LOGGING_ENABLED &&
      level.value >= this.getEffectiveLevel().value;
};


/**
 * Logs a message. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 */
goog.debug.Logger.prototype.log = function(level, msg, opt_exception) {
  // java caches the effective level, not sure it's necessary here
  if (goog.debug.LOGGING_ENABLED && this.isLoggable(level)) {
    // Message callbacks can be useful when a log message is expensive to build.
    if (goog.isFunction(msg)) {
      msg = msg();
    }

    this.doLogRecord_(this.getLogRecord(
        level, msg, opt_exception, goog.debug.Logger.prototype.log));
  }
};


/**
 * Creates a new log record and adds the exception (if present) to it.
 * @param {goog.debug.Logger.Level} level One of the level identifiers.
 * @param {string} msg The string message.
 * @param {Error|Object=} opt_exception An exception associated with the
 *     message.
 * @param {Function=} opt_fnStackContext A function to use as the base
 *     of the stack trace used in the log record.
 * @return {!goog.debug.LogRecord} A log record.
 * @suppress {es5Strict}
 */
goog.debug.Logger.prototype.getLogRecord = function(
    level, msg, opt_exception, opt_fnStackContext) {
  if (goog.debug.LogBuffer.isBufferingEnabled()) {
    var logRecord =
        goog.debug.LogBuffer.getInstance().addRecord(level, msg, this.name_);
  } else {
    logRecord = new goog.debug.LogRecord(level, String(msg), this.name_);
  }
  if (opt_exception) {
    var context;
    if (goog.STRICT_MODE_COMPATIBLE) {
      context = opt_fnStackContext || goog.debug.Logger.prototype.getLogRecord;
    } else {
      context = opt_fnStackContext || arguments.callee.caller;
    }

    logRecord.setException(opt_exception);
    logRecord.setExceptionText(
        goog.debug.exposeException(opt_exception,
            opt_fnStackContext || goog.debug.Logger.prototype.getLogRecord));
  }
  return logRecord;
};


/**
 * Logs a message at the Logger.Level.SHOUT level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.shout = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.SHOUT, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.SEVERE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.severe = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.SEVERE, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.WARNING level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.warning = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.WARNING, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.INFO level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.info = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.INFO, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.CONFIG level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.config = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.CONFIG, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINE level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.fine = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINE, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINER level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.finer = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINER, msg, opt_exception);
  }
};


/**
 * Logs a message at the Logger.Level.FINEST level.
 * If the logger is currently enabled for the given message level then the
 * given message is forwarded to all the registered output Handler objects.
 * @param {goog.debug.Loggable} msg The message to log.
 * @param {Error=} opt_exception An exception associated with the message.
 */
goog.debug.Logger.prototype.finest = function(msg, opt_exception) {
  if (goog.debug.LOGGING_ENABLED) {
    this.log(goog.debug.Logger.Level.FINEST, msg, opt_exception);
  }
};


/**
 * Logs a LogRecord. If the logger is currently enabled for the
 * given message level then the given message is forwarded to all the
 * registered output Handler objects.
 * @param {goog.debug.LogRecord} logRecord A log record to log.
 */
goog.debug.Logger.prototype.logRecord = function(logRecord) {
  if (goog.debug.LOGGING_ENABLED && this.isLoggable(logRecord.getLevel())) {
    this.doLogRecord_(logRecord);
  }
};


/**
 * Logs a LogRecord.
 * @param {goog.debug.LogRecord} logRecord A log record to log.
 * @private
 */
goog.debug.Logger.prototype.doLogRecord_ = function(logRecord) {
  goog.debug.Logger.logToProfilers('log:' + logRecord.getMessage());
  if (goog.debug.Logger.ENABLE_HIERARCHY) {
    var target = this;
    while (target) {
      target.callPublish_(logRecord);
      target = target.getParent();
    }
  } else {
    for (var i = 0, handler; handler = goog.debug.Logger.rootHandlers_[i++]; ) {
      handler(logRecord);
    }
  }
};


/**
 * Calls the handlers for publish.
 * @param {goog.debug.LogRecord} logRecord The log record to publish.
 * @private
 */
goog.debug.Logger.prototype.callPublish_ = function(logRecord) {
  if (this.handlers_) {
    for (var i = 0, handler; handler = this.handlers_[i]; i++) {
      handler(logRecord);
    }
  }
};


/**
 * Sets the parent of this logger. This is used for setting up the logger tree.
 * @param {goog.debug.Logger} parent The parent logger.
 * @private
 */
goog.debug.Logger.prototype.setParent_ = function(parent) {
  this.parent_ = parent;
};


/**
 * Adds a child to this logger. This is used for setting up the logger tree.
 * @param {string} name The leaf name of the child.
 * @param {goog.debug.Logger} logger The child logger.
 * @private
 */
goog.debug.Logger.prototype.addChild_ = function(name, logger) {
  this.getChildren()[name] = logger;
};


/**
 * There is a single global LogManager object that is used to maintain a set of
 * shared state about Loggers and log services. This is loosely based on the
 * java class java.util.logging.LogManager.
 */
goog.debug.LogManager = {};


/**
 * Map of logger names to logger objects.
 *
 * @type {!Object.<string, !goog.debug.Logger>}
 * @private
 */
goog.debug.LogManager.loggers_ = {};


/**
 * The root logger which is the root of the logger tree.
 * @type {goog.debug.Logger}
 * @private
 */
goog.debug.LogManager.rootLogger_ = null;


/**
 * Initializes the LogManager if not already initialized.
 */
goog.debug.LogManager.initialize = function() {
  if (!goog.debug.LogManager.rootLogger_) {
    goog.debug.LogManager.rootLogger_ = new goog.debug.Logger(
        goog.debug.Logger.ROOT_LOGGER_NAME);
    goog.debug.LogManager.loggers_[goog.debug.Logger.ROOT_LOGGER_NAME] =
        goog.debug.LogManager.rootLogger_;
    goog.debug.LogManager.rootLogger_.setLevel(goog.debug.Logger.Level.CONFIG);
  }
};


/**
 * Returns all the loggers.
 * @return {!Object.<string, !goog.debug.Logger>} Map of logger names to logger
 *     objects.
 */
goog.debug.LogManager.getLoggers = function() {
  return goog.debug.LogManager.loggers_;
};


/**
 * Returns the root of the logger tree namespace, the logger with the empty
 * string as its name.
 *
 * @return {!goog.debug.Logger} The root logger.
 */
goog.debug.LogManager.getRoot = function() {
  goog.debug.LogManager.initialize();
  return /** @type {!goog.debug.Logger} */ (goog.debug.LogManager.rootLogger_);
};


/**
 * Finds a named logger.
 *
 * @param {string} name A name for the logger. This should be a dot-separated
 * name and should normally be based on the package name or class name of the
 * subsystem, such as goog.net.BrowserChannel.
 * @return {!goog.debug.Logger} The named logger.
 */
goog.debug.LogManager.getLogger = function(name) {
  goog.debug.LogManager.initialize();
  var ret = goog.debug.LogManager.loggers_[name];
  return ret || goog.debug.LogManager.createLogger_(name);
};


/**
 * Creates a function that can be passed to goog.debug.catchErrors. The function
 * will log all reported errors using the given logger.
 * @param {goog.debug.Logger=} opt_logger The logger to log the errors to.
 *     Defaults to the root logger.
 * @return {function(Object)} The created function.
 */
goog.debug.LogManager.createFunctionForCatchErrors = function(opt_logger) {
  return function(info) {
    var logger = opt_logger || goog.debug.LogManager.getRoot();
    logger.severe('Error: ' + info.message + ' (' + info.fileName +
                  ' @ Line: ' + info.line + ')');
  };
};


/**
 * Creates the named logger. Will also create the parents of the named logger
 * if they don't yet exist.
 * @param {string} name The name of the logger.
 * @return {!goog.debug.Logger} The named logger.
 * @private
 */
goog.debug.LogManager.createLogger_ = function(name) {
  // find parent logger
  var logger = new goog.debug.Logger(name);
  if (goog.debug.Logger.ENABLE_HIERARCHY) {
    var lastDotIndex = name.lastIndexOf('.');
    var parentName = name.substr(0, lastDotIndex);
    var leafName = name.substr(lastDotIndex + 1);
    var parentLogger = goog.debug.LogManager.getLogger(parentName);

    // tell the parent about the child and the child about the parent
    parentLogger.addChild_(leafName, logger);
    logger.setParent_(parentLogger);
  }

  goog.debug.LogManager.loggers_[name] = logger;
  return logger;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition the goog.debug.RelativeTimeProvider class.
 *
 */

goog.provide('goog.debug.RelativeTimeProvider');



/**
 * A simple object to keep track of a timestamp considered the start of
 * something. The main use is for the logger system to maintain a start time
 * that is occasionally reset. For example, in Gmail, we reset this relative
 * time at the start of a user action so that timings are offset from the
 * beginning of the action. This class also provides a singleton as the default
 * behavior for most use cases is to share the same start time.
 *
 * @constructor
 * @final
 */
goog.debug.RelativeTimeProvider = function() {
  /**
   * The start time.
   * @type {number}
   * @private
   */
  this.relativeTimeStart_ = goog.now();
};


/**
 * Default instance.
 * @type {goog.debug.RelativeTimeProvider}
 * @private
 */
goog.debug.RelativeTimeProvider.defaultInstance_ =
    new goog.debug.RelativeTimeProvider();


/**
 * Sets the start time to the specified time.
 * @param {number} timeStamp The start time.
 */
goog.debug.RelativeTimeProvider.prototype.set = function(timeStamp) {
  this.relativeTimeStart_ = timeStamp;
};


/**
 * Resets the start time to now.
 */
goog.debug.RelativeTimeProvider.prototype.reset = function() {
  this.set(goog.now());
};


/**
 * @return {number} The start time.
 */
goog.debug.RelativeTimeProvider.prototype.get = function() {
  return this.relativeTimeStart_;
};


/**
 * @return {goog.debug.RelativeTimeProvider} The default instance.
 */
goog.debug.RelativeTimeProvider.getDefaultInstance = function() {
  return goog.debug.RelativeTimeProvider.defaultInstance_;
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Definition of various formatters for logging. Please minimize
 * dependencies this file has on other closure classes as any dependency it
 * takes won't be able to use the logging infrastructure.
 *
 */

goog.provide('goog.debug.Formatter');
goog.provide('goog.debug.HtmlFormatter');
goog.provide('goog.debug.TextFormatter');

goog.require('goog.debug.RelativeTimeProvider');
goog.require('goog.string');



/**
 * Base class for Formatters. A Formatter is used to format a LogRecord into
 * something that can be displayed to the user.
 *
 * @param {string=} opt_prefix The prefix to place before text records.
 * @constructor
 */
goog.debug.Formatter = function(opt_prefix) {
  this.prefix_ = opt_prefix || '';

  /**
   * A provider that returns the relative start time.
   * @type {goog.debug.RelativeTimeProvider}
   * @private
   */
  this.startTimeProvider_ =
      goog.debug.RelativeTimeProvider.getDefaultInstance();
};


/**
 * Whether to append newlines to the end of formatted log records.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.appendNewline = true;


/**
 * Whether to show absolute time in the DebugWindow.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showAbsoluteTime = true;


/**
 * Whether to show relative time in the DebugWindow.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showRelativeTime = true;


/**
 * Whether to show the logger name in the DebugWindow.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showLoggerName = true;


/**
 * Whether to show the logger exception text.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showExceptionText = false;


/**
 * Whether to show the severity level.
 * @type {boolean}
 */
goog.debug.Formatter.prototype.showSeverityLevel = false;


/**
 * Formats a record.
 * @param {goog.debug.LogRecord} logRecord the logRecord to format.
 * @return {string} The formatted string.
 */
goog.debug.Formatter.prototype.formatRecord = goog.abstractMethod;


/**
 * Sets the start time provider. By default, this is the default instance
 * but can be changed.
 * @param {goog.debug.RelativeTimeProvider} provider The provider to use.
 */
goog.debug.Formatter.prototype.setStartTimeProvider = function(provider) {
  this.startTimeProvider_ = provider;
};


/**
 * Returns the start time provider. By default, this is the default instance
 * but can be changed.
 * @return {goog.debug.RelativeTimeProvider} The start time provider.
 */
goog.debug.Formatter.prototype.getStartTimeProvider = function() {
  return this.startTimeProvider_;
};


/**
 * Resets the start relative time.
 */
goog.debug.Formatter.prototype.resetRelativeTimeStart = function() {
  this.startTimeProvider_.reset();
};


/**
 * Returns a string for the time/date of the LogRecord.
 * @param {goog.debug.LogRecord} logRecord The record to get a time stamp for.
 * @return {string} A string representation of the time/date of the LogRecord.
 * @private
 */
goog.debug.Formatter.getDateTimeStamp_ = function(logRecord) {
  var time = new Date(logRecord.getMillis());
  return goog.debug.Formatter.getTwoDigitString_((time.getFullYear() - 2000)) +
         goog.debug.Formatter.getTwoDigitString_((time.getMonth() + 1)) +
         goog.debug.Formatter.getTwoDigitString_(time.getDate()) + ' ' +
         goog.debug.Formatter.getTwoDigitString_(time.getHours()) + ':' +
         goog.debug.Formatter.getTwoDigitString_(time.getMinutes()) + ':' +
         goog.debug.Formatter.getTwoDigitString_(time.getSeconds()) + '.' +
         goog.debug.Formatter.getTwoDigitString_(
             Math.floor(time.getMilliseconds() / 10));
};


/**
 * Returns the number as a two-digit string, meaning it prepends a 0 if the
 * number if less than 10.
 * @param {number} n The number to format.
 * @return {string} A two-digit string representation of {@code n}.
 * @private
 */
goog.debug.Formatter.getTwoDigitString_ = function(n) {
  if (n < 10) {
    return '0' + n;
  }
  return String(n);
};


/**
 * Returns a string for the number of seconds relative to the start time.
 * Prepads with spaces so that anything less than 1000 seconds takes up the
 * same number of characters for better formatting.
 * @param {goog.debug.LogRecord} logRecord The log to compare time to.
 * @param {number} relativeTimeStart The start time to compare to.
 * @return {string} The number of seconds of the LogRecord relative to the
 *     start time.
 * @private
 */
goog.debug.Formatter.getRelativeTime_ = function(logRecord,
                                                 relativeTimeStart) {
  var ms = logRecord.getMillis() - relativeTimeStart;
  var sec = ms / 1000;
  var str = sec.toFixed(3);

  var spacesToPrepend = 0;
  if (sec < 1) {
    spacesToPrepend = 2;
  } else {
    while (sec < 100) {
      spacesToPrepend++;
      sec *= 10;
    }
  }
  while (spacesToPrepend-- > 0) {
    str = ' ' + str;
  }
  return str;
};



/**
 * Formatter that returns formatted html. See formatRecord for the classes
 * it uses for various types of formatted output.
 *
 * @param {string=} opt_prefix The prefix to place before text records.
 * @constructor
 * @extends {goog.debug.Formatter}
 */
goog.debug.HtmlFormatter = function(opt_prefix) {
  goog.debug.Formatter.call(this, opt_prefix);
};
goog.inherits(goog.debug.HtmlFormatter, goog.debug.Formatter);


/**
 * Whether to show the logger exception text
 * @type {boolean}
 * @override
 */
goog.debug.HtmlFormatter.prototype.showExceptionText = true;


/**
 * Formats a record
 * @param {goog.debug.LogRecord} logRecord the logRecord to format.
 * @return {string} The formatted string as html.
 * @override
 */
goog.debug.HtmlFormatter.prototype.formatRecord = function(logRecord) {
  var className;
  switch (logRecord.getLevel().value) {
    case goog.debug.Logger.Level.SHOUT.value:
      className = 'dbg-sh';
      break;
    case goog.debug.Logger.Level.SEVERE.value:
      className = 'dbg-sev';
      break;
    case goog.debug.Logger.Level.WARNING.value:
      className = 'dbg-w';
      break;
    case goog.debug.Logger.Level.INFO.value:
      className = 'dbg-i';
      break;
    case goog.debug.Logger.Level.FINE.value:
    default:
      className = 'dbg-f';
      break;
  }

  // Build message html
  var sb = [];
  sb.push(this.prefix_, ' ');
  if (this.showAbsoluteTime) {
    sb.push('[', goog.debug.Formatter.getDateTimeStamp_(logRecord), '] ');
  }
  if (this.showRelativeTime) {
    sb.push('[',
        goog.string.whitespaceEscape(
            goog.debug.Formatter.getRelativeTime_(logRecord,
                this.startTimeProvider_.get())),
        's] ');
  }

  if (this.showLoggerName) {
    sb.push('[', goog.string.htmlEscape(logRecord.getLoggerName()), '] ');
  }
  if (this.showSeverityLevel) {
    sb.push('[', goog.string.htmlEscape(logRecord.getLevel().name), '] ');
  }
  sb.push('<span class="', className, '">',
      goog.string.newLineToBr(goog.string.whitespaceEscape(
          goog.string.htmlEscape(logRecord.getMessage()))));

  if (this.showExceptionText && logRecord.getException()) {
    sb.push('<br>',
        goog.string.newLineToBr(goog.string.whitespaceEscape(
            logRecord.getExceptionText() || '')));
  }
  sb.push('</span>');
  if (this.appendNewline) {
    sb.push('<br>');
  }

  return sb.join('');
};



/**
 * Formatter that returns formatted plain text
 *
 * @param {string=} opt_prefix The prefix to place before text records.
 * @constructor
 * @extends {goog.debug.Formatter}
 * @final
 */
goog.debug.TextFormatter = function(opt_prefix) {
  goog.debug.Formatter.call(this, opt_prefix);
};
goog.inherits(goog.debug.TextFormatter, goog.debug.Formatter);


/**
 * Formats a record as text
 * @param {goog.debug.LogRecord} logRecord the logRecord to format.
 * @return {string} The formatted string.
 * @override
 */
goog.debug.TextFormatter.prototype.formatRecord = function(logRecord) {
  // Build message html
  var sb = [];
  sb.push(this.prefix_, ' ');
  if (this.showAbsoluteTime) {
    sb.push('[', goog.debug.Formatter.getDateTimeStamp_(logRecord), '] ');
  }
  if (this.showRelativeTime) {
    sb.push('[', goog.debug.Formatter.getRelativeTime_(logRecord,
        this.startTimeProvider_.get()), 's] ');
  }

  if (this.showLoggerName) {
    sb.push('[', logRecord.getLoggerName(), '] ');
  }
  if (this.showSeverityLevel) {
    sb.push('[', logRecord.getLevel().name, '] ');
  }
  sb.push(logRecord.getMessage());
  if (this.showExceptionText && logRecord.getException()) {
    sb.push('\n', logRecord.getExceptionText());
  }
  if (this.appendNewline) {
    sb.push('\n');
  }
  return sb.join('');
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Simple logger that logs to the window console if available.
 *
 * Has an autoInstall option which can be put into initialization code, which
 * will start logging if "Debug=true" is in document.location.href
 *
 */

goog.provide('goog.debug.Console');

goog.require('goog.debug.LogManager');
goog.require('goog.debug.Logger.Level');
goog.require('goog.debug.TextFormatter');



/**
 * Create and install a log handler that logs to window.console if available
 * @constructor
 */
goog.debug.Console = function() {
  this.publishHandler_ = goog.bind(this.addLogRecord, this);

  /**
   * Formatter for formatted output.
   * @type {!goog.debug.TextFormatter}
   * @private
   */
  this.formatter_ = new goog.debug.TextFormatter();
  this.formatter_.showAbsoluteTime = false;
  this.formatter_.showExceptionText = false;

  this.isCapturing_ = false;
  this.logBuffer_ = '';

  /**
   * Loggers that we shouldn't output.
   * @type {!Object.<boolean>}
   * @private
   */
  this.filteredLoggers_ = {};
};


/**
 * Returns the text formatter used by this console
 * @return {!goog.debug.TextFormatter} The text formatter.
 */
goog.debug.Console.prototype.getFormatter = function() {
  return this.formatter_;
};


/**
 * Sets whether we are currently capturing logger output.
 * @param {boolean} capturing Whether to capture logger output.
 */
goog.debug.Console.prototype.setCapturing = function(capturing) {
  if (capturing == this.isCapturing_) {
    return;
  }

  // attach or detach handler from the root logger
  var rootLogger = goog.debug.LogManager.getRoot();
  if (capturing) {
    rootLogger.addHandler(this.publishHandler_);
  } else {
    rootLogger.removeHandler(this.publishHandler_);
    this.logBuffer = '';
  }
  this.isCapturing_ = capturing;
};


/**
 * Adds a log record.
 * @param {goog.debug.LogRecord} logRecord The log entry.
 */
goog.debug.Console.prototype.addLogRecord = function(logRecord) {

  // Check to see if the log record is filtered or not.
  if (this.filteredLoggers_[logRecord.getLoggerName()]) {
    return;
  }

  var record = this.formatter_.formatRecord(logRecord);
  var console = goog.debug.Console.console_;
  if (console) {
    switch (logRecord.getLevel()) {
      case goog.debug.Logger.Level.SHOUT:
        goog.debug.Console.logToConsole_(console, 'info', record);
        break;
      case goog.debug.Logger.Level.SEVERE:
        goog.debug.Console.logToConsole_(console, 'error', record);
        break;
      case goog.debug.Logger.Level.WARNING:
        goog.debug.Console.logToConsole_(console, 'warn', record);
        break;
      default:
        goog.debug.Console.logToConsole_(console, 'debug', record);
        break;
    }
  } else if (window.opera) {
    // window.opera.postError is considered an undefined property reference
    // by JSCompiler, so it has to be referenced using array notation instead.
    window.opera['postError'](record);
  } else {
    this.logBuffer_ += record;
  }
};


/**
 * Adds a logger name to be filtered.
 * @param {string} loggerName the logger name to add.
 */
goog.debug.Console.prototype.addFilter = function(loggerName) {
  this.filteredLoggers_[loggerName] = true;
};


/**
 * Removes a logger name to be filtered.
 * @param {string} loggerName the logger name to remove.
 */
goog.debug.Console.prototype.removeFilter = function(loggerName) {
  delete this.filteredLoggers_[loggerName];
};


/**
 * Global console logger instance
 * @type {goog.debug.Console}
 */
goog.debug.Console.instance = null;


/**
 * The console to which to log.  This is a property so it can be mocked out in
 * this unit test for goog.debug.Console.
 * @type {Object}
 * @private
 */
goog.debug.Console.console_ = window.console;


/**
 * Sets the console to which to log.
 * @param {!Object} console The console to which to log.
 */
goog.debug.Console.setConsole = function(console) {
  goog.debug.Console.console_ = console;
};


/**
 * Install the console and start capturing if "Debug=true" is in the page URL
 */
goog.debug.Console.autoInstall = function() {
  if (!goog.debug.Console.instance) {
    goog.debug.Console.instance = new goog.debug.Console();
  }

  if (window.location.href.indexOf('Debug=true') != -1) {
    goog.debug.Console.instance.setCapturing(true);
  }
};


/**
 * Show an alert with all of the captured debug information.
 * Information is only captured if console is not available
 */
goog.debug.Console.show = function() {
  alert(goog.debug.Console.instance.logBuffer_);
};


/**
 * Logs the record to the console using the given function.  If the function is
 * not available on the console object, the log function is used instead.
 * @param {!Object} console The console object.
 * @param {string} fnName The name of the function to use.
 * @param {string} record The record to log.
 * @private
 */
goog.debug.Console.logToConsole_ = function(console, fnName, record) {
  if (console[fnName]) {
    console[fnName](record);
  } else {
    console.log(record);
  }
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Almost all classes in the 'lgb' namespace inherit
 * from this class. It is primarily concerned with Event listening
 * and dispatching.
 */
goog.provide('lgb.core.DebugLGB');

goog.require('lgb.core.BaseClass');


lgb.core.DebugLGB = function() {
  lgb.core.BaseClass.call(this);
};
goog.inherits(lgb.core.DebugLGB, lgb.core.BaseClass);



lgb.core.DebugLGB.prototype.getClasses = function() {
    var classes = [
    "goog.Disposable",
    "goog.events.EventTarget"
  ];
  
  return classes;
};





lgb.core.DebugLGB.prototype.filterPackages3 = function(packages) {

  var filtered = [];
  var filteredAry = [];

  var len = packages.length;

  for (var i = 0; i < len; i++) {
    
    var packageName = packages[i];
    var packageAry = packageName.split('.');

    var isValid = (window.hasOwnProperty(packageAry[0]));

    if (isValid) {

      var level1 = window[packageAry[0]];
      if (packageAry.length < 2) {
        filtered.push(packageName);
        filteredAry.push(packageAry);
      } else {

        isValid = (level1.hasOwnProperty(packageAry[1]));

        if (isValid) {

          var level2 = level1[packageAry[1]];

          if (packageAry.length < 3) {
            filtered.push(packageName);
            filteredAry.push(packageAry);
          } else {
            isValid = (level2.hasOwnProperty(packageAry[2]));

            if (isValid) {
              var level3 = level2[packageAry[2]];
              
              if (packageAry.length < 4) {
                filtered.push(packageName);
                filteredAry.push(packageAry);
              } else { 
                isValid = (level3.hasOwnProperty(packageAry[3]));
                
                if (isValid) {
                  var level4 = level3[packageAry[3]];
                  if (packageAry.length < 5) {
                    filtered.push(packageName);
                    filteredAry.push(packageAry);
                  } else {
                    debugger;
                  } 
                  
                  
                }
                
              }
            }

          }

        }

      }
    }

  }

  return filteredAry;

}; 


lgb.core.DebugLGB.prototype.getPackages3 = function() {
  
  var packages = [
    'lgb',
    'lgb.component',
    'lgb.core',
    'lgb.gui',
    'lgb.gui.controller',
    'lgb.gui.model',
    'lgb.gui.view',
    
    'lgb.scenario.controller',
    'lgb.scenario.model',
    'lgb.scenario.view',
    
    'lgb.simulation.controller',
    'lgb.simulation.events',
    'lgb.simulation.model',
    'lgb.simulation.model.voManaged',
    'lgb.simulation.model.voNative',
    
    'lgb.utils',
    
    'lgb.chart',
    'lgb.chart.controller',
    'lgb.chart.view',

    'lgb.world',
    'lgb.world.controller',
    'lgb.world.model',
    'lgb.world.view',
    'THREE'
  ];
  

  return packages;
};




lgb.core.DebugLGB.prototype.filterPackages = function(packageAry) {
  
  var filteredPackages = []
  this.filteredPackages_.push(packageAry);
  
  var thePackageString = packageAry.join('.');
    
  topLevelPackage =  eval(thePackageString);
  
  
  for (var propertyName in topLevelPackage) {
    
      var obj = topLevelPackage[propertyName];
      if (obj instanceof Object) {
        
        var newPackageAry = packageAry.concat([propertyName]);
        this.getPackages2(newPackageAry);
      }
      
      
      var x = 0;    
        
        
  }
        
        
  
  // var len = packages.length;
  // for (var i=0; i < len; i++) {
    // var pk = packages[i];
//     
//     
    // var top = eval(pk[0]);
//     
    // var depth = pk.length;
//     
    // if ()
//     
    // if (top.hasOwnProperty(pk[1])) {
//       
    // }
//     
//     
    // var x = 0;
  // };
  
};



  
  
  



lgb.core.DebugLGB.prototype.tag = function() {
  
  var classes = this.getClasses();
  
  var packages = this.getPackages3();
  packages = this.filterPackages3(packages);
   
  
  
  
  this.each(classes, this.setCountClassName_);
  this.each(packages, this.setCountPackageAry_);
  
  this.each(classes, this.tagClassName_);
  this.each(packages, this.tagPackageAry_);
  
  return;
};


lgb.core.DebugLGB.prototype.tagEx = function() {
  
  var classes = this.getClasses();
  
  var packages = this.getPackages3();
  packages = this.filterPackages3(packages);
  
  this.each(classes, this.tagExClassName_);
  this.each(packages, this.tagExPackageAry_);
  
  return;
};





lgb.core.DebugLGB.prototype.tagExPackageAry_ = function(packageAry) {
  
  
  var thePackageString = packageAry.join('.');
  
  
  try
    { 
      var thePackage = eval(thePackageString);
    }
  catch(err)
    {
      console.log(err.message);
    }
    
    if (null != thePackage) {
      for (var className in thePackage) {
    
        if (thePackage.hasOwnProperty(className) && typeof thePackage[className] === 'function') {
          
          var classConstructor = thePackage[className];
          
          
          var fullClassName = thePackageString + '.' + className;
          this.tagExClassName_(fullClassName);
        }
    
      };
    }
    
    

  
};


lgb.core.DebugLGB.prototype.tagExClassName_ = function(fullClassName) {
  
  var classConstructor = eval(fullClassName);
  var functionExists1 = classConstructor.prototype.hasOwnProperty('getFullClassName');  
  
  if(functionExists1) {
    
    console.log("DebugLGB.tagClassName_() - skipping class: " + fullClassName + " - already tagged");
    
  } else {
    var code = "{0}.prototype.getFullClassName".format(fullClassName);
    code += "=function() { return '{0}'};".format(fullClassName);
    eval(code);
  }

  //test
  var functionExists2 = classConstructor.prototype.hasOwnProperty('getFullClassName');  
  
  if(!functionExists2) {
    debugger;
  } 
  
  
  var functionExists3 = classConstructor.prototype.hasOwnProperty('getClassName');  
  if(!functionExists3) {
    
    classConstructor.prototype.getClassName = lgb.core.BaseClass.prototype.getClassName;
  } 
  
  

  return;
    
};

lgb.core.DebugLGB.prototype.tagPackageAry_ = function(packageAry) {

  var thePackageString = packageAry.join('.');
  
  
  try
    { 
      var thePackage = eval(thePackageString);
    }
  catch(err)
    {
      console.log(err.message);
    }
    
    
    
    if (null != thePackage) {
      for (var className in thePackage) {
    
        if (thePackage.hasOwnProperty(className) && typeof thePackage[className] === 'function') {
          
          var fullClassName = thePackageString + '.' + className;
          this.tagClassName_(fullClassName);
        }
    
      };
    }


  
};

lgb.core.DebugLGB.prototype.tagClassName_ = function(fullClassName) {

  var classConstructor = eval(fullClassName);
  
  if (null == classConstructor) {
    
    console.log("DebugLGB.tagClassName_() - skipping class: " + fullClassName);
    
  } else {
    var fullClassName2 = fullClassName.split('.').join('_');
    var countStr = String(classConstructor.SUPERCLASS_COUNT_);
    
    var newFunctionName = "_CLASS_{0}_{1}".format(countStr, fullClassName2);
    
    var code = "{0}.prototype.{1}".format(fullClassName, newFunctionName);
    code += "=function() {};";
    eval(code);
  }

      
      
  return;
};


lgb.core.DebugLGB.prototype.setCountPackageAry_ = function(packageAry) {

  var thePackageString = packageAry.join('.');
  
  try
    { 
      var thePackage = eval(thePackageString);
    }
  catch(err)
    {
      console.log(err.message);
    }
    
    
    if (null != thePackage) {
      for (var className in thePackage) {
    
        if (thePackage.hasOwnProperty(className) && typeof thePackage[className] === 'function') {
          
          var fullClassName = thePackageString + '.' + className;
          this.setCountClassName_(fullClassName);
        }
    
      };
    }

  






};



lgb.core.DebugLGB.prototype.setCountClassName_ = function(fullClassName) {

  // var theClassString = classAry.join('.');
  var classConstructor = eval(fullClassName);
  
  if (typeof classConstructor === 'function') {

    this.setSuperClassCount_(classConstructor);

  } else {
    debugger;
  }

};


lgb.core.DebugLGB.prototype.setSuperClassCount_ = function(classConstructor) {
 
      if (classConstructor.superClass_ && classConstructor.superClass_.constructor) {
        var superClassConstructor = classConstructor.superClass_.constructor;
        
        if (superClassConstructor.SUPERCLASS_COUNT_) {
          classConstructor.SUPERCLASS_COUNT_ = superClassConstructor.SUPERCLASS_COUNT_ + 1;
        } else {
          this.setSuperClassCount_ (superClassConstructor);
          classConstructor.SUPERCLASS_COUNT_ = superClassConstructor.SUPERCLASS_COUNT_ + 1;
        }
        
      } else {
        //no superclass therefore level 0
        classConstructor.SUPERCLASS_COUNT_ = 0;
      }
};





/**
 * fires an event
 * "this" is the event target
 * @param {goog.events.Event} event The event object to dispatch.
 */
lgb.core.DebugLGB.prototype.tagClasses = function(packageAry) {

  var thePackageString = packageAry.join('.');
  var thePackage = eval(thePackageString);


  for (var className in thePackage) {

    if (thePackage.hasOwnProperty(className) && typeof thePackage[className] === 'function') {

      var classConstructor = thePackage[className];
      var str = classConstructor.toString();
      
      
      var newFunctionName = "_CLASS_{0}_{1}".format(packageAry.join('_'), className);
      
      var code = "{0}.{1}.prototype.{2}".format(thePackageString, className, newFunctionName);
      code += "=function() {};";
      eval(code);

    }

  };

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 * Rather than create global functions, I put functions in here.
 * Then you can call them like this - lgb.init();
 * simple. no global namespace conflict then.
 */

goog.provide('lgb');

goog.require('goog.debug.Console');
goog.require('goog.debug.LogRecord');
goog.require('goog.debug.Logger.Level');
goog.require('lgb.core.DebugLGB');


/**
 *
 * You need to call this before you can use the logging
 * functions
 */
lgb.init = function() {
  lgb.console = new goog.debug.Console();
  
  var debug = new lgb.core.DebugLGB();
    
  if ( !COMPILED ) {
    debug.tag();
  }
  
  debug.tagEx();
  
  if (!"LGB_WEBROOT" in window || undefined === window.LGB_WEBROOT) {
    window.LGB_WEBROOT = "";
  }

  
  return;
};

lgb.assert = function(obj) {
    
  if (obj === undefined  ) {
    debugger;
    throw "lgb.assert Failed";

  }
};




lgb.selectNone = function(msg, loggerName) {
  
  if (window.getSelection) {
    if (window.getSelection().empty) {  // Chrome
      window.getSelection().empty();
    } else if (window.getSelection().removeAllRanges) {  // Firefox
      window.getSelection().removeAllRanges();
    }
  }
};



  
  
/**
 * @param {string} msg The message that you want to appear in the console.
 * @param {string=} loggerName This will display as a kind of label.
 */
lgb.logInfo = function(msg, loggerName) {
  lgb.logHelper_(msg, loggerName, goog.debug.Logger.Level.INFO);
};


/**
 * @param {string} msg The message that you want to appear in the console.
 * @param {string=} loggerName This will display as a kind of label.
 */
lgb.logWarning = function(msg, loggerName) {
  lgb.logHelper_(msg, loggerName, goog.debug.Logger.Level.WARNING);
};

/**
 * @param {string} msg The message that you want to appear in the console.
 * @param {string=} loggerName This will display as a kind of label.
 */
lgb.logSevere = function(msg, loggerName) {
  lgb.logHelper_(msg, loggerName, goog.debug.Logger.Level.SEVERE);
};


/**
 * @param {string} msg The message that you want to appear in the console.
 * @param {string|undefined} loggerName This will display as a kind of label.
 * @param {goog.debug.Logger.Level} level INFO, WARNING, or SEVERE.
 * @private
 */
lgb.logHelper_ = function(msg, loggerName, level) {

  if (loggerName === undefined) {
  loggerName = 'lgb';
  }

  var logRecord = new goog.debug.LogRecord(level, msg, loggerName);

   lgb.console.addLogRecord(logRecord);
};


/**
 * You can run this to test and see
 * how the goog logging works
 * //TODO (Raj) put this in another test file.
 */
lgb.testDebug = function() {
  var debugConsole;
  var mockConsole;
  var loggerName1;
  var logRecord1;
  var loggerName2;
  var logRecord2;
  var loggerName3;
  var logRecord3;

  debugConsole = new goog.debug.Console();


  // Set up a recorder for mockConsole.log
  //mockConsole = { log: goog.testing.recordFunction() };
  //goog.debug.Console.console_ = mockConsole;

  // Test logger 1.
  loggerName1 = 'this.is.a.logger';
  logRecord1 = new goog.debug.LogRecord(goog.debug.Logger.Level.INFO,
      'this is a statement', loggerName1);

  // Test logger 2.
  loggerName2 = 'name.of.logger';
  logRecord2 = new goog.debug.LogRecord(goog.debug.Logger.Level.WARNING,
      'hey, this is a warning', loggerName2);

  // Test logger 3.
  loggerName3 = 'third.logger';
  logRecord3 = new goog.debug.LogRecord(goog.debug.Logger.Level.SEVERE,
      'seriously, this statement is serious', loggerName3);

  debugConsole.addLogRecord(logRecord1);
  debugConsole.addLogRecord(logRecord2);
  debugConsole.addLogRecord(logRecord3);
  //assertEquals(1, mockConsole.log.getCallCount());
};


/**
 * @param {number} feet The number of feet.
 * @return {number} the number of meters.
 */
lgb.convertFeetToMeters = function(feet) {
  return feet / 3.2808399;
};


lgb.convertMapToArray = function(map) {
  
  var ary = [];
  
  for(var propertyName in map) {

    var propertyValue = map[propertyName];
    ary.push(propertyValue);
    
  }
  
  return ary;
};







/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.BaseModel');

goog.require('lgb.core.BaseClass');


/**
 * @constructor
 * @extends lgb.core.BaseClass
 */
lgb.world.model.BaseModel = function() {
  lgb.core.BaseClass.call(this);
};
goog.inherits(lgb.world.model.BaseModel, lgb.core.BaseClass);



lgb.world.model.BaseModel.prototype.changePropertyEx = function(propertyName, propertyValue) {

    if (this[propertyName] != propertyValue) {
        this[propertyName] = propertyValue;
        this.dispatchChangedEx(propertyName, propertyValue);
    }
};


lgb.world.model.BaseModel.prototype.dispatchChangedEx = function(propertyName, payload) {
   
   var whatIsDirty = {};
   whatIsDirty[propertyName] = payload;
   
   this.triggerLocal(e.DataModelChangedEx, whatIsDirty);
  
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.model.BaseGuiModel');
goog.require('lgb.world.model.BaseModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.gui.model.BaseGuiModel = function() {

  /**@const */
  this._TITLE = 'BaseGuiModel';


  lgb.world.model.BaseModel.call(this);

};
goog.inherits(lgb.gui.model.BaseGuiModel, lgb.world.model.BaseModel);




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.component.BaseDataSource');

goog.require('lgb.core.BaseClass');



/**
 * @constructor
 * @extends lgb.core.BaseClass
 */
lgb.component.BaseDataSource = function() {

  lgb.core.BaseClass.call(this);

};
goog.inherits(lgb.component.BaseDataSource, lgb.core.BaseClass);




lgb.component.BaseDataSource.prototype.changePropertyEx = function(propertyName, propertyValue) {

   // if (this[propertyName] != propertyValue) {
        this[propertyName] = propertyValue;
        this.dispatchChangedEx(propertyName, propertyValue);
   // }
};




lgb.component.BaseDataSource.prototype.dispatchChangedEx = function(propertyName, payload) {
   
   var whatIsDirty = {};
   whatIsDirty[propertyName] = payload;
   
   this.triggerLocal(e.DataModelChangedEx, whatIsDirty);
  
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.component.TabStripDataSource');
goog.require('lgb.component.BaseDataSource');

/**
 * @constructor
 * @extends lgb.component.BaseDataSource
 * @param {string} title The HTML title in the Link.
 * @param {string} parentHtmlID The CSS ID of the parent in the DOM.
 * @param {string} subID The second part of the CSS ID for this element.
 */
lgb.component.TabStripDataSource = function(title, htmlID, parentHtmlID) {

  lgb.component.BaseDataSource.call(this);
  
  this.title = title;
  
  if (undefined == title || '' == title) {
    debugger;
  }
  
  
  this.parentHtmlID = parentHtmlID;
  
  if (undefined === htmlID) {
    this.htmlID = title;
    //debugger;
  } else {
    this.htmlID = htmlID;
  }
  


  this.isEnabled = true;

  this.showIcon = false;
  this.tabCollection = [];

};
goog.inherits(lgb.component.TabStripDataSource, lgb.component.BaseDataSource);

lgb.component.TabStripDataSource.prototype.setIcon = function(imageUrl, iconHeight, iconWidth) {

  this.imageUrl = imageUrl;
  this.iconHeight = iconHeight;
  this.iconWidth = iconWidth;
  this.showIcon = true;

};


lgb.component.TabStripDataSource.prototype.getTabCount = function() {
  return this.tabCollection.length;
};


lgb.component.TabStripDataSource.prototype.addTab = function(title, content, xPosition) {

  //if (undefined == title || '' == title) {
   // debugger;
 // }
 
 
  if (null == xPosition) { 
    xPosition = this.tabCollection.length + 1;
  };

  if (null == content) { 
    content = '<span></span>';
  };


  var cssClassName = 'tab' + (xPosition);

  var tab = {
    title : title,
    content : content,
    cssClass : cssClassName,
    xPosition : xPosition
  };

  this.tabCollection.push(tab);
  
  if (this.kendoDS) {
    this.kendoDS.add(tab);
  }
  
  this.dispatchChangedEx('addTab', tab);
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.utils');


/**
 * Tests variable for not null;
 * @param {*} value Any variable.
 * @return {boolean} True is the value is not null.
 */
lgb.utils.notNull = function(value) {
  return !lgb.utils.isNull(value);
};


/**
 * Tests variable for null;
 * @param {*} value Any variable.
 * @return {boolean} True is the value is null.
 */
lgb.utils.isNull = function(value) {
  return (null === value || undefined === value);
};


/**
 * used to preload images like for image roll-overs
 * @param {string} images Comma delimited list of image names.
 */
lgb.utils.preload = function(images) {
    var i = 0;

    var imageArray = images.split(',');


    for (i = 0; i <= imageArray.length - 1; i++) {
      var src = 'images/' + imageArray[i];

    var imageObj = new Image(42, 42);
        //document.write('<img src="' + src + '" />');
        // Write to page (uncomment to check images)
        imageObj.src = src;
    }
};


/**
* converts feet to meters
* @param {number} ft The number of feet.
* @return {number} The number of meters.
*/
lgb.utils.ftToM = function(ft) {

  return ft * 0.3048;
};


/**
* Used to verify the number and type of arguments passed to a function
*
* @param {Array} arrayOfTypes An array of Strings which speicfy
* the type of each expected argument.
* @param {number} expectedArgCount The number of arguments expected.
*
*/
lgb.utils.validateArgs = function(arrayOfTypes, expectedArgCount) {
  //get the parameters of the function that is executing validArgs
  var args = lgb.utils.validateArgs.caller.arguments,
    len = args.length;

//Check if the function get the number of parameter you are expecting.
//If not throw an error.
//If the parameter declared is 0 then do not perform this check
    if (expectedArgCount) {
         if (expectedArgCount !== len) {
       var msg = 'The amount of paramers allowed it is ' + expectedArgCount +
       ', received ' + len;
       jQuery.error(msg);
         }
     }

    //Verify the type of each of the parameters. If one is wrong throw an error.
    if (arrayOfTypes) {
     for (var i = 0; i < len; i++) {
        if (typeof(args[i]) !== arrayOfTypes[i]) {

        jQuery.error('In parameter no. ' + (i + 1) + ' the type should be ' +
          arrayOfTypes[i] + ', received ' + typeof(args[i]));
        }
    }
     }
};


goog.provide('lgb.world.view.BaseV');

goog.require('lgb.core.BaseClass');
goog.require('lgb.utils');


/**
 * MVC View base class
 * @constructor
 * @extends {lgb.core.BaseClass}
 * @param {lgb.world.model.BaseModel=} dataModel that the view with display.
 */
lgb.world.view.BaseV = function(dataModel, htmlID, parentHtmlID) {
  lgb.core.BaseClass.call(this);


  if (null !== dataModel && undefined !== dataModel) {
    this.dataModel = dataModel;

    //this.changeMap_ = {};

    if (this.onChange && this.dataModel) {
      this.listenHelper_(this.dataModel, e.DataModelChanged, this, this.onChange);
    }

    if (this.onDataModelChanged && this.dataModel) {
      this.listenHelper_(this.dataModel, e.DataModelChanged, this, this.onDataModelChanged);
    }

  }

  if (null == this.disableIDs_ || false == this.disableIDs_) {
    this.setIds_(htmlID, parentHtmlID);
  }


};
goog.inherits(lgb.world.view.BaseV, lgb.core.BaseClass);



lgb.world.view.BaseV.prototype.listenForChangeTargetInit_ = function(eventTarget) {
    this.listenHelper_(eventTarget, e.DataModelChangedEx, this, this.onChangeEx_);
};


lgb.world.view.BaseV.prototype.listenForChange_ = function(changedPropertyString, eventTargetArg) {
    
    if (this.changeMap_ === undefined) {
      this.changeMap_ = {};
      this.listenerMap_ = {};
      this.listenForChangeTargetInit_(this.dataModel);
    }
    
    var eventTarget;
    
    if (null == eventTargetArg) {
       eventTarget = this.dataModel;
    } else {
       eventTarget = eventTargetArg;
    }
    
    this.listenForOneChange_(changedPropertyString);
};




lgb.world.view.BaseV.prototype.listenForOneChange_ = function(changedPropertyString, eventTarget) {
  
    var handlerName = 'onChange_' + changedPropertyString + '_';
    var func = this[handlerName];

    if (func && func instanceof Function) {
      var delegate = this.d(func);
      this.changeMap_[changedPropertyString] = delegate;
    } else {
      debugger;
    }
};


lgb.world.view.BaseV.prototype.onChangeEx_ = function(event) {
  
   var whatIsDirty = event.payload;
  
    //loop through all the dirty properties and fire their event listeners
   for (var prop in whatIsDirty) {
      
      if(prop !== undefined || prop !== null) {
        
        if(whatIsDirty.hasOwnProperty(prop)){
          
          var delegate = this.changeMap_[prop];
          var arg = whatIsDirty[prop];
          
          if (delegate) {
            delegate(arg);
          }
        }
      }
   }
};






/**
 * appends html to the main element
 * @param {string} html the HTML string to append.
 * @protected
 */
lgb.world.view.BaseV.prototype.append = function(content) {

  var el = this.getMainElement();

  if (!el) {
    debugger;
  }
  
  el.append(content);

};



lgb.world.view.BaseV.prototype.injectInto = function(parentElement) {
  
  if (null == parentElement) {
    debugger;
  } else {
    this.parentElement_ = parentElement;
  }
  
  this.inject();
};



lgb.world.view.BaseV.prototype.inject = function() {

  var el = this.getMainElement();
  
  var parentElement = this.getParentElement();
  
  if (null == parentElement) {
    debugger;
  }
  
  parentElement.append(el);
};


lgb.world.view.BaseV.prototype.makeDiv = function(id) {
  
  var div = $('<div>');
  
  if (id) {
    div.attr('id', id);
  }

  return div;
};


/**
 * makes a unique css ID for a child element
 * @param {!string} id The last part of the CSS ID.
 * @return {string} The generated ID.
 */
lgb.world.view.BaseV.prototype.makeID = function(id) {
  lgb.assert(this.htmlID);
  var newID = '{0}-{1}'.format(this.htmlID, id);
  return newID;
};


lgb.world.view.BaseV.prototype.setMainElement = function(el) {
  this.mainElement_ = el;
};

lgb.world.view.BaseV.prototype.setParentElement = function(parentElement) {
  this.parentElement_ = parentElement;
};


lgb.world.view.BaseV.prototype.setIds_ = function(htmlID, parentHtmlID) {

  this.parentHtmlID = parentHtmlID || 'theBody';
  
  var id;
  if (null == htmlID) {
    id = this.generateHTMLid_();
  }  else {
    id = htmlID;
  }
  
  if (lgb.world.view.BaseV.HTML_IDS.hasOwnProperty(id)) {
    debugger;
  } else {
    lgb.world.view.BaseV.HTML_IDS[id] = true;
    this.htmlID = id;
  }


};


lgb.world.view.BaseV.prototype.generateHTMLid_ = function(id) {
  
    var fullName = this.getFullClassName();
    var fullNameDashes = fullName.split('.').join('-');
    
    if (lgb.world.view.BaseV.HTML_IDS_COUNT.hasOwnProperty(fullNameDashes)) {
      lgb.world.view.BaseV.HTML_IDS_COUNT[fullNameDashes]++;
    } else {
      lgb.world.view.BaseV.HTML_IDS_COUNT[fullNameDashes] = 0;
    }
    
    var count = lgb.world.view.BaseV.HTML_IDS_COUNT[fullNameDashes];
    var htmlID = fullNameDashes + '-' + String(count);  
    
    if (lgb.world.view.BaseV.HTML_IDS.hasOwnProperty(htmlID)) {
      debugger;
    }
    
    return htmlID;  
    
};




lgb.world.view.BaseV.prototype.getMainElement = function() {

  if (undefined == this.mainElement_) {
    this.mainElement_ = $('<div>');
    
    if (undefined != this.htmlID) {
      this.mainElement_.attr('id', this.htmlID);
    }
    
    if (undefined != this.cssClassName_) {
      this.mainElement_.addClass(this.cssClassName_);
    }
  }

  return this.mainElement_;
};


/**
 * converts an id into a Jquery object
 * refers to the parent in the DOM
 * @return {jQuery} Jquery object.
 */
lgb.world.view.BaseV.prototype.getParentElement = function() {

  if (undefined == this.parentElement_) {
    this.parentElement_ = $('#{0}'.format(this.parentHtmlID));
  }

  return this.parentElement_;
};



lgb.world.view.BaseV.prototype.requestDataModelChange = function(property, newValue) {
  var payload = {property:property, newValue:newValue};
  this.triggerLocal(e.RequestDataModelChange, payload);
};



lgb.world.view.BaseV.prototype.getTitle = function() {
  
  var title = this._TITLE || this.getClassName();
  return title;
};


lgb.world.view.BaseV.prototype.getViewPoint = function() {
  
  return null;
};



lgb.world.view.BaseV.HTML_IDS_COUNT = {};
lgb.world.view.BaseV.HTML_IDS_BASE = {};
lgb.world.view.BaseV.HTML_IDS = {};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');
goog.require('lgb.world.view.BaseV');


/**
 * Html radio button group that will be inserted into the DOM
 * @constructor
 * @extends {lgb.world.view.BaseV}
 * @param {lgb.component.TabStripDataSource} ds the datasource
 * for this component.
 */
lgb.component.TabStrip = function(ds) {

  lgb.world.view.BaseV.call(this, ds, ds.htmlID, ds.parentHtmlID);
  this.ds = ds;
  
  this.listenForChange_('addTab');
};
goog.inherits(lgb.component.TabStrip, lgb.world.view.BaseV);


lgb.component.TabStrip.prototype.onChange_addTab_ = function(tab) {
  

    if (this.ds.showIcon) {
      
      var idx = tab.xPosition-1;

      var cssInner = this.makeBackgroundPosition(' .' + tab.cssClass, idx, 1);
      cssInner += this.makeBackgroundPosition(' .k-state-active .' + tab.cssClass, idx, 0);
      cssInner += this.makeBackgroundPosition(' .k-state-hover .' + tab.cssClass, idx, 2);

      var cssStr = "<style type='text/css'>{0}</style>".format(cssInner);
      $(cssStr).appendTo('head');
    }
    
};


/**
 * @param {string} appendToSelector The second part of the
 * jQuery selector string.
 * @param {number} yPosition Used to calculate the pixel shift.
 * @return {string} the Css.
 */
lgb.component.TabStrip.prototype.makeBackgroundPosition = function(appendToSelector, xPosition, yPosition) {

  var pixelShiftY = this.ds.iconHeight * yPosition * -1;
  var pixelShiftX = this.ds.iconWidth * xPosition * -1;

  var cssStr = '#{0}{1}{background-position: {2}px {3}px;}'.format(this.htmlID, appendToSelector, pixelShiftX.toString(), pixelShiftY.toString());

  return cssStr;
};


lgb.component.TabStrip.prototype.addTab = function(title) {

  this.ds.addTab(title);
  this.kendoTabStrip_.select(0);

  return this.getContentElement();
};


lgb.component.TabStrip.prototype.getContentElement = function() {
  
  var len = this.kendoTabStrip_.contentElements.length;
  var contentElement = this.kendoTabStrip_.contentElements[len - 1];
  
  return $(contentElement);
};


/*
lgb.component.TabStrip.prototype.setOptions = function(options) {

  this.options = options;

  if (this.options.width) {
    this.getMainElement().css('width', this.options.width);
  }

};
*/

lgb.component.TabStrip.prototype.bind_ = function() {

  this.kendoTabStrip_.bind('select', this.d(this.onSelect_));
  
};


lgb.component.TabStrip.prototype.onSelect_ = function(event) {
  
  
  var payload = event.item;
  this.triggerLocal(e.Select, payload);
  
  
};


lgb.component.TabStrip.prototype.injectCss = function() {

  if (this.ds.showIcon) {
    //inject background image for tab
    var cssInner = '#{0} .k-sprite '.format(this.ds.htmlID);
    cssInner += '{background-image: url("{0}");'.format(this.ds.imageUrl);
    cssInner += 'margin: 0px;';
    cssInner += 'width: {0}px;}'.format(this.ds.iconWidth);

    //eliminate margin and padding
    cssInner += '#{0} .k-tabstrip-items .k-link {margin:0px;padding:0px }'.format(this.ds.htmlID);
    var len = this.ds.tabCollection.length;

    for (var i = 0; i < len; i++) {
      var cssStr = '.tab' + (i + 1) + ' ';

      cssInner += this.makeBackgroundPosition(' ' + cssStr, i, 1);
      cssInner += this.makeBackgroundPosition(' .k-state-active ' + cssStr, i, 0);
      cssInner += this.makeBackgroundPosition(' .k-state-hover ' + cssStr, i, 2);
    };

    var cssStr = "<style type='text/css'>{0}</style>".format(cssInner);
    $(cssStr).appendTo('head');
  }

};



/**
 * @public
 */
lgb.component.TabStrip.prototype.injectInto = function(parentElement) {

  var el = this.getMainElement();

  this.kendoTabStrip_ = el.kendoTabStrip({
    dataTextField : "title",
    dataSpriteCssClass : "cssClass",
    dataContentField : "content",
    dataSource : this.ds.tabCollection
  }).data("kendoTabStrip");

  this.kendoTabStrip_.select(0);
  this.ds.kendoDS = this.kendoTabStrip_.dataSource;
  
  this.bind_();
  
  goog.base(this,'injectInto', parentElement);

};

goog.provide('lgb.gui.view.BaseGUI');

goog.require('lgb.world.view.BaseV');


/**
 * MVC View base class
 * @constructor
 * @extends {lgb.BaseV}
 * @param {lgb.world.model.BaseModel=} dataModel that the view with display.
 */
lgb.gui.view.BaseGUI = function(dataModel, htmlID, parentHtmlID) {
  
  lgb.world.view.BaseV.call(this, dataModel, htmlID, parentHtmlID);
  this.isVisible_ = true;

};
goog.inherits(lgb.gui.view.BaseGUI, lgb.world.view.BaseV);



lgb.gui.view.BaseGUI.prototype.gotoViewPoint = function(name) {


};




goog.provide('lgb.gui.view.TestGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');
goog.require('lgb.core.Event');


lgb.gui.view.TestGUI = function(dataModel) {

  this._TITLE = 'Test';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
};
goog.inherits(lgb.gui.view.TestGUI, lgb.gui.view.BaseGUI);


/**
 * @public
 */
lgb.gui.view.TestGUI.prototype.init = function() {

  this.dataSource = new lgb.component.TabStripDataSource('testingInputGUI-tabStrip');
  this.tabStrip = new lgb.component.TabStrip(this.dataSource);

  this.tabTitleMap_ = {};
  this.tabViewPointMap_ = {};
  this.tab2guiMap_ = {};
  
  this.bind_();
  

};


lgb.gui.view.TestGUI.prototype.bind_ = function() {
  
  this.listenTo(this.tabStrip, e.Select, this.onSelect);
  
};


lgb.gui.view.TestGUI.prototype.onSelect = function(event) {

  var title = event.payload.textContent;
  var gui = this.tab2guiMap_[title];
  
  if (null == gui) {
    //debugger;
  } else {
    gui.gotoViewPoint('MainViewPoint');
  }


};


lgb.gui.view.TestGUI.prototype.add = function(gui) {

  var title = gui.getTitle();

  var contentElement;
  
  if (this.tabTitleMap_.hasOwnProperty(title)) {
    debugger;
  } else {
    contentElement = this.tabStrip.addTab(title);
    this.tabTitleMap_[title] = contentElement;
    this.tab2guiMap_[title] = gui;
  }
  
  gui.injectInto(contentElement);
  
  
};


/**
 * @public
 */
lgb.gui.view.TestGUI.prototype.injectInto = function(parentElement) {
  
  this.tabStrip.injectInto(parentElement);
  this.tabStrip.injectCss();

 
};


goog.provide('lgb.gui.controller.TestController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.TestGUI');
goog.require('lgb.gui.model.BaseGuiModel');


lgb.gui.controller.TestController = function() {

  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.gui.controller.TestController, lgb.core.BaseController);


/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.TestController.prototype.init = function() {

  this.dataModel = new lgb.gui.model.BaseGuiModel();

  this.guiView = new lgb.gui.view.TestGUI(this.dataModel);
  this.bind_();
  this.guiView.init();
  
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
};


lgb.gui.controller.TestController.prototype.bind_ = function() {

  this.relay(
    this.guiView,
    e.RequestGoToViewpointNode);
    
  this.listen(e.RequestAddToTestingInput, this.onRequestAddToTestingInput_);
    

};


lgb.gui.controller.TestController.prototype.onRequestAddToTestingInput_ = function(event) {
  
    this.guiView.add(event.payload);
  
};goog.provide('lgb.gui.view.BottomPanelGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');

lgb.gui.view.BottomPanelGUI = function(dataModel) {

  this._TITLE = 'BottomPanelGUI';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.init_();

  
};
goog.inherits(lgb.gui.view.BottomPanelGUI, lgb.gui.view.BaseGUI);



lgb.gui.view.BottomPanelGUI.prototype.init_ = function() {
  
  this.tabTitleMap_ = {};
  
  this.dataSource = new lgb.component.TabStripDataSource('bottomPanelGUI-tabStrip');
  this.tabStrip1 = new lgb.component.TabStrip(this.dataSource);
    
};


lgb.gui.view.BottomPanelGUI.prototype.add = function(gui) {

  var title = gui.getTitle();

  var contentElement;
  
  if (this.tabTitleMap_[title]) {
    contentElement = this.tabTitleMap_[title];
  } else {
    
    contentElement = this.tabStrip1.addTab(title);
    
    contentElement.css("min-height","100%");
    contentElement.css("height","100%");
    contentElement.css("overflow","none");
    
    
    this.tabTitleMap_[title] = contentElement;
  }
  
  gui.injectInto(contentElement);
  
};


/**
 * @public
 */
lgb.gui.view.BottomPanelGUI.prototype.injectInto = function(parentElement) {
  
  this.tabStrip1.injectInto(parentElement);
  this.tabStrip1.injectCss();
  
  var el = this.tabStrip1.getMainElement();
  el.css("width","100%");
  el.css("min-height","100%");
  el.css("height","100%");
  
  
};


goog.provide('lgb.gui.view.SimulationConsoleGUI');

goog.require('lgb.gui.view.BaseGUI');


lgb.gui.view.SimulationConsoleGUI = function(dataModel) {

  this._TITLE = 'Console';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.totalHeaderHeight_ = 74;
};
goog.inherits(lgb.gui.view.SimulationConsoleGUI, lgb.gui.view.BaseGUI);



lgb.gui.view.SimulationConsoleGUI.prototype.init = function() {
  
    var el = this.getMainElement();
    
    el.css({
       "overflow-y":"scroll",
       "height":"100%"
    });
    

    this.listenForChange_('messageStruct');
};


lgb.gui.view.SimulationConsoleGUI.prototype.calculateLayout = function() {
  
  
  var p = this.getParentElement();
  var gp = p[0].parentElement;
  var paneHeight = gp.clientHeight;

  var contentHeight = paneHeight - this.totalHeaderHeight_;
  var cssStr = contentHeight + 'px';
  
  this.getMainElement().css("height", cssStr);
     
};


lgb.gui.view.SimulationConsoleGUI.prototype.injectInto = function(parentElement) {
  
  goog.base(this,  'injectInto', parentElement);
  this.calculateLayout();
  
};



lgb.gui.view.SimulationConsoleGUI.prototype.onChange_messageStruct_ = function(messageStruct) {
  
  var el = this.getMainElement();
  el.prepend(  messageStruct.msgText + '<br />' + "\n");
  

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.component.LinkDataSource');
goog.require('lgb.component.BaseDataSource');


/**
 * @constructor
 * @extends lgb.component.BaseDataSource
 * @param {string} title The HTML title in the Link.
 * @param {string} parentHtmlID The CSS ID of the parent in the DOM.
 * @param {string} subID The second part of the CSS ID for this element.
 */
lgb.component.LinkDataSource = function(title, parentHtmlID, subID) {

  lgb.component.BaseDataSource.call(this);

  this.title = title;
  this.parentHtmlID = parentHtmlID;
  this.htmlID = parentHtmlID + '-' + subID;
  this.theSelectedOne = null;
  this.data = null;
  this.isEnabled = true;
  this.cssClass = 'admin';
};
goog.inherits(lgb.component.LinkDataSource, lgb.component.BaseDataSource);
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.BaseEvent');
goog.provide('se.Event');

goog.require('goog.events.Event');
goog.require('goog.asserts');


/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.BaseEvent = function(payload) {
  
  
  var type = this.getFullClassName();
  goog.events.Event.call( this,  type);
  
  if (undefined != payload) {
    this.setPayload(payload);
  }

  
};
goog.inherits(lgb.simulation.events.BaseEvent, goog.events.Event);





//must implement in subclass
lgb.simulation.events.BaseEvent.prototype.getPayloadType = function() { debugger;};




lgb.simulation.events.BaseEvent.prototype.getPayload = function() {

    return this.payload_;
};


lgb.simulation.events.BaseEvent.prototype.setPayload = function(payload) {
  
    var payloadType = this.getPayloadType();
    goog.asserts.assertInstanceof(payload, payloadType);

    this.payload_ = payload;
};


lgb.simulation.events.BaseEvent.prototype.getClassName = function() {
  
  var fullClassName = this.getFullClassName();
  var ary = fullClassName.split('.');
  
  var len = ary.length;
  var className = ary[len-1];
  
  return className;
};




lgb.simulation.events.BaseEvent.prototype.toJSON = function() { 
    return this.toJSONHelper_();
};

lgb.simulation.events.BaseEvent.prototype.toJSONHelper_ = function() {
    
    var jsonObj = {
      t:this.getClassName(),
      payload:this.payload_
    };
    
    return jsonObj;
};


// 
// lgb.simulation.events.BaseEvent.prototype.fromJSON = function(deserializedObj) {
  // this.fromJSONHelper_(deserializedObj);
// };
// 
// 
// 
// lgb.simulation.events.BaseEvent.prototype.fromJSONHelper_ = function(deserializedObj) {
//     
  // var payloadClassReference = this.getPayloadType();
  // this.payload_ = new payloadClassReference();
//   
  // this.payload_.fromJSON(deserializedObj.payload);
//   
// };
// 




se.Event = function() {};

se.BaseEvent = 'lgb.simulation.events.BaseEvent';
se.WebSocketChangeRequest = 'lgb.simulation.events.WebSocketChangeRequest';
se.WebSocketChangeNotify = 'lgb.simulation.events.WebSocketChangeNotify';

se.SimStateNativeRequest = 'lgb.simulation.events.SimStateNativeRequest';
se.SimStateNativeNotify = 'lgb.simulation.events.SimStateNativeNotify';

se.XMLparsedEvent = 'lgb.simulation.events.XMLparsedEvent';
se.ResultEvent = 'lgb.simulation.events.ResultEvent';
se.MessageEvent = 'lgb.simulation.events.MessageEvent';
se.RequestModelicaVariableChange = 'lgb.simulation.events.RequestModelicaVariableChange';
se.ConfigChangeNotify = 'lgb.simulation.events.ConfigChangeNotify';

se.SetRemoteHost = 'lgb.simulation.events.SetRemoteHost';
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.component.Link');
goog.require('lgb.component.LinkDataSource');



/**
 * Html radio button group that will be inserted into the DOM
 * @constructor
 * @extends {lgb.world.view.BaseV}
 * @param {lgb.component.LinkDataSource} ds the datasource
 * for this component.
 */
lgb.component.Link = function(ds) {

  
  lgb.world.view.BaseV.call(this, null, ds.htmlID);
  this.ds = ds;

};
goog.inherits(lgb.component.Link, lgb.world.view.BaseV);




lgb.component.Link.prototype.getHTML = function() {

   var theClass ="{0}-link".format(this.ds.cssClass);
   
   if (!this.ds.isEnabled) {
       theClass +="-disabled";
   }
   
 var html = '<a id="{0}" class="{1}" href="#">{2}</a>'.
  format(
      this.ds.htmlID,
      theClass, 
      this.ds.title
      );

  return html;
};



/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 */
lgb.component.Link.prototype.bind = function(el) {
    
  var delegateClick = this.d(this.onMouseClick_);
  var delegateOver = this.d(this.onMouseOver_);
  var delegateOut = this.d(this.onMouseOut_);

  
  if (el) {
    this.theEl_ = el;
  } else {
    var el = $('#' + this.ds.htmlID);
  }


  el.click(delegateClick);
  el.hover(delegateOver, delegateOut);

};


lgb.component.Link.prototype.setEnabled = function(isEnabled) {
   

    if (this.ds.isEnabled != isEnabled) {
        
        var enabledClass = this.ds.cssClass + '-link';
        var disabledClass = enabledClass + '-disabled';
      
        this.ds.isEnabled = isEnabled;

        if (this.theEl_) {
          var el = this.theEl_;
          
          if(isEnabled) {
              el.removeClass(disabledClass);
              el.addClass(enabledClass);
              
          } else {
              el.removeClass(enabledClass);
              el.addClass(disabledClass);
          }
        } else {
           var el = $('#' + this.ds.htmlID);
          if(isEnabled) {
              el.removeClass(disabledClass);
              el.addClass(enabledClass);
          } else {
              el.removeClass(enabledClass);
              el.addClass(disabledClass);
          }
        }

    }
};


/**'
 * Event handler
 * @private
 * @param {jQuery.event} event The event.
 */
lgb.component.Link.prototype.onMouseClick_ = function(event) {
    
    if(this.ds.isEnabled ) {
        this.triggerLocal(e.MouseClick);
    }

};


/**
 * Event handler
 * @private
 * @param {jQuery.event} event The event.
 */
lgb.component.Link.prototype.onMouseOver_ = function(event) {
    
    if(this.ds.isEnabled ) {
        this.triggerLocal(e.MouseOver);
    }

};


/**'
 * Event handler
 * @private
 * @param {jQuery.event} event The event.
 */
lgb.component.Link.prototype.onMouseOut_ = function(event) {
    
    if(this.ds.isEnabled ) {
        this.triggerLocal(e.MouseOut);
    }

};









/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2014 Institute for Sustainable Performance of Buildings (Superb)
 */
goog.provide('lgb.simulation.model.BaseModel');

goog.require('lgb.core.BaseClass');




lgb.simulation.model.BaseModel  = function() {


};




lgb.simulation.model.BaseModel.prototype.getClassName = function() {
  
  var fullClassName = this.getFullClassName();
  var ary = fullClassName.split('.');
  
  var len = ary.length;
  var className = ary[len-1];
  
  return className;
};


lgb.simulation.model.BaseModel.prototype.getClassReference = function() {
  
  var fullClassName = this.getFullClassName();
  var classReference = eval(fullClassName);
  
  return classReference;
};




lgb.simulation.model.BaseModel.prototype.toJSON = function() { 
    return this.toJSONHelper_();
};


lgb.simulation.model.BaseModel.prototype.toJSONHelper_ = function() { 
  

  var serializeType = this.serializeType;

  if ( undefined == serializeType) {
    serializeType = true;
  }

  var jsonObject = {};
  
  if (serializeType) {
     jsonObject.t = this.getClassName();
  }

  
  var classReference = this.getClassReference();

  
  if (undefined != classReference.fieldPrimativesEx_) {
    
    var fieldPrimativesEx = classReference.fieldPrimativesEx_;

    for(var jsFieldName in fieldPrimativesEx) {
      var jsonFieldName = fieldPrimativesEx[jsFieldName];
      jsonObject[jsonFieldName] = this[jsFieldName];
    }
  }
  
  if (undefined != classReference.fieldObjectsEx_) {
    
    var fieldObjectsEx = classReference.fieldObjectsEx_;

    for(var jsFieldName in fieldObjectsEx) {
      
      var fieldObject = fieldObjectsEx[jsFieldName];
       
      var jsonFieldName = fieldObject.jsonFieldName;
      var fieldClassReference = fieldObject.classReference;
      

      
      if (this[jsFieldName] != null) {
        
      var fieldValue = this[jsFieldName];
      
      if (fieldClassReference == lgb.simulation.model.voManaged.SerializableVector) {
        
        if (fieldValue instanceof Array) {

          var sv = new lgb.simulation.model.voManaged.SerializableVector(fieldObject.itemTypeString, fieldValue);
          jsonObject[jsonFieldName] = sv;
          
        } else {
          debugger;
        }

        
      } else {
        jsonObject[jsonFieldName] = fieldValue;
      }

      }

    }
  }
  

  return jsonObject;
};



// lgb.simulation.model.BaseModel.prototype.fromJSON = function(deserializedObj) {
//   
  // this.fromJSONHelper_(deserializedObj);
//   
// };



// lgb.simulation.model.BaseModel.prototype.fromJSONHelper_ = function(deserializedObj) {
//     
  // //if (undefined == classReference) {
    // var classReference = this.getClassReference();
  // //}
// 
//    
  // if (undefined != classReference.fieldPrimativesEx_) {
//     
    // var fieldPrimativesEx = classReference.fieldPrimativesEx_;
// 
    // for(var jsFieldName in fieldPrimativesEx) {
//       
      // var jsonFieldName = fieldPrimativesEx[jsFieldName];
      // this[jsFieldName] = deserializedObj[jsonFieldName];
//       
    // }
  // }
//   
  // if (undefined != classReference.fieldObjectsEx_) {
//     
    // var fieldObjectsEx = classReference.fieldObjectsEx_;
// 
    // for(var jsFieldName in fieldObjectsEx) {
//       
      // var fieldObject = fieldObjectsEx[jsFieldName];   
      // var jsonFieldName = fieldObject.jsonFieldName;
      // var fieldClassReference = fieldObject.classReference;
//       
//       
      // if (null == fieldClassReference) {
        // debugger;
      // }
//       
      // var childDeserializedObj = deserializedObj[jsonFieldName];
//       
//       
// 
//       
      // if (null != childDeserializedObj) { 
//         
        // var childTypedObject = new fieldClassReference();
        // childTypedObject.fromJSON(childDeserializedObj);
//         
        // if (fieldClassReference == lgb.simulation.model.voManaged.SerializableVector) {
//         
          // this[jsFieldName] = childTypedObject.toArray();
//           
        // } else {
// 
          // this[jsFieldName] = childTypedObject;
//           
        // }
//       
      // }
// 
    // }
//     
  // }
//   
// 
// };

goog.provide('lgb.simulation.model.voNative.SimStateNative');

goog.require('lgb.simulation.model.BaseModel');

lgb.simulation.model.voNative.SimStateNative = function(intValue) {
  
  if (undefined != intValue) {
    this.setIntValue(intValue);
  }
  lgb.simulation.model.BaseModel.call(this);
};
goog.inherits(lgb.simulation.model.voNative.SimStateNative, lgb.simulation.model.BaseModel);


lgb.simulation.model.voNative.SimStateNative.CLIENT_TRANSITIONS = {
  0 : [1], //simStateNative_0_uninitialized
  1 : [1], //simStateNative_0_uninitialized
  2: [3], //simStateNative_1_connect_completed
  4: [5], //simStateNative_2_xmlParse_completed
  10: [11, 17, 22, 24], //simStateNative_3_ready
  12:[15], //simStateNative_4_run_started
  13: [10], //simStateNative_4_run_completed
  16: [17, 26, 24, 22], //simStateNative_5_stop_completed
  21: [26,22,15] //simStateNative_6_pause_completed
  

};





lgb.simulation.model.voNative.SimStateNative.prototype.setIntValue  = function( intValue ) {
    this.intValue_ = intValue;
};

lgb.simulation.model.voNative.SimStateNative.prototype.getIntValue  = function(  ) {
  return this.intValue_;
};



lgb.simulation.model.voNative.SimStateNative.prototype.getString  = function(  ) {
  var str = lgb.simulation.model.voNative.SimStateNative.TEXT[this.intValue_];
  return str;
};


lgb.simulation.model.voNative.SimStateNative.prototype.canRequestTransitionTo  = function( intValue ) {
  
  // if (enum_arg == 3 ) {
    // debugger;
  // }
//   
  if (lgb.simulation.model.voNative.SimStateNative.CLIENT_TRANSITIONS.hasOwnProperty(this.intValue_)) {
    
    var aryOfValidTransitions = lgb.simulation.model.voNative.SimStateNative.CLIENT_TRANSITIONS[ this.intValue_ ];
    var isValid = $.inArray(intValue, aryOfValidTransitions);
    
    
    if (isValid == -1) {
      return false;
    } else {
      return true;
    }
  } else {
    //debugger;
  }
  
  

  
};



 

lgb.simulation.model.voNative.SimStateNative.TEXT = {
  
  0 : 'uninitialized',
  1: 'connect_requested',
  2: 'connect_completed',
  3: 'xmlParse_requested',
  4: 'xmlParse_completed',
  
  5: 'init_requested',
  6: 'init_dllLoaded',
  7: 'init_instantiatedSlaves',
  8: 'init_initializedSlaves',
  9:'init_completed',
  
  10:'ready',
  
  11:'run_requested',
  12:'run_started',
  13:'run_completed',
  14:'cleanedup',
  
  15:'stop_requested',
  16:'stop_completed',
  
  17:'step_requested',
  18:'step_started',
  19:'step_completed',
  
  20:'pause_requested',
  21:'pause_completed',
  
  22:'terminate_requested',
  23:'terminate_completed',
  
  24:'reset_requested',
  25:'reset_completed',
  
  26:'resume_requested',
  27:'resume_completed',
  
  28:'e_error',
  29:'unknown'
  
};


lgb.simulation.model.voNative.SimStateNative.ENUM = {
  simStateNative_0_uninitialized: 0,
  simStateNative_1_connect_requested: 1,
  simStateNative_1_connect_completed: 2,
  
  simStateNative_2_xmlParse_requested: 3,
  simStateNative_2_xmlParse_completed: 4,

  simStateNative_3_init_requested: 5,
  simStateNative_3_init_dllLoaded: 6,
  simStateNative_3_init_instantiatedSlaves: 7,
  simStateNative_3_init_initializedSlaves: 8,
  simStateNative_3_init_completed: 9,
  
  simStateNative_3_ready: 10,
  
  simStateNative_4_run_requested: 11,
  simStateNative_4_run_started: 12,
  simStateNative_4_run_completed: 13,
  simStateNative_4_run_cleanedup: 14,
  
  simStateNative_5_stop_requested: 15,
  simStateNative_5_stop_completed: 16,
  
  simStateNative_5_step_requested: 17,
  simStateNative_5_step_started: 18,
  simStateNative_5_step_completed: 19,
  
  simStateNative_6_pause_requested: 20,
  simStateNative_6_pause_completed: 21,
  
  simStateNative_7_terminate_requested: 22,
  simStateNative_7_terminate_completed: 23,
  
  simStateNative_7_reset_requested: 24,
  simStateNative_7_reset_completed: 25,
  
  simStateNative_7_resume_requested: 26,
  simStateNative_7_resume_completed: 27,
  
  simStateNative_e_error: 28,
  simStateNative_unknown:29
};



lgb.simulation.model.voNative.SimStateNative.fieldPrimativesEx_ = {
   intValue_: "intValue"
};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.SimStateNativeRequest');
goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.voNative.SimStateNative');

/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.SimStateNativeRequest = function(payload) {
  lgb.simulation.events.BaseEvent.call(this, payload);
};
goog.inherits(lgb.simulation.events.SimStateNativeRequest, lgb.simulation.events.BaseEvent);



lgb.simulation.events.SimStateNativeRequest.prototype.getPayloadType = function() {
  return lgb.simulation.model.voNative.SimStateNative;
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.model.WebSocketConnectionState');
goog.provide('lgb.simulation.model.WebSocketConnectionStateRequest');
goog.provide('lgb.simulation.model.WSConnectionState');


/**
 * @enum {number}
 */
lgb.simulation.model.WebSocketConnectionState = {
  uninitialized: 0,
  open_requested: 1,
  opened: 2,
  closed: 3,
  timed_out: 4,
  dropped: 5,
  error:6
};



lgb.simulation.model.WebSocketConnectionStateRequest = {
  open: 0,
  close: 1
};




lgb.simulation.model.WSConnectionState = function(enum_arg) {
  
  if (undefined != enum_arg) {
    this.setIntValue(enum_arg);
  }
  
};



lgb.simulation.model.WSConnectionState.prototype.setIntValue  = function( enum_arg ) {
  this.enum_ = enum_arg;
};


lgb.simulation.model.WSConnectionState.prototype.getIntValue  = function(  ) {
  return this.enum_;
};


lgb.simulation.model.WSConnectionState.prototype.getString  = function(  ) {
  var str = lgb.simulation.model.WSConnectionState.TEXT[this.enum_];
  return str;
};


lgb.simulation.model.WSConnectionState.prototype.canRequestTransitionTo  = function( enum_arg ) {
  
  // if (enum_arg == 3 ) {
    // debugger;
  // }
//   
  var aryOfValidTransitions = lgb.simulation.model.WSConnectionState.CLIENT_TRANSITIONS[ this.enum_ ];
  var isValid = $.inArray(enum_arg, aryOfValidTransitions);
  
  
  if (isValid == -1) {
    return false;
  } else {
    return true;
  }
  
};



lgb.simulation.model.WSConnectionState.CLIENT_TRANSITIONS = {
  0 : [2],
  1: [],
  2: [3],
  3: [2],
  4: [],
  5: [],
  6: []
};



lgb.simulation.model.WSConnectionState.TEXT = {
  0 : 'uninitialized',
  1: 'open_requested',
  2: 'opened',
  3: 'closed',
  4: 'timed_out',
  5: 'dropped',
  6: 'error'
};


lgb.simulation.model.WSConnectionState.ENUM = {
  uninitialized: 0,
  open_requested: 1,
  opened: 2,
  closed: 3,
  timed_out: 4,
  dropped: 5,
  error:6
};

goog.provide('lgb.gui.view.SimulationStateControlGUIh');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');

goog.require('lgb.component.LinkDataSource');
goog.require('lgb.component.Link');

goog.require('lgb.simulation.model.WebSocketConnectionStateRequest');
goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.WSConnectionState');
goog.require('lgb.simulation.events.SimStateNativeRequest');
goog.require('lgb.simulation.model.voNative.SimStateNative');


lgb.gui.view.SimulationStateControlGUIh = function(dataModel) {


  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
};
goog.inherits(lgb.gui.view.SimulationStateControlGUIh, lgb.gui.view.BaseGUI);


/**
 * @public
 */
lgb.gui.view.SimulationStateControlGUIh.prototype.init = function() {
  
    this.listenForChange_('webSocketConnectionState');
    this.listenForChange_('simStateNative');
    this.listenForChange_('scalarValueResultsConverted');
    
};


lgb.gui.view.SimulationStateControlGUIh.prototype.onChange_scalarValueResultsConverted_ = 
  function(scalarValueResultsConverted) {
  
  this.simTime_.html (scalarValueResultsConverted.time_);
  
};


lgb.gui.view.SimulationStateControlGUIh.prototype.onChange_simStateNative_ = function(stateObject) {
  

  //var stateObject = new lgb.simulation.model.voNative.SimStateNative(simStateNative);
  goog.asserts.assert(stateObject, "stateObject not set");

  var str = stateObject.getString();
  goog.asserts.assert(str);
  
  
  var msg = "{0}:{1}".format(stateObject.getIntValue(), stateObject.getString());
  this.simStatus_.html (msg);
  this.each(this.simControlButtons_, this.checkIfButtonEnabled_, stateObject);

};


lgb.gui.view.SimulationStateControlGUIh.prototype.onChange_webSocketConnectionState_ = function(webSocketConnectionState) {
  
  var WebSocketConnectionState = lgb.simulation.model.WebSocketConnectionState;
  var stateObject = new lgb.simulation.model.WSConnectionState(webSocketConnectionState);
  
  var canConnect = stateObject.canRequestTransitionTo(lgb.simulation.model.WSConnectionState.ENUM.opened);
  var canDisconnect = stateObject.canRequestTransitionTo(lgb.simulation.model.WSConnectionState.ENUM.closed);
  
  var msg = "{0}:{1}".format(stateObject.getIntValue(), stateObject.getString());
  this.wsStatus_.html (msg);
  
  this.wsConnectLink_.setEnabled(canConnect);
  this.wsDisConnectLink_.setEnabled(canDisconnect);

};


lgb.gui.view.SimulationStateControlGUIh.prototype.checkIfButtonEnabled_ = function(button, stateObject) {
  
  var buttonPayloadState = button.ds.clickPayload;
  
  var isEnabled = stateObject.canRequestTransitionTo(buttonPayloadState);
  button.setEnabled(isEnabled);
  
};


lgb.gui.view.SimulationStateControlGUIh.prototype.add = function(gui) {

  var title = gui.getTitle();
  var contentElement;
  
  if (this.tabTitleMap_[title]) {
    contentElement = this.tabTitleMap_[title];
  } else {
    
    contentElement = this.tabStrip1.addTab(title);
    this.tabTitleMap_[title] = contentElement;
  }
  
  gui.injectInto(contentElement);
  
};


/**
 * @public
 */
lgb.gui.view.SimulationStateControlGUIh.prototype.injectInto = function(parentElement) {
  

  goog.base(this,  'injectInto', parentElement);

  var el = this.getMainElement();
  

  
  this.wsConnectLink_ = this.makeLink1_('Socket Open', 'wsConnect');
  this.wsDisConnectLink_ = this.makeLink1_('Socket Close', 'wsDisConnect');
  
  
  var state1 = $('<span>State:</span>')
  .addClass('simulation-state');

  this.wsStatus_ = $('<strong>{}</strong>');
  state1.append(this.wsStatus_);
  
  el.append(state1);
  
  var time1 = $('<span>Time:</span>')
  .addClass('simulation-state');

  this.simTime_ = $('<strong>{}</strong>');
  time1.append(this.simTime_);
  
  el.append(time1);

  el.append('<br />');



  this.simControlButtons_ = new Array();
  var SimStateNative = lgb.simulation.model.voNative.SimStateNative.ENUM;
  
  
  this.makeLink2_('Connect~', 'connect-link', SimStateNative.simStateNative_1_connect_requested);
  this.makeLink2_('XML Parse {}', 'xmlParse-link', SimStateNative.simStateNative_2_xmlParse_requested);
  this.makeLink2_('Init ^', 'init-link', SimStateNative.simStateNative_3_init_requested);
  
  this.makeLink2_('Run ^', 'run-link', SimStateNative.simStateNative_4_run_requested);
  this.makeLink2_('Step >', 'step-link', SimStateNative.simStateNative_5_step_requested);
  this.makeLink2_('Stop []', 'stop-link', SimStateNative.simStateNative_5_stop_requested);
  
  this.makeLink2_('Terminate.', 'terminate-link', SimStateNative.simStateNative_7_terminate_requested);
  
  
  var state2 = $('<span>State:</span>')
  .addClass('simulation-state');
  

  this.simStatus_ = $('<strong>{}</strong>');
  state2.append(this.simStatus_);
  
  el.append(state2);
  
  
  this.bind2_();
  


};


lgb.gui.view.SimulationStateControlGUIh.prototype.bind2_ = function() {

    this.listenTo(this.wsConnectLink_, e.MouseClick, this.onWsConnectLink_);
    this.listenTo(this.wsDisConnectLink_, e.MouseClick, this.onWsDisConnectLink_);
  
    var len = this.simControlButtons_.length;
    for (var i = 0; i < len - 1; i++) {

        var button = this.simControlButtons_[i];
        this.listenTo(button, e.MouseClick, this.onClickSimStateNativeRequest_);

    };

};





lgb.gui.view.SimulationStateControlGUIh.prototype.makeLink2_ = function(label, cssId, simStateNative) {
  
  var link = this.makeLink1_(label, cssId);
  link.ds.clickPayload = simStateNative;
  this.simControlButtons_.push(link);
  
};


lgb.gui.view.SimulationStateControlGUIh.prototype.makeLink1_ = function(label, cssId) {
  
  var ds = new lgb.component.LinkDataSource(label, this.htmlID, cssId);
  ds.cssClass = "sim";
  var link = new lgb.component.Link(ds);
  
  var el = this.getMainElement();
  var html = link.getHTML();
  
  var result = el.append(html);
  var idx = el.children.length-1;
  
  link.bind(el.children[idx]);
  
  return link;
  
};


lgb.gui.view.SimulationStateControlGUIh.prototype.onClickSimStateNativeRequest_ = function(event) {
  
    var simStateInt = event.target.ds.clickPayload;
    var simStateNative = new lgb.simulation.model.voNative.SimStateNative(simStateInt);
    
    var newEvent = new lgb.simulation.events.SimStateNativeRequest(simStateNative);
    this.dispatchLocal(newEvent);
    
    //this.triggerLocal(se.SimStateNativeRequest, simStateNative);
    
};


lgb.gui.view.SimulationStateControlGUIh.prototype.onWsConnectLink_ = function(event) {
  
  this.triggerLocal(se.WebSocketChangeRequest, lgb.simulation.model.WebSocketConnectionStateRequest.open);
  
};

lgb.gui.view.SimulationStateControlGUIh.prototype.onWsDisConnectLink_ = function(event) {
  
  this.triggerLocal(se.WebSocketChangeRequest, lgb.simulation.model.WebSocketConnectionStateRequest.close);
  
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.ResultEventList');

goog.require('lgb.simulation.events.BaseEvent');


/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.ResultEventList = function(payload) {
  lgb.simulation.events.BaseEvent.call(this,  payload);
};

goog.inherits(lgb.simulation.events.ResultEventList, lgb.simulation.events.BaseEvent);



 
lgb.simulation.events.ResultEventList.prototype.getPayloadType = function() {
  return Array;
};goog.provide('lgb.simulation.model.voManaged.ScalarValueReal');


goog.require('lgb.simulation.model.BaseModel');

lgb.simulation.model.voManaged.ScalarValueReal = function(idx, value) {

  this.idx_ = idx;
  this.value_ = value;
};
goog.inherits(lgb.simulation.model.voManaged.ScalarValueReal, lgb.simulation.model.BaseModel);



lgb.simulation.model.voManaged.ScalarValueReal.prototype.getIdx = function() {
    return this.idx_;
};

 
lgb.simulation.model.voManaged.ScalarValueReal.prototype.getValue = function() {
    return this.value_;
};



lgb.simulation.model.voManaged.ScalarValueReal.fieldPrimativesEx_ = {
   idx_: "i" ,
   value_: "v" ,
};




goog.provide('lgb.simulation.model.voManaged.SessionControl');

goog.require('lgb.simulation.model.BaseModel');


lgb.simulation.model.voManaged.SessionControl = function(idx, value) {

  this.idx = idx;
  this.value = value;

};
goog.inherits(lgb.simulation.model.voManaged.SessionControl, lgb.simulation.model.BaseModel);




lgb.simulation.model.voManaged.SessionControl.fieldPrimativesEx_ = {
   idx: "idx" ,
   value: "value" ,
};

goog.provide('lgb.simulation.model.voNative.ScalarValueRealStruct');


goog.require('lgb.simulation.model.BaseModel');

lgb.simulation.model.voNative.ScalarValueRealStruct = function(idx, value) {

  this.idx = idx;
  this.value = value;
  lgb.simulation.model.BaseModel.call(this);
};

goog.inherits(lgb.simulation.model.voNative.ScalarValueRealStruct, lgb.simulation.model.BaseModel);




lgb.simulation.model.voNative.ScalarValueRealStruct.fieldPrimativesEx_ = {
   idx: "idx",
   value : "value"
};





/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.SessionControlEvent');
goog.require('lgb.simulation.events.BaseEvent');


/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.SessionControlEvent = function(payload) {
  lgb.simulation.events.BaseEvent.call(this, payload);
};
goog.inherits(lgb.simulation.events.SessionControlEvent, lgb.simulation.events.BaseEvent);



 
lgb.simulation.events.SessionControlEvent.prototype.getPayloadType = function() {
  return lgb.simulation.model.voManaged.SessionControl;
};goog.provide('lgb.simulation.model.voManaged.SerializableVector');

goog.require('lgb.simulation.model.BaseModel');



lgb.simulation.model.voManaged.SerializableVector = function(itemTypeString, itemArray) {

  this.itemTypeString_ = itemTypeString;
  this.itemArray_ = itemArray;

};
goog.inherits(lgb.simulation.model.voManaged.SerializableVector, lgb.simulation.model.BaseModel);



lgb.simulation.model.voManaged.SerializableVector.prototype.toArray = function() {
  return this.itemArray_ ;
};

lgb.simulation.model.voManaged.SerializableVector.prototype.toJSON = function() {
    
    var ary = [];
    var len = this.itemArray_.length;
    for (var i=0; i < len; i++) {
      
     this.itemArray_[i].serializeType = false;

    };
    
    var jsonObj = {
      t:this.getClassName(),
      itemType:this.itemTypeString_,
      itemArray:this.itemArray_
    };
    
    
    return jsonObj;
};



// lgb.simulation.model.voManaged.SerializableVector.prototype.fromJSON = function(deserializedObj) {
//     
// 
    // this.fromJSONHelper_(deserializedObj);
//     
    // this.itemArray_  = [];
//     
//     
    // if (undefined == deserializedObj.itemArray) {
      // debugger;
    // }
//     
    // var len = deserializedObj.itemArray.length;
//     
    // for (var i=0; i < len; i++) {
//       
      // var deserializedItem =  deserializedObj.itemArray[i];
      // deserializedItem.t = this.itemTypeString_;
//       
      // var typedItem =  lgb.simulation.controller.JsonController().makeTyped(deserializedItem);
      // this.itemArray_ .push(typedItem);
    // };
// 
// 
// };




lgb.simulation.model.voManaged.SerializableVector.fieldPrimativesEx_ = {
   itemTypeString_: "itemType" ,
};
goog.provide('lgb.simulation.model.voManaged.ScalarValueCollection');


goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voManaged.ScalarValueReal');
goog.require('lgb.simulation.model.voManaged.SerializableVector');


lgb.simulation.model.voManaged.ScalarValueCollection = function(realList) {
  
  this.realList_ = realList;

};
goog.inherits(lgb.simulation.model.voManaged.ScalarValueCollection, lgb.simulation.model.BaseModel);



lgb.simulation.model.voManaged.ScalarValueCollection.prototype.getRealList = function() {
  return  this.realList_;
};



lgb.simulation.model.voManaged.ScalarValueCollection.fieldObjectsEx_ = {
  
   realList_: {
     jsonFieldName : "realList",
     classReference : lgb.simulation.model.voManaged.SerializableVector,
     itemTypeString : "ScalarValueReal"
   }
       
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.ScalarValueChangeRequest');
goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.voManaged.ScalarValueCollection');


lgb.simulation.events.ScalarValueChangeRequest = function(payload) {
  lgb.simulation.events.BaseEvent.call(this, payload);
};
goog.inherits(lgb.simulation.events.ScalarValueChangeRequest, lgb.simulation.events.BaseEvent);



 
lgb.simulation.events.ScalarValueChangeRequest.prototype.getPayloadType = function() {
  return lgb.simulation.model.voManaged.ScalarValueCollection;
};goog.provide('lgb.simulation.model.voManaged.ScalarValueResults');

goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voManaged.ScalarValueCollection');



lgb.simulation.model.voManaged.ScalarValueResults = function() {


};
goog.inherits(lgb.simulation.model.voManaged.ScalarValueResults, lgb.simulation.model.BaseModel);



lgb.simulation.model.voManaged.ScalarValueResults.prototype.getTime = function() {
    return this.time_;
};


lgb.simulation.model.voManaged.ScalarValueResults.prototype.getInput = function() {
    return this.input;
};


lgb.simulation.model.voManaged.ScalarValueResults.prototype.getOutput = function() {
    return this.output;
};




lgb.simulation.model.voManaged.ScalarValueResults.fieldObjectsEx_ = {
  
   input: {
     jsonFieldName : "input",
     classReference : lgb.simulation.model.voManaged.ScalarValueCollection
   },
   output: {
     jsonFieldName : "output",
     classReference : lgb.simulation.model.voManaged.ScalarValueCollection
   },
       
};


lgb.simulation.model.voManaged.ScalarValueResults.fieldPrimativesEx_ = {
   time_: "time_" 
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.ResultEvent');

goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.voManaged.ScalarValueResults');

/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.ResultEvent = function(payload) {
  lgb.simulation.events.BaseEvent.call(this,  payload);
};

goog.inherits(lgb.simulation.events.ResultEvent, lgb.simulation.events.BaseEvent);



lgb.simulation.events.ResultEvent.prototype.getPayloadType = function() {
  return lgb.simulation.model.voManaged.ScalarValueResults;
};goog.provide('lgb.simulation.model.voNative.TypeSpecReal');

goog.require('lgb.simulation.model.BaseModel');



lgb.simulation.model.voNative.TypeSpecReal = function() {

  this.start = 0.0;
  this.nominal = 0.0;
  this.min = 0.0;
  this.max = 0.0;

  this.startValueStatus = 1;
  this.nominalValueStatus = 1;
  this.minValueStatus = 1;
  this.maxValueStatus = 1;
  
  this.unit = "";
  this.unitValueStatus = 1;
  lgb.simulation.model.BaseModel.call(this);
};
goog.inherits(lgb.simulation.model.voNative.TypeSpecReal, lgb.simulation.model.BaseModel);



lgb.simulation.model.voNative.TypeSpecReal.fieldPrimativesEx_ = {
   start: "start",
   nominal: "nominal",
   min: "min",
   max: "max",
   unit: "unit"
};


goog.provide('lgb.simulation.model.voNative.Enu');

goog.require('lgb.simulation.model.BaseModel');

lgb.simulation.model.voNative.Enu = function(enumInteger) {
  
  this.intValue_ = 0;
  
  if (undefined != enumInteger) {
    this.setIntValue(enumInteger);
  }
    lgb.simulation.model.BaseModel.call(this);
};
goog.inherits(lgb.simulation.model.voNative.Enu, lgb.simulation.model.BaseModel);



lgb.simulation.model.voNative.Enu.prototype.setIntValue  = function( intValue ) {
  
    this.intValue_ = intValue;

};

lgb.simulation.model.voNative.Enu.prototype.getIntValue  = function(  ) {
  return this.intValue_;
};



lgb.simulation.model.voNative.Enu.prototype.toString  = function(  ) {
  var str = lgb.simulation.model.voNative.Enu.TEXT[this.intValue_];
  return str;
};



 

lgb.simulation.model.voNative.Enu.TEXT = {
  
  0 : 'flat',
  1: 'structured',
  2: 'constant',
  3: 'parameter',
  4: 'discrete',
  
  5: 'continuous',
  6: 'input',
  7: 'output',
  8: 'internal',
  9:'none',
  
  10:'noAlias',
  
  11:'alias',
  12:'negatedAlias'
  
};


lgb.simulation.model.voNative.Enu.ENUM = {
  enu_flat: 0,
  enu_structured: 1,
  enu_constant: 2,
  
  enu_parameter: 3,
  enu_discrete: 4,

  enu_continuous: 5,
  enu_input: 6,
  enu_output: 7,
  enu_internal: 8,
  enu_none: 9,
  
  enu_noAlias: 10,
  
  enu_alias: 11,
  enu_negatedAlias: 12,
};



lgb.simulation.model.voNative.Enu.fieldPrimativesEx_ = {
   intValue_: "intValue" 
};





goog.provide('lgb.simulation.model.voManaged.ScalarVariableReal');

goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voNative.Enu');
goog.require('lgb.simulation.model.voNative.TypeSpecReal');

lgb.simulation.model.voManaged.ScalarVariableReal = function(typeSpecReal) {
  
  this.name_ = "";
  this.idx_ = 0;
  this.causality_ = 0;
  this.variability_ = 0;
  this.description_ = "";
  this.unit_ = 0;
  this.valueReference_ = 0;
  this.typeSpecReal_ = typeSpecReal;
  this.serializeType = true;
  
};
goog.inherits(lgb.simulation.model.voManaged.ScalarVariableReal, lgb.simulation.model.BaseModel);




lgb.simulation.model.voManaged.ScalarVariableReal.prototype.setName = function(name) {
  this.name_ = name;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.setIdx = function(idx) {
  this.idx_ = idx;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.setCausality = function(causality) {
  this.causality_ = causality;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.setVariability = function(variability) {
  this.variability_ = variability;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.setDescription = function(description) {
  this.description_ = description;
};


lgb.simulation.model.voManaged.ScalarVariableReal.prototype.setValueReference = function(valueReference) {
  this.valueReference_ = valueReference;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.setTypeSpecReal = function(typeSpecReal) {
  this.typeSpecReal_ = typeSpecReal;
};


lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getName = function() {
  return this.name_;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getIdx = function() {
  return this.idx_;
};


lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getCausalityAsInt = function() {
  return this.causality_;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getCausalityAsEnum = function() {
  var theEnum = new lgb.simulation.model.voNative.Enu(this.causality_);
  return theEnum;
};


lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getVariabilityAsInt = function() {
  return this.variability_;
};


lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getVariabilityAsEnum = function() {
  var theEnum = new lgb.simulation.model.voNative.Enu(this.variability_);
  return theEnum;
};


lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getDescription = function() {
  return this.description_;
};
                                                            
lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getValueReference = function() {
  return this.valueReference_;
};

lgb.simulation.model.voManaged.ScalarVariableReal.prototype.getTypeSpecReal = function() {
  return this.typeSpecReal_;
};





lgb.simulation.model.voManaged.ScalarVariableReal.fieldPrimativesEx_ = {
   name_: "n" ,
   idx_: "i" ,
   causality_: "c" ,
   variability_: "vb" ,
   description_: "d" ,
   valueReference_: "vr" 
};


lgb.simulation.model.voManaged.ScalarVariableReal.fieldObjectsEx_ = {
  
   typeSpecReal_: {
     jsonFieldName : "typeSpecReal",
     classReference : lgb.simulation.model.voNative.TypeSpecReal
   }  
       
};







goog.provide('lgb.simulation.model.voManaged.ScalarVariableCollection');


goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voManaged.ScalarVariableReal');
goog.require('lgb.simulation.model.voManaged.SerializableVector');



lgb.simulation.model.voManaged.ScalarVariableCollection = function(realVarList) {
  
  this.realVarList_ = realVarList || [];

};
goog.inherits(lgb.simulation.model.voManaged.ScalarVariableCollection, lgb.simulation.model.BaseModel);




lgb.simulation.model.voManaged.ScalarVariableCollection.prototype.setRealVarList = function(realVarList) {
  this.realVarList_ = realVarList;
};


lgb.simulation.model.voManaged.ScalarVariableCollection.prototype.getRealVarList = function() {
  return this.realVarList_;
};






lgb.simulation.model.voManaged.ScalarVariableCollection.fieldObjectsEx_ = {
  
   realVarList_: {
     jsonFieldName : "realVarList_",
     classReference : lgb.simulation.model.voManaged.SerializableVector,
     itemTypeString : "ScalarVariableReal"
   }
       
};



goog.provide('lgb.simulation.model.voNative.DefaultExperimentStruct');

goog.require('lgb.simulation.model.BaseModel');

lgb.simulation.model.voNative.DefaultExperimentStruct = function(startTime, stopTime, tolerance) {

  this.startTime = startTime || 0.0;
  this.stopTime = stopTime || 0.0;
  this.tolerance = tolerance || 0.0;

  lgb.simulation.model.BaseModel.call(this);
};
goog.inherits(lgb.simulation.model.voNative.DefaultExperimentStruct, lgb.simulation.model.BaseModel);



lgb.simulation.model.voNative.DefaultExperimentStruct.fieldPrimativesEx_ = {
   startTime: "startTime" ,
   stopTime: "stopTime" ,
   tolerance: "tolerance" 
};

goog.provide('lgb.simulation.model.voNative.ConfigStruct');

goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voNative.DefaultExperimentStruct');


lgb.simulation.model.voNative.ConfigStruct  = function(defaultExperimentStruct, stepDelta) {
  
  this.stepDelta = stepDelta;
  this.defaultExperimentStruct = defaultExperimentStruct;
  
  lgb.simulation.model.BaseModel.call(this);
};
goog.inherits(lgb.simulation.model.voNative.ConfigStruct, lgb.simulation.model.BaseModel);





lgb.simulation.model.voNative.ConfigStruct.fieldPrimativesEx_ = {
   stepDelta: "stepDelta"
};


lgb.simulation.model.voNative.ConfigStruct.fieldObjectsEx_ = {
  
   defaultExperimentStruct: {
     jsonFieldName : "defaultExperimentStruct",
     classReference : lgb.simulation.model.voNative.DefaultExperimentStruct
   }
   
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.ConfigChangeNotify');

goog.require('lgb.simulation.model.voNative.ConfigStruct');
goog.require('lgb.simulation.events.BaseEvent');


/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.ConfigChangeNotify = function(payload) {
  lgb.simulation.events.BaseEvent.call(this,  payload);
};

goog.inherits(lgb.simulation.events.ConfigChangeNotify, lgb.simulation.events.BaseEvent);



lgb.simulation.events.ConfigChangeNotify.prototype.getPayloadType = function() {
  return lgb.simulation.model.voNative.ConfigStruct;
};


goog.provide('lgb.simulation.model.voManaged.ScalarVariablesAll');

goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voManaged.ScalarVariableCollection');

lgb.simulation.model.voManaged.ScalarVariablesAll = function() {

  this.input_ = null;
  this.output_ = null;
  this.internal_ = null;


};
goog.inherits(lgb.simulation.model.voManaged.ScalarVariablesAll, lgb.simulation.model.BaseModel);



lgb.simulation.model.voManaged.ScalarVariablesAll.prototype.setInput = function(input) {
  this.input_ = input;
};

lgb.simulation.model.voManaged.ScalarVariablesAll.prototype.setOutput = function(output) {
  this.output_ = output;
};

lgb.simulation.model.voManaged.ScalarVariablesAll.prototype.setInternal = function(internal) {
  this.internal_ = internal;
};






lgb.simulation.model.voManaged.ScalarVariablesAll.fieldObjectsEx_ = {
  
   input_: {
     jsonFieldName : "input",
     classReference : lgb.simulation.model.voManaged.ScalarVariableCollection
   },
   output_: {
     jsonFieldName : "output",
     classReference : lgb.simulation.model.voManaged.ScalarVariableCollection
   },
   internal_: {
     jsonFieldName : "internal",
     classReference : lgb.simulation.model.voManaged.ScalarVariableCollection
   },
       
};








/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.model.voNative.MessageType');

/**
 * @enum {number}
 */
lgb.simulation.model.voNative.MessageType = {
  messageType_debug: 0,
  messageType_info: 1,
  messageType_error: 2
};

goog.provide('lgb.simulation.model.voManaged.XMLparsedInfo');

goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voManaged.ScalarVariablesAll');

lgb.simulation.model.voManaged.XMLparsedInfo = function(scalarVariablesAll) {

  this.scalarVariablesAll_ = scalarVariablesAll;
  this.sessionID_ = null;

};
goog.inherits(lgb.simulation.model.voManaged.XMLparsedInfo, lgb.simulation.model.BaseModel);





lgb.simulation.model.voManaged.XMLparsedInfo.fieldPrimativesEx_ = {
   sessionID_: "sessionID_" 
};



lgb.simulation.model.voManaged.XMLparsedInfo.fieldObjectsEx_ = {
  
   scalarVariablesAll_: {
     jsonFieldName : "scalarVariablesAll_",
     classReference : lgb.simulation.model.voManaged.ScalarVariablesAll,
   }
   
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.XMLparsedEvent');

goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.voManaged.XMLparsedInfo');

/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.XMLparsedEvent = function(payload) {
  lgb.simulation.events.BaseEvent.call(this,  payload);
};

goog.inherits(lgb.simulation.events.XMLparsedEvent, lgb.simulation.events.BaseEvent);



lgb.simulation.events.XMLparsedEvent.prototype.getPayloadType = function() {
  return lgb.simulation.model.voManaged.XMLparsedInfo;
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.SimStateNativeNotify');

goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.voNative.SimStateNative');



/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.SimStateNativeNotify = function(payload) {
  lgb.simulation.events.BaseEvent.call(this,  payload);
};

goog.inherits(lgb.simulation.events.SimStateNativeNotify, lgb.simulation.events.BaseEvent);





lgb.simulation.events.SimStateNativeNotify.prototype.getPayloadType = function() {
  return lgb.simulation.model.voNative.SimStateNative;
};


goog.provide('lgb.simulation.model.voNative.MessageStruct');

goog.require('lgb.simulation.model.BaseModel');
goog.require('lgb.simulation.model.voNative.MessageType');


lgb.simulation.model.voNative.MessageStruct = function(msgText, messageType) {

  this.msgText = msgText || "{not set}";
  this.messageType = messageType;
  
  lgb.simulation.model.BaseModel.call(this);
};
goog.inherits(lgb.simulation.model.voNative.MessageStruct, lgb.simulation.model.BaseModel);




lgb.simulation.model.voNative.MessageStruct.fieldPrimativesEx_ = {
   msgText: "msgText",
   messageType : "messageType"
};





/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.events.MessageEvent');

goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.voNative.MessageStruct');
goog.require('lgb.simulation.model.voNative.MessageType');

/**
 * @constructor
 * @param {lgb.scenario.model.Base} scenarioBase The Data Model.
 * @extends {goog.events.Event}
 */
lgb.simulation.events.MessageEvent = function(payload) {
  lgb.simulation.events.BaseEvent.call(this,  payload);
};
goog.inherits(lgb.simulation.events.MessageEvent, lgb.simulation.events.BaseEvent);


lgb.simulation.events.MessageEvent.prototype.getPayloadType = function() {
  return lgb.simulation.model.voNative.MessageStruct;
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.controller.JsonController');


goog.require('lgb.core.BaseController');

goog.require('lgb.simulation.events.ConfigChangeNotify');
goog.require('lgb.simulation.events.MessageEvent');
goog.require('lgb.simulation.events.ResultEvent');
goog.require('lgb.simulation.events.ResultEventList');
goog.require('lgb.simulation.events.ScalarValueChangeRequest');
goog.require('lgb.simulation.events.SessionControlEvent');
goog.require('lgb.simulation.events.SimStateNativeNotify');
goog.require('lgb.simulation.events.SimStateNativeRequest');
goog.require('lgb.simulation.events.XMLparsedEvent');

goog.require('lgb.simulation.model.voNative.ConfigStruct');
goog.require('lgb.simulation.model.voNative.DefaultExperimentStruct');
goog.require('lgb.simulation.model.voNative.MessageStruct');
goog.require('lgb.simulation.model.voNative.MessageType');
goog.require('lgb.simulation.model.voNative.ScalarValueRealStruct');
goog.require('lgb.simulation.model.voNative.SimStateNative');
goog.require('lgb.simulation.model.voNative.TypeSpecReal');

goog.require('lgb.simulation.model.voManaged.ScalarValueResults');
goog.require('lgb.simulation.model.voManaged.ScalarValueReal');
goog.require('lgb.simulation.model.voManaged.ScalarValueCollection');


goog.require('lgb.simulation.model.voManaged.ScalarVariableReal');
goog.require('lgb.simulation.model.voManaged.ScalarVariableCollection');
goog.require('lgb.simulation.model.voManaged.ScalarVariablesAll');






lgb.simulation.controller.JsonController = function() {
  
    if ( lgb.simulation.controller.JsonController.prototype._singletonInstance ) {
      return lgb.simulation.controller.JsonController.prototype._singletonInstance;
    }
    
    lgb.simulation.controller.JsonController.prototype._singletonInstance = this;
    
    this.deserializeMap_ = {
      
          "ConfigChangeNotify":         lgb.simulation.events.ConfigChangeNotify,  
          "MessageEvent":               lgb.simulation.events.MessageEvent,
          "ResultEvent" :               lgb.simulation.events.ResultEvent,
          "ResultEventList" :           lgb.simulation.events.ResultEventList, 
          "ScalarValueChangeRequest" :  lgb.simulation.events.ScalarValueChangeRequest, 
          "SessionControlEvent" :       lgb.simulation.events.SessionControlEvent, 
          "SimStateNativeNotify":       lgb.simulation.events.SimStateNativeNotify,
          "SimStateNativeRequest":      lgb.simulation.events.SimStateNativeRequest,
          "XMLparsedEvent":             lgb.simulation.events.XMLparsedEvent,
          
          "ConfigStruct" :              lgb.simulation.model.voNative.ConfigStruct,
          "DefaultExperimentStruct" :   lgb.simulation.model.voNative.DefaultExperimentStruct,
          "MessageStruct" :             lgb.simulation.model.voNative.MessageStruct,
          "MessageType" :               lgb.simulation.model.voNative.MessageType,
          "ScalarValueRealStruct" :     lgb.simulation.model.voNative.ScalarValueRealStruct,
          "SimStateNative" :            lgb.simulation.model.voNative.SimStateNative,
          "TypeSpecReal" :              lgb.simulation.model.voNative.TypeSpecReal,
          
          "ScalarValueResults" :        lgb.simulation.model.voManaged.ScalarValueResults,
          "ScalarValueReal" :           lgb.simulation.model.voManaged.ScalarValueReal,
          "ScalarValueCollection" :     lgb.simulation.model.voManaged.ScalarValueCollection,
          
          "ScalarVariableReal" :        lgb.simulation.model.voManaged.ScalarVariableReal,
          "ScalarVariableCollection" :  lgb.simulation.model.voManaged.ScalarVariableCollection,
          "ScalarVariablesAll" :        lgb.simulation.model.voManaged.ScalarVariablesAll

    };


  return;
};
goog.inherits(lgb.simulation.controller.JsonController, lgb.core.BaseController);





lgb.simulation.controller.JsonController.getShortClassName = function(deserializedObj) {
  
    var type = deserializedObj.type;
    
    var ary = type.split(".");
    var eventTypeShort = ary.pop();
  
    return eventTypeShort;
};







lgb.simulation.controller.JsonController.prototype.getClass = function(deserializedObj) {
  
   // var eventTypeShort = lgb.simulation.controller.JsonController.getShortClassName(deserializedObj);

    var classNameStr = deserializedObj.t;
    
    if (this.deserializeMap_.hasOwnProperty(classNameStr)) {
      
      var classReference = this.deserializeMap_[classNameStr];
      return classReference;
      
      
    } else {
      debugger;
       //throw ("JsonController.deserialize() failed due to unknown type: "+ classNameStr);
    }
    
    
};



lgb.simulation.controller.JsonController.prototype.deserialize = function(jsonString) {


    var deserializedObj = JSON && JSON.parse(jsonString) || $.parseJSON(jsonString);
    var typedObj = this.makeTyped(deserializedObj);
      
    return typedObj;


};

lgb.simulation.controller.JsonController.prototype.makeTyped = function(deserializedObj) {

    var classReference = this.getClass(deserializedObj);
    
    var instance = new classReference();
    
    
  if (undefined != classReference.fieldPrimativesEx_) {
    
    var fieldPrimativesEx = classReference.fieldPrimativesEx_;

    for(var jsFieldName in fieldPrimativesEx) {
      
      var jsonFieldName = fieldPrimativesEx[jsFieldName];
      instance[jsFieldName] = deserializedObj[jsonFieldName];
      
    }
  }
  
  if (undefined != classReference.fieldObjectsEx_) {
    
    var fieldObjectsEx = classReference.fieldObjectsEx_;

    for(var jsFieldName in fieldObjectsEx) {
      
      var fieldObject = fieldObjectsEx[jsFieldName];   
      var jsonFieldName = fieldObject.jsonFieldName;
      var fieldClassReference = fieldObject.classReference;
      
      
      if (null == fieldClassReference) {
        debugger;
      }
      
      var childDeserializedObj = deserializedObj[jsonFieldName];
      
      

      
      if (null != childDeserializedObj) { 
        
        //var childTypedObject = new fieldClassReference();
        
        var childTypedObject = this.makeTyped(childDeserializedObj);
        
        
        if (fieldClassReference == lgb.simulation.model.voManaged.SerializableVector) {
        
          instance[jsFieldName] = childTypedObject.toArray();
          
        } else {

          instance[jsFieldName] = childTypedObject;
          
        }
      
      }

    }
    
  }
  
  
    
    return instance;
    
};

lgb.simulation.controller.JsonController.serialize = function(jsonObj) {

    var jsonString = JSON.stringify(jsonObj, null, 0);
   // jsonString = jsonString.replace(/\s/g, '');
    
    return jsonString;
    
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 * Stores configuration information for the
 * app.
 * information about the datatypes used is here:
 * http://code.google.com/closure/compiler/docs/js-for-compiler.html
 */

goog.provide('lgb.core.Config');

/**@typedef {Object} */
lgb.core.Config = {};

/**
 * @define {boolean} If this is set to true, then all global events
 * are logged in lgb.core.EventBus.
 */
lgb.core.Config.DEBUG_EVENTS = false;


lgb.core.Config.DEBUG_3D = false;



/**
 * relative path to 3d assets includinf Three.js meshes and textures.
 * @const
 * @type {string}
 */
lgb.core.Config.ASSETS_BASE_PATH = '3d-assets/';

/**
 * relative path to all XML files.
 * @const
 * @type {string}
 */
lgb.core.Config.XML_BASE_PATH = 'xml/';

/**
 * Will apear in the <title>.
 * @const
 * @type {string}
 */
lgb.core.Config.APP_TITLE = 'LearnHPB Beta';

/**
 * The application verison, will appear in the <title>
 * @const
 * @type {string}
 */
lgb.core.Config.APP_VERSION = '1.35';

/**
 * Will show status in the upper left if set to true.
 * @const
 * @type {boolean}
 */
lgb.core.Config.SHOW_STATS = true;


lgb.core.Config.WEBGL_CONTAINER_DIV_ID = "webGLcontainerDiv";

/**
 * The file that holds the Three.js scene for all the particle systems.
 * @const
 * @type {string}
 */
lgb.core.Config.PARTICLE_SYSTEM_SCENE = lgb.core.Config.ASSETS_BASE_PATH +
'particle-systems/scene.json';


/**
 * the XML file for all the particle systems.
 * @const
 * @type {string}
 */
lgb.core.Config.PARTICLE_SYSTEM_XML = lgb.core.Config.XML_BASE_PATH +
'scene.xml';

/**
 * @return {string} The string used to inject into the <title>
 * tag in the DOM.
 */
lgb.core.Config.getTitle = function() {
  var str = '{0} - version {1}'.format(lgb.core.Config.APP_TITLE, lgb.core.Config.APP_VERSION);
  return str;
};


/**
 * @define {boolean} If this is set to true, then all global events
 * are logged in lgb.core.EventBus.
 */
lgb.core.Config.UTILITY_SHOW_GRID = true;

/**
 * @define {boolean} If this is set to true, then all global events
 * are logged in lgb.core.EventBus.
 */
lgb.core.Config.UTILITY_SHOW_AXIS = false;

lgb.core.Config.SOCKET_SERVER = function() {};
lgb.core.Config.SOCKET_SERVER.AutoConfig = 0;
lgb.core.Config.SOCKET_SERVER.Pfalco = 1;
lgb.core.Config.SOCKET_SERVER.PfalcoLocal = 2;
lgb.core.Config.SOCKET_SERVER.LocalHost = 3;
lgb.core.Config.SOCKET_SERVER.Cube = 4;

lgb.core.Config.SOCKET_SERVER_HOST = lgb.core.Config.SOCKET_SERVER.LocalHost;


lgb.core.Config.WEBROOT = "";

lgb.core.Config.SHOW_POPUPS = false;

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.simulation.model.MainModel');

goog.require('lgb.world.model.BaseModel');
goog.require('lgb.core.Config');
goog.require('lgb.simulation.model.WebSocketConnectionState');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.simulation.model.MainModel = function() {


  /**@const */
  this._TITLE = 'MainModel';
  lgb.world.model.BaseModel.call(this);

  this.simStateNative = lgb.simulation.model.voNative.SimStateNative.ENUM.simStateNative_0_uninitialized;
  this.webSocketConnectionState = lgb.simulation.model.WebSocketConnectionState.uninitialized;
  
  this.socketServerURL = null;
  this.messageStruct = null;
  this.xmlParsedInfo = null;
  this.scalarValueResults = null;
  
  this.scalarValueResultsConverted = null;
  
  this.modNameToVarMap_ = {};

};
goog.inherits(lgb.simulation.model.MainModel, lgb.world.model.BaseModel);


/**
 * Handler used for websocket init
 * @private
 */
lgb.simulation.model.MainModel.prototype.init = function(hostname) {
  

  this.socketServerURL = "ws://" + hostname + ":8081/";
  
};



lgb.simulation.model.MainModel.prototype.setScalarValueResults = function(scalarValueResults ) {


    this.scalarValueResults = scalarValueResults;
    this.dispatchChangedEx('scalarValueResults', scalarValueResults);
    
    this.calcScalarValueResultsConverted();
    

};



lgb.simulation.model.MainModel.prototype.calcScalarValueResultsConverted = function( ) {

    var totalSec = this.scalarValueResults.time_;
    
    var hours = parseInt( totalSec / 3600 ) % 24;
    var minutes = parseInt( totalSec / 60 ) % 60;
    var seconds = totalSec % 60;

    var friendlyTime = (hours < 10 ? "0" + hours : hours) + ":" + 
        (minutes < 10 ? "0" + minutes : minutes) + ":" + 
        (seconds  < 10 ? "0" + seconds : seconds);




    var outAry = this.convertRealValueList(
      this.scalarValueResults.output.realList_, 
      this.xmlParsedInfo.scalarVariablesAll_.output_.realVarList_);
      
      
    var inAry = this.convertRealValueList(
      this.scalarValueResults.input.realList_, 
      this.xmlParsedInfo.scalarVariablesAll_.input_.realVarList_);
    
    
    this.scalarValueResultsConverted = {
      time_:friendlyTime,
      input:{realList:inAry},
      output:{realList:outAry}
    };
    
    this.dispatchChangedEx('scalarValueResultsConverted', this.scalarValueResultsConverted);
    

};


lgb.simulation.model.MainModel.prototype.convertRealValueList = function(valueList, variableList) {
  
  
    var len = valueList.length;
    var newValueList = [];
    
    for (var i=0; i < len; i++) {
      
      var valueVo = valueList[i];
      var variableVo = variableList[i];

      var v = this.convertRealValue(valueVo, variableVo.typeSpecReal_.unit);
      
      newValueList.push( { value_ :  v} );
    };
    
    
  return newValueList;
};



lgb.simulation.model.MainModel.prototype.convertRealValue = function(realVo, unit) {

      
      var v = 0.0;
      
      switch(unit) {
        case "K" :
          //v = (realVo.value_-273.15);
          v = realVo.value_;
          break;
        case "C" :
          v = (realVo.value_-273.15);
          break;
        case "F" :
          v = (realVo.value_-273.15);
          v = v * 1.80 + 32.00;
          break;
        default :
          v = realVo.value_;
          break;
      }
      
  
      v = v.toFixed(2);
      return v;

};





lgb.simulation.model.MainModel.prototype.setWebSocketConnectionState = function(webSocketConnectionState) {

    this.changePropertyEx('webSocketConnectionState', webSocketConnectionState);

};



lgb.simulation.model.MainModel.prototype.getWebSocketConnectionState = function() {
    return this.webSocketConnectionState;
};





lgb.simulation.model.MainModel.prototype.getSimStateNative = function() {

    return this.simStateNative; 
};



lgb.simulation.model.MainModel.prototype.getIdxFromModelicaName = function(modelicaName) {

    
    return this.modNameToVarMap_[modelicaName]; 
};





lgb.simulation.model.MainModel.prototype.setXmlParseInfo = function(xmlParseInfo) {

  this.xmlParsedInfo = xmlParseInfo;
  
  var varList = xmlParseInfo.scalarVariablesAll_.input_.realVarList_;
  this.each(varList, this.idxOne_);
  
  
  this.dispatchChangedEx('xmlParsedInfo', xmlParseInfo);
  
};


lgb.simulation.model.MainModel.prototype.idxOne_ = function(theVar) {

  var theName = theVar.name_;
  
  if (undefined == theName) {
    debugger;
  }
  
  this.modNameToVarMap_[theName] = theVar;
};








 
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.simulation.controller.MainController');

goog.require('se.Event');

goog.require('lgb.core.BaseController');
goog.require('lgb.simulation.controller.JsonController');

goog.require('lgb.simulation.model.MainModel');
goog.require('lgb.simulation.model.WebSocketConnectionState');
goog.require('lgb.simulation.model.WebSocketConnectionStateRequest');
goog.require('lgb.simulation.model.voNative.ScalarValueRealStruct');
goog.require('lgb.simulation.model.voManaged.ScalarValueCollection');
goog.require('lgb.simulation.model.voManaged.ScalarValueReal');
goog.require('lgb.simulation.model.voManaged.SessionControl');


goog.require('lgb.simulation.events.SimStateNativeRequest');
goog.require('lgb.simulation.events.ScalarValueChangeRequest');
goog.require('lgb.simulation.events.ResultEventList');
goog.require('lgb.simulation.events.ResultEvent');
goog.require('lgb.simulation.events.SessionControlEvent');




lgb.simulation.controller.MainController = function() {
    lgb.core.BaseController.call(this);

};
goog.inherits(lgb.simulation.controller.MainController, lgb.core.BaseController);


/**
 * Handler used for websocket init
 * @private
 */
lgb.simulation.controller.MainController.prototype.init = function() {


    this.jsonController_ = new lgb.simulation.controller.JsonController();
    this.dataModel = new lgb.simulation.model.MainModel();

    this.delayedMessages = [];
    this.resultEventQueue_ = [];
    this.resultEventQueueIsDirty_ = false;
    this.resultEventQueueIntervalMS_ = 1000; //ms
    this.clearResultEventQueueDelegate_ = this.d(this.clearResultEventqueue_),
    this.resultEventQueueIntervalHandle_ = null;
    
    this.bind_();
    this.setRemoteHost_();

};

lgb.simulation.controller.MainController.prototype.setRemoteHost_ = function() {
  
  var url = $.url(); // parse the current page URL
  var server = url.param('server');
  
  if (server) {
    
    this.socketServerHost = server;
    
  } else {
    
    switch(lgb.core.Config.SOCKET_SERVER_HOST) {
      
      case lgb.core.Config.SOCKET_SERVER.AutoConfig :
      
        url = String (window.location);
        console.log('window.location: '+ url);
        
        hostname = url.split('/')[2];
        console.log('hostname: '+ hostname);
        
        this.socketServerHost = hostname.split(':')[0];
        console.log('hostname2: '+ hostname2);
        break;
        
      case lgb.core.Config.SOCKET_SERVER.Pfalco :
        this.socketServerHost = 'learnhpb.straylightsim.com';
        break;
        
      case lgb.core.Config.SOCKET_SERVER.PfalcoLocal :
        this.socketServerHost = '192.168.0.15';
        break;
        
      case lgb.core.Config.SOCKET_SERVER.LocalHost :
        this.socketServerHost = '127.0.0.1';
        break;
        
      case lgb.core.Config.SOCKET_SERVER.Cube :
        this.socketServerHost = 'cube.straylightsim.com';
        break;
    }
    
  }
  

    this.trigger(se.SetRemoteHost, this.socketServerHost);

    this.trigger(e.SimulationEngineLoaded, this);
  
};



    

lgb.simulation.controller.MainController.prototype.bind_ = function() {
  
    this.listenTo (
        this,
        se.SimStateNativeNotify,
        this.onSimStateNativeNotify_
    );
    
    this.listenTo (
        this,
        se.ConfigChangeNotify,
        this.onConfigChangeNotify_
    );
    
    this.listenTo (
        this,
        se.XMLparsedEvent,
        this.onXMLparsedEvent_
    );
    
    this.listenTo (
        this,
        se.ResultEvent,
        this.onResultEvent_
    );
    
    
    this.listenTo (
        this,
        se.MessageEvent,
        this.onMessageEvent_
    );
    
    this.listen (
        se.RequestModelicaVariableChange,
        this.onRequestModelicaVariableChange_
    );
    
    this.listen (
        se.SetRemoteHost,
        this.onSetRemoteHost_
    );


    this.listen (
        se.WebSocketChangeRequest,
        this.onWebSocketChangeRequest_
    );
    
    this.listen (
        se.SimStateNativeRequest,
        this.onSimStateNativeRequest_
    );
    
    
    
};



lgb.simulation.controller.MainController.prototype.onWebSocketChangeRequest_ = function(event) {
  
  this.requestWebSocketStateChange(event.payload);
  
};



lgb.simulation.controller.MainController.prototype.onSimStateNativeRequest_ = function(event) {
  
  var simStateNative = event.getPayload();
  this.requestSimStateChange(simStateNative);
  
};





lgb.simulation.controller.MainController.prototype.attachToSession = function(sessionID) {
  
  var payload = new lgb.simulation.model.voManaged.SessionControl(0,sessionID);
  var event = new lgb.simulation.events.SessionControlEvent(payload);
  
  this.serializeAndSend(event);
  
  
};

lgb.simulation.controller.MainController.prototype.getInfo = function() {
  
  var payload = new lgb.simulation.model.voManaged.SessionControl(1, 0);
  var event = new lgb.simulation.events.SessionControlEvent(payload);
  
  this.serializeAndSend(event);
  
  
};




lgb.simulation.controller.MainController.prototype.onSetRemoteHost_ = function(event) {
  
  this.dataModel.init(event.payload);
  
};


lgb.simulation.controller.MainController.prototype.getDataModel = function() {
  return this.dataModel;
};




lgb.simulation.controller.MainController.prototype.onRequestModelicaVariableChange_ = function(event) {
  
  var theVar = this.dataModel.getIdxFromModelicaName(event.payload.modName);
  
  if (undefined === theVar) {
    debugger;
  }
  
  var floatValue = event.payload.value;
  var idx = theVar.idx;
  
  var scalarValueReal = new lgb.simulation.model.voManaged.ScalarValueReal(idx, floatValue);
  var collection = new lgb.simulation.model.voManaged.ScalarValueCollection([scalarValueReal], []);
  
  var event = new lgb.simulation.events.ScalarValueChangeRequest(collection);
  this.serializeAndSend(event);
  
};


    
lgb.simulation.controller.MainController.prototype.onSimStateNativeNotify_ = function(event) {
  
  var simStateNativeWrapper = event.getPayload();
  
  this.dataModel.changePropertyEx('simStateNative', simStateNativeWrapper);
  this.dispatch(event);
  
  var theInt = simStateNativeWrapper.getIntValue();
  var theString = simStateNativeWrapper.getString();
  
  //fix for init_completed not reported
  if (theInt ==  9) { //init_completed
    
   // var x= 0;
    
    this.trigger(e.SimulationInitialized, simStateNativeWrapper);
    // return;
  }
  
  
  return;
  
};

lgb.simulation.controller.MainController.prototype.onConfigChangeNotify_ = function(event) {
 // this.dataModel.changePropertyEx('simStateNative', event.getPayload());
   this.dispatch(event);
};

lgb.simulation.controller.MainController.prototype.onXMLparsedEvent_ = function(event) {
  
  this.dataModel.setXmlParseInfo(event.getPayload());
  this.dispatch(event);
};

lgb.simulation.controller.MainController.prototype.onResultEvent_ = function(event) {

  this.resultEventQueue_.push(event);
  
  if (null == this.resultEventQueueIntervalHandle_) {
      this.resultEventQueueIntervalHandle_ = setInterval(
        this.clearResultEventQueueDelegate_,this.resultEventQueueInterval_);
  }

  //this.dispatch(event);
};

lgb.simulation.controller.MainController.prototype.clearResultEventqueue_ = function() {
  
  var eventCount = this.resultEventQueue_.length;
  
  if (0 == eventCount) {
    
    window.clearInterval(this.resultEventQueueIntervalHandle_);
    this.resultEventQueueIntervalHandle_ = null;
    
  } else {
    
    var event = new lgb.simulation.events.ResultEventList(this.resultEventQueue_);
    this.dispatch(event);
   
    var mostRecentResult = this.resultEventQueue_[eventCount-1];
    this.dataModel.setScalarValueResults(mostRecentResult.getPayload());
     
    this.resultEventQueue_ = [];
      
  }
  
  

  
};




lgb.simulation.controller.MainController.prototype.onMessageEvent_ = function(event) {
  this.dataModel.changePropertyEx('messageStruct', event.getPayload());
  this.dispatch(event);
};



lgb.simulation.controller.MainController.prototype.getWebSocketConnectionState = function() {
    return this.dataModel.getWebSocketConnectionState();
};


lgb.simulation.controller.MainController.prototype.getSimStateNative = function() {
    return this.dataModel.getSimStateNative();
};




lgb.simulation.controller.MainController.prototype.getDataModel = function() {
    return this.dataModel;
};


lgb.simulation.controller.MainController.prototype.requestSimStateChange = function(state) {

  this.dataModel.changePropertyEx('simStateNative', state);
  
  var event = new lgb.simulation.events.SimStateNativeRequest(state);
  this.serializeAndSend(event);

};


lgb.simulation.controller.MainController.prototype.requestWebSocketStateChange = function(state) {

  switch (state) {
    
    case  lgb.simulation.model.WebSocketConnectionStateRequest.open : {
       this.connect(true);
      break;
    }
    case  lgb.simulation.model.WebSocketConnectionStateRequest.close : {
       this.connect(false);
      break;
    }
    
    default:
  }
  
  
};



lgb.simulation.controller.MainController.prototype.connect = function(connectFlag) {


    if (connectFlag) {
      
      if (window.MozWebSocket) {
          this.ws_ = new MozWebSocket(this.dataModel.socketServerURL);
      } else if (window.WebSocket) {
          this.ws_ = new WebSocket(this.dataModel.socketServerURL);
      } else {
          // this.ws_ = new MozWebSocket(this.dataModel.socketServerURL);
          alert("This web Browser does not support Web Sockets");
      }
  
      this.ws_.onopen = this.d(this.onOpen_);
      this.ws_.onmessage = this.d(this.onMessage_);
      this.ws_.onclose = this.d(this.onClose_);
      this.ws_.onerror = this.d(this.onError_);
      
      this.dataModel.setWebSocketConnectionState(lgb.simulation.model.WebSocketConnectionState.open_requested);
      
    } else {
      
      this.ws_.close();
      this.dataModel.setWebSocketConnectionState(lgb.simulation.model.WebSocketConnectionState.closed);
    }

};

lgb.simulation.controller.MainController.prototype.serializeAndSend = function(event) {


    var jsonString = lgb.simulation.controller.JsonController.serialize(event);
      
      
    var state = this.dataModel.getWebSocketConnectionState();

    if (state == lgb.simulation.model.WebSocketConnectionState.uninitialized) {
        this.connect();
        this.delayedMessages.push(jsonString);
    } else {

        if (undefined === this.ws_ || this.ws_.readyState !== this.ws_.OPEN) {
            this.delayedMessages.push(jsonString);
        } else {
            this.ws_.send(jsonString);
        }

    }

};



/**
 * Handler used for websocket communication
 * @private
 */
lgb.simulation.controller.MainController.prototype.onOpen_ = function(event) {
    
    this.dataModel.setWebSocketConnectionState(lgb.simulation.model.WebSocketConnectionState.opened);

    while(msg = this.delayedMessages.shift()) {
        this.ws_.send(msg);
    }


};

/**
 * Handler used for websocket communication
 * @private
 */
lgb.simulation.controller.MainController.prototype.onMessage_ = function(event) {

    if (event.data) {
        var jsonString = event.data;
        console.log("SimulationController.onMessage_() - " + jsonString);

        var event = this.jsonController_.deserialize(jsonString);

        
        this.dispatchLocal(event);
        

    }
};

/**
 * Handler used for websocket communication
 * @private
 */
lgb.simulation.controller.MainController.prototype.onClose_ = function(event) {

    this.dataModel.setWebSocketConnectionState(lgb.simulation.model.WebSocketConnectionState.closed);
};

/**
 * Handler used for websocket communication
 * @private
 */
lgb.simulation.controller.MainController.prototype.onError_ = function(event) {

    this.dataModel.setWebSocketConnectionState(lgb.simulation.model.WebSocketConnectionState.error);

};
goog.provide('lgb.gui.view.SimulationStateControlGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');

goog.require('lgb.component.LinkDataSource');
goog.require('lgb.component.Link');

goog.require('lgb.simulation.model.WebSocketConnectionStateRequest');
goog.require('lgb.simulation.events.BaseEvent');
goog.require('lgb.simulation.model.WSConnectionState');
goog.require('lgb.simulation.events.SimStateNativeRequest');
goog.require('lgb.simulation.model.voNative.SimStateNative');


lgb.gui.view.SimulationStateControlGUI = function(dataModel) {

  this._TITLE = "Simulation";
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
};
goog.inherits(lgb.gui.view.SimulationStateControlGUI, lgb.gui.view.BaseGUI);







/**
 * @public
 */
lgb.gui.view.SimulationStateControlGUI.prototype.init = function() {


    this.listenForChange_('webSocketConnectionState');
    this.listenForChange_('simStateNative');
    this.listenForChange_('scalarValueResultsConverted');
    

};


lgb.gui.view.SimulationStateControlGUI.prototype.onChange_scalarValueResultsConverted_ = 
  function(scalarValueResultsConverted) {
  
  this.simTime_.html (scalarValueResultsConverted.time_);
  
};


lgb.gui.view.SimulationStateControlGUI.prototype.onChange_simStateNative_ = function(stateObject) {
  

  

  //var stateObject = new lgb.simulation.model.voNative.SimStateNative(simStateNative);
  
  if (stateObject.getString() == undefined) {
    debugger;  
  }
  
  var msg = "{0}:{1}".format(stateObject.getIntValue(), stateObject.getString());
  this.simStatus_.html (msg);
  this.each(this.simControlButtons_, this.checkIfButtonEnabled_, stateObject);

};


lgb.gui.view.SimulationStateControlGUI.prototype.onChange_webSocketConnectionState_ = function(webSocketConnectionState) {
  
  var WebSocketConnectionState = lgb.simulation.model.WebSocketConnectionState;
  var stateObject = new lgb.simulation.model.WSConnectionState(webSocketConnectionState);
  
  var canConnect = stateObject.canRequestTransitionTo(lgb.simulation.model.WSConnectionState.ENUM.opened);
  var canDisconnect = stateObject.canRequestTransitionTo(lgb.simulation.model.WSConnectionState.ENUM.closed);
  
  var msg = "{0}:{1}".format(stateObject.getIntValue(), stateObject.getString());
  this.wsStatus_.html (msg);
  
  this.wsConnectLink_.setEnabled(canConnect);
  this.wsDisConnectLink_.setEnabled(canDisconnect);

};


lgb.gui.view.SimulationStateControlGUI.prototype.checkIfButtonEnabled_ = function(button, stateObject) {
  
  var buttonPayloadState = button.ds.clickPayload;
  
  var isEnabled = stateObject.canRequestTransitionTo(buttonPayloadState);
  button.setEnabled(isEnabled);
  
};


lgb.gui.view.SimulationStateControlGUI.prototype.add = function(gui) {

  var title = gui.getTitle();
  var contentElement;
  
  if (this.tabTitleMap_[title]) {
    contentElement = this.tabTitleMap_[title];
  } else {
    
    contentElement = this.tabStrip1.addTab(title);
    this.tabTitleMap_[title] = contentElement;
  }
  
  gui.injectInto(contentElement);
  
};


/**
 * @public
 */
lgb.gui.view.SimulationStateControlGUI.prototype.injectInto = function(parentElement) {
  

  goog.base(this,  'injectInto', parentElement);

  var el = this.getMainElement();
  

  el.append('<h4>Simulation</h4>');
  el.append('<h5>Websockets</h5>');
  
  el.append('State:');
  
  this.wsStatus_ = $('<strong>{}</strong>');

  el.append(this.wsStatus_);
  el.append('<br />');
  
  this.wsConnectLink_ = this.makeLink1_('Socket Open', 'wsConnect');
  this.wsDisConnectLink_ = this.makeLink1_('Socket Close', 'wsDisConnect');

  el.append('<br />');
  
   
  el.append('<h5>Simulation Control</h5>');
  
  el.append('<span class="simulation-state">State:');
  this.simStatus_ = $('<strong>{}</strong>');
  el.append(this.simStatus_);
  el.append('</span>');
  
  
  el.append('<br />');

  
  this.simControlButtons_ = new Array();
  var SimStateNative = lgb.simulation.model.voNative.SimStateNative.ENUM;
  
  
  this.makeLink2_('Connect~', 'connect-link', SimStateNative.simStateNative_1_connect_requested);
  this.makeLink2_('XML Parse {}', 'xmlParse-link', SimStateNative.simStateNative_2_xmlParse_requested);
  this.makeLink2_('Init ^', 'init-link', SimStateNative.simStateNative_3_init_requested);
  el.append('<br />');
  
  this.makeLink2_('Run ^', 'run-link', SimStateNative.simStateNative_4_run_requested);
  this.makeLink2_('Step >', 'step-link', SimStateNative.simStateNative_5_step_requested);
  this.makeLink2_('Stop []', 'stop-link', SimStateNative.simStateNative_5_stop_requested);
  el.append('<br />');
  
  this.makeLink2_('Terminate.', 'terminate-link', SimStateNative.simStateNative_7_terminate_requested);
  
  el.append('<br />');
  el.append('<h5>Simulation Info</h5>');
  
  el.append('<span class="simulation-state">Time:');
  
  
  this.simTime_ = $('<strong>{}</strong>');
  el.append(this.simTime_);
  el.append('</span>');
  
  
  this.bind2_();
  


};


lgb.gui.view.SimulationStateControlGUI.prototype.bind2_ = function() {

    this.listenTo(this.wsConnectLink_, e.MouseClick, this.onWsConnectLink_);
    this.listenTo(this.wsDisConnectLink_, e.MouseClick, this.onWsDisConnectLink_);
  
    var len = this.simControlButtons_.length;
    for (var i = 0; i < len - 1; i++) {

        var button = this.simControlButtons_[i];
        this.listenTo(button, e.MouseClick, this.onClickSimStateNativeRequest_);

    };

};


lgb.gui.view.SimulationStateControlGUI.prototype.onClickSimStateNativeRequest_ = function(event) {
  
    var simState = event.target.ds.clickPayload;

    var e = new lgb.simulation.events.SimStateNativeRequest(simState);
    this.dispatchLocal(e);
};


lgb.gui.view.SimulationStateControlGUI.prototype.makeLink2_ = function(label, cssId, simStateNative) {
  
  var link = this.makeLink1_(label, cssId);
  link.ds.clickPayload = simStateNative;
  this.simControlButtons_.push(link);
  
};


lgb.gui.view.SimulationStateControlGUI.prototype.makeLink1_ = function(label, cssId) {
  
  var ds = new lgb.component.LinkDataSource(label, this.htmlID, cssId);
  ds.cssClass = "sim";
  var link = new lgb.component.Link(ds);
  
  var el = this.getMainElement();
  var html = link.getHTML();
  
  var result = el.append(html);
  var idx = el.children.length-1;
  
  link.bind(el.children[idx]);
  
  return link;
  
};



lgb.gui.view.SimulationStateControlGUI.prototype.onWsConnectLink_ = function(event) {
  
  this.triggerLocal(se.WebSocketChangeRequest, lgb.simulation.model.WebSocketConnectionStateRequest.open);
  
};

lgb.gui.view.SimulationStateControlGUI.prototype.onWsDisConnectLink_ = function(event) {
  
  this.triggerLocal(se.WebSocketChangeRequest, lgb.simulation.model.WebSocketConnectionStateRequest.close);
  
};



goog.provide('lgb.gui.controller.SimulationStateController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.SimulationStateControlGUIh');
goog.require('lgb.gui.view.SimulationStateControlGUI');


goog.require('lgb.gui.model.BaseGuiModel');

goog.require('lgb.simulation.controller.MainController');
goog.require('lgb.gui.view.SimulationConsoleGUI');
goog.require('se.Event');



lgb.gui.controller.SimulationStateController = function() {

  lgb.core.BaseController.call(this);

  
};
goog.inherits(lgb.gui.controller.SimulationStateController, lgb.core.BaseController);




lgb.gui.controller.SimulationStateController.prototype.init = function(simulationMainController) {
  
  this.simulationMainController_ = simulationMainController;
  this.dataModel = this.simulationMainController_.getDataModel();
    
  this.guiView = new lgb.gui.view.SimulationStateControlGUIh(this.dataModel);
  
  
  this.bind_();
  
  this.guiView.init();
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  

};




lgb.gui.controller.SimulationStateController.prototype.bind_ = function() {

    this.relay (
        this.guiView,
        [se.WebSocketChangeRequest, se.SimStateNativeRequest]
    );
    
    

};


goog.provide('lgb.gui.view.ScenarioGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');

lgb.gui.view.ScenarioGUI = function(dataModel) {

  this._TITLE = 'Scenario';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
};
goog.inherits(lgb.gui.view.ScenarioGUI, lgb.gui.view.BaseGUI);


/**
 * @public
 */
lgb.gui.view.ScenarioGUI.prototype.init = function() {

  this.dataSource = new lgb.component.TabStripDataSource('scenarioInputGUI-tabStrip');
  this.tabStrip1 = new lgb.component.TabStrip(this.dataSource);

  this.tabTitleMap_ = {};

  this.showPopup_();
};


lgb.gui.view.ScenarioGUI.prototype.add = function(gui) {

  var el = this.getMainElement();
  gui.appendTo(el);
  
};









/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.NodeBase');
goog.require('lgb.world.model.BaseModel');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.NodeBase = function(node) {
  
  this.node = node;
  
  var className = this.getClassName();
  
  if (null == node || className != node.tagName) {
      debugger;
  }
  
  this.classReference_ = eval(this.getFullClassName());
  
  lgb.world.model.BaseModel.call(this);
  
  this.parse_(node);
  this.node = null;
  
};
goog.inherits(lgb.scenario.model.NodeBase, lgb.world.model.BaseModel);


lgb.scenario.model.NodeBase.prototype.getChildren = function() {
  
  return this.children_;

};

lgb.scenario.model.NodeBase.prototype.makeChildrenAbbr_ = function(parentFqAbbr) {
  
  this.parentFqAbbr_=parentFqAbbr;
  
  this.children_ = [];
  this.each(this.node.children, this.parseChild_);
};

lgb.scenario.model.NodeBase.prototype.makeChildren_ = function() {
  
  this.children_ = [];
  this.each(this.node.children, this.parseChild_);
};




lgb.scenario.model.NodeBase.prototype.parseChild_ = function(childNode) {
  
  var tagName = childNode.tagName;
  
  if ("description" == tagName) {
    
    this.description = childNode.textContent;
    
  }
  
  
  if ("description" == tagName) {
    
    this.description = childNode.textContent;
    
  } else {
    
    
    if (this.classReference_.childClassMap.hasOwnProperty()) {
      debugger;
    } else {
      var theClass = this.classReference_.childClassMap[tagName];
    }

    
    if(theClass) {
      var child = new theClass(childNode);
      this.children_.push(child);
    } else {
      debugger;
    }
  }
  
};


lgb.scenario.model.NodeBase.prototype.getAttribute = function(attributeName) {
  
  var node = this.node.attributes.getNamedItem(attributeName);
  
  if (node) {
    return node.nodeValue;
  } else {
    return null;
  }
   
};


lgb.scenario.model.NodeBase.prototype.setNameAndAbbr_ = function() {
    
    this.setPropertyStr_('name');
    this.setPropertyStr_('abbr');

};


lgb.scenario.model.NodeBase.prototype.setPropertyInt_ = function(propertyName) {
    
  var strValue = this.getAttribute(propertyName);
  if (strValue) {
    this[propertyName] = parseInt(strValue);
  } else {
    this[propertyName] = null;
  }

};

lgb.scenario.model.NodeBase.prototype.setPropertyStr_ = function(propertyName) {
    
  var strValue = this.getAttribute(propertyName);
  if (strValue) {
    this[propertyName] = String(strValue);
  } else {
    this[propertyName] = null;
  }

};

lgb.scenario.model.NodeBase.prototype.setPropertyFloat_ = function(propertyName) {
    
  var strValue = this.getAttribute(propertyName);
  if (strValue) {
    this[propertyName] = parseFloat(strValue);
  } else {
    this[propertyName] = null;
  }

};


lgb.scenario.model.NodeBase.prototype.setPropertyBool_ = function(propertyName) {
    
  var strValue = this.getAttribute(propertyName);
  if (undefined == strValue) {
    this[propertyName] = false;
  } else {
    
    if ("false" == strValue.toLowerCase()) {
      this[propertyName] = false;
    } else if ("true" == strValue.toLowerCase()) {
      this[propertyName] = true;
    } else {
      debugger;
    }
    
  }

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.utils.XmlWrapper');

/**
 * @constructor
 * @param {Document} xml The xml document that we will parse.
 * @extends {lgb.core.BaseClass}
 */
lgb.utils.XmlWrapper = function(xml) {


  lgb.core.BaseClass.call(this);

 /** @type {Document}  */
  this.xml = xml;
  /** @type {XPathResult}  */
  this.xpathResult = null;
  /** @type {Node} A Node Object */
  this.currentNode = null;
};
goog.inherits(lgb.utils.XmlWrapper, lgb.core.BaseClass);


/**
 * pases the XML docuement based on the xpath and creates a root node
 * which can then be operated on.
 * @param {string} xpath If you are not familiar with Xpath,
 * it is like a SQL query performed against an XML document.
 * @return {Node} In case caller wants this.
 */
lgb.utils.XmlWrapper.prototype.makeRootNode = function(xpath) {

  this.xpathResult = this.evaluate_(xpath, this.xml);
  this.currentNode = this.xpathResult.iterateNext();

  return this.currentNode;
};


/**
 * Using the xpath query and a node known as the searchnode
 * this function parses part of the XML document.
 * @private
 * @param {string} xpath The query string.
 * @param {Node} searchNode The xml node to search.
 * @return {XPathResult} the result
 * see https://developer.mozilla.org/en/XPathResult.
 */
lgb.utils.XmlWrapper.prototype.evaluate_ = function(xpath, searchNode) {
  try {
    var result = this.xml.evaluate(
      xpath,
      searchNode,
      null,
      XPathResult.ANY_TYPE,
      null
      );
  }
  catch (e) {
    jQuery.error('lgb.utils.XmlWrapper.evaluate_(){0}'.format(e));
  }

  return result;
};



/**
 * changes the current node to the next in the result set.
 */
lgb.utils.XmlWrapper.prototype.next = function() {
  this.currentNode = this.xpathResult.iterateNext();
};

/**
 * @param {string} xpath An Xpath selector.
 * @param {Node} searchNode The xml node to search.
 * @return {string} The string value.
 */
lgb.utils.XmlWrapper.prototype.getNodeValue = function(xpath, searchNode) {
  if (searchNode == null) {
    searchNode = this.currentNode;
  }
  var xpathResult = this.evaluate_(xpath, searchNode);
  var resultNode = xpathResult.iterateNext();

  return resultNode.nodeValue;
};

/**
 * @param {string} xpath An Xpath selector.
 * @return {string} The string content of the XML node.
 */
lgb.utils.XmlWrapper.prototype.getContent = function(xpath) {

  var xpathResult = this.evaluate_(xpath, this.currentNode);
  var resultNode = xpathResult.iterateNext();

  return resultNode.textContent;
};

/**
 * @param {string} xpath An Xpath selector.
 * @return {number} The content of the XML node.
 */
lgb.utils.XmlWrapper.prototype.getContentAsFloat = function(xpath) {
    var str = this.getContent(xpath);
    return parseFloat(str);
};


/**
 * Takes a string like this "1,2,3" and makes and array containing numbers
 * @param {string=} xpath An Xpath selector.
 * @return {Array.<number>} The content of the XML node.
 */
lgb.utils.XmlWrapper.prototype.getFloatArray = function(xpath) {
  var txtAry = this.getTextArray(xpath);
  var len = txtAry.length;

  /**@type {Array.<number>} */
  var numberAry = [];
  //convert by all array elements to integer
  for (var i = 0; i < len; i++) {
    numberAry[i] = parseFloat(txtAry[i]);
  }

  return numberAry;
};

/**
 * @param {string=} xpath An Xpath selector.
 * @return {Array.<string>} The content of the XML node.
 */
lgb.utils.XmlWrapper.prototype.getTextArray = function(xpath) {
  var searchNode;
  if (xpath == null) {
    searchNode = this.currentNode;
  } else {
    var xpathResult = this.evaluate_(xpath, this.currentNode);
    searchNode = xpathResult.iterateNext();
  }

  var ary = searchNode.textContent.split(',');


  return ary;
};


/**
 * @return {string} the name atribute of the current node.
 */
lgb.utils.XmlWrapper.prototype.getName = function() {
  return this.getNodeValue('@name', this.currentNode);
};

lgb.utils.XmlWrapper.prototype.getAbbr = function() {
  return this.getNodeValue('@abbr', this.currentNode);
};

/**
 * returns the attribute 'id' from xml.
 * @return {string} The id.
 */
lgb.utils.XmlWrapper.prototype.getId = function() {
  return this.getNodeValue('@id', this.currentNode);
};

lgb.utils.XmlWrapper.prototype.getAttribute = function(attributeName) {
  
  return this.getNodeValue('@'+ attributeName, this.currentNode);
};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Boolean');
goog.require('lgb.scenario.model.NodeBase');



/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Boolean = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.Boolean, lgb.scenario.model.NodeBase);



lgb.scenario.model.Boolean.prototype.parse_ = function(node) {
  
  this.setPropertyBool_('default');  

  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Option');
goog.require('lgb.scenario.model.NodeBase');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Option = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.Option, lgb.scenario.model.NodeBase);



lgb.scenario.model.Option.prototype.parse_ = function(node) {
  
  this.setPropertyStr_('name');
  this.setPropertyStr_('description');
  this.setPropertyBool_('default');
  this.setPropertyBool_('disabled');
  
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.OptionList');
goog.require('lgb.scenario.model.NodeBase');
goog.require('lgb.scenario.model.Option');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.OptionList = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.OptionList, lgb.scenario.model.NodeBase);



lgb.scenario.model.OptionList.prototype.parse_ = function(node) {
  this.makeChildren_();
};


lgb.scenario.model.OptionList.childClassMap = {
    "Option" : lgb.scenario.model.Option
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Decimal');
goog.require('lgb.scenario.model.NodeBase');



/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Decimal = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.Decimal, lgb.scenario.model.NodeBase);



lgb.scenario.model.Decimal.prototype.parse_ = function(node) {
  
  this.setPropertyFloat_('min');  
  if (undefined == this.min) {
      this.min = 0.0;
  }
  
  this.setPropertyFloat_('max');
  if (undefined == this.max) {
      this.max = 9999999.0;
  }
  
  this.setPropertyFloat_('default');
  if (undefined == this['default']) {
      this['default'] = 0.0;
  }
  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Integer');
goog.require('lgb.scenario.model.NodeBase');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Integer = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.Integer, lgb.scenario.model.NodeBase);



lgb.scenario.model.Integer.prototype.parse_ = function(node) {
  this.setPropertyInt_('min');
  this.setPropertyInt_('max');
  this.setPropertyInt_('default');
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Temperature');
goog.require('lgb.scenario.model.NodeBase');



/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Temperature = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.Temperature, lgb.scenario.model.NodeBase);



lgb.scenario.model.Temperature.prototype.parse_ = function(node) {
  
  this.setPropertyFloat_('min');  
  if (undefined == this.min) {
      this.min = 250;
  }
  
  this.setPropertyFloat_('max');
  if (undefined == this.max) {
      this.max = 325;
  }
  
  this.setPropertyFloat_('default');
  if (undefined == this['default']) {
      this['default'] = 295.15;
  }
  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Variable');
goog.require('lgb.scenario.model.NodeBase');

goog.require('lgb.scenario.model.Integer');
goog.require('lgb.scenario.model.OptionList');
goog.require('lgb.scenario.model.Decimal');
goog.require('lgb.scenario.model.Boolean');
goog.require('lgb.scenario.model.Temperature');



/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Variable = function(node) {


  lgb.scenario.model.NodeBase.call(this, node);

  
};
goog.inherits(lgb.scenario.model.Variable, lgb.scenario.model.NodeBase);



lgb.scenario.model.Variable.prototype.parse_ = function(node) {
  
  this.setNameAndAbbr_();
  this.scope = this.getAttribute("scope");
  this.phase = this.getAttribute("phase");
  this.variability = this.getAttribute("variability");
  this.unit = this.getAttribute("unit");
  this.modName = this.getAttribute("modName");

  this.makeChildren_();
  
};


lgb.scenario.model.Variable.prototype.getPropertyNames = function() {
  
  return   ['name', 'abbr', 'scope', 'phase', 'variability', 'unit', 'modName'];
};




lgb.scenario.model.Variable.childClassMap = {
    "Integer" : lgb.scenario.model.Integer,
    "OptionList" : lgb.scenario.model.OptionList,
    "Decimal" : lgb.scenario.model.Decimal,
    "Boolean" : lgb.scenario.model.Boolean,
    "Temperature" : lgb.scenario.model.Temperature
};
  
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Component');
goog.require('lgb.scenario.model.NodeBase');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Component = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.Component, lgb.scenario.model.NodeBase);



lgb.scenario.model.Component.prototype.parse_ = function(node) {
  this.setNameAndAbbr_();
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.Category');
goog.require('lgb.scenario.model.NodeBase');
goog.require('lgb.scenario.model.Variable');
goog.require('lgb.scenario.model.Component');




/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.Category = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.Category, lgb.scenario.model.NodeBase);



lgb.scenario.model.Category.prototype.parse_ = function(node) {
  this.setNameAndAbbr_();
  this.makeChildren_();
};


lgb.scenario.model.Category.childClassMap = {
    "Variable" : lgb.scenario.model.Variable,
    "Component" : lgb.scenario.model.Component
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.SubSystem');
goog.require('lgb.scenario.model.NodeBase');
goog.require('lgb.utils.XmlWrapper');
goog.require('lgb.scenario.model.Category');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.SubSystem = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.SubSystem, lgb.scenario.model.NodeBase);



lgb.scenario.model.SubSystem.prototype.parse_ = function(node) {
  this.setNameAndAbbr_();
  this.makeChildren_();
};



lgb.scenario.model.SubSystem.childClassMap = {
    "Category" : lgb.scenario.model.Category,
    "Variable" : lgb.scenario.model.Variable
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.System');

goog.require('lgb.scenario.model.NodeBase');
goog.require('lgb.scenario.model.SubSystem');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.System = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);

};
goog.inherits(lgb.scenario.model.System, lgb.scenario.model.NodeBase);


lgb.scenario.model.System.prototype.parse_ = function(node) {
  this.setNameAndAbbr_();
  this.makeChildrenAbbr_(this.abbr);
};


lgb.scenario.model.System.childClassMap = {
    "SubSystem" : lgb.scenario.model.SubSystem
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.vo.BaseVo');


/**
 * @constructor
 * @extends lgb.world.model.vo.BaseVo
 */
lgb.world.model.vo.BaseVo = function() {

};



/**
 * loop though the array and
 * supply each element as an argument
 *  to the handler
 * @param {Array} ary The array to loop though.
 * @param {Function} handler The handler to call.
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @protected
 */
lgb.world.model.vo.BaseVo.prototype.each = function(ary, handler) {
  var additionalArgs = null;
  var allArguments = Array.prototype.slice.call(arguments);
  var len = allArguments.length;
  if (len > 2) {
    additionalArgs = allArguments.slice(2, len);
  }
  
  var l = ary.length;
  for (var i = 0; i < l; i++) {
    var arrayElement = ary[i];
    
    var argList = [arrayElement];
    
    if(additionalArgs) {
      argList = argList.concat(additionalArgs);
    }
    
    handler.apply(this, argList);
  }
};


/**
 * loop though the array and
 * supply each element as an argument
 *  to the handler
 * @param {Array} ary The array to loop though.
 * @param {Function} handler The handler to call.
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @param aditional argument to pass along for all function calls
 * @protected
 */
lgb.world.model.vo.BaseVo.prototype.eachIdx = function(ary, handler) {
  var additionalArgs = null;
  var allArguments = Array.prototype.slice.call(arguments);
  var len = allArguments.length;
  if (len > 2) {
    additionalArgs = allArguments.slice(2, len);
  }
  
  var l = ary.length;
  for (var i = 0; i < l; i++) {
    var arrayElement = ary[i];
    
    var argList = [arrayElement];
    
    if (useIdx) {
      argList.push(i);
    }
    
    if(additionalArgs) {
      argList = argList.concat(additionalArgs);
    }
    
    handler.apply(this, argList);
  }
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.vo.ViewpointNode');

goog.require('lgb.world.model.vo.BaseVo');



lgb.world.model.vo.ViewpointNode = function(title) {
  
  this.idx = lgb.world.model.vo.ViewpointNode.idx++;
  lgb.world.model.vo.ViewpointNode.allNodes[this.idx] = this;
  
  this.title = title;
  this.children = undefined;
  this.hasChildren = false;
  this.parent = undefined;
  this.camera_ = undefined;
  this.focusEvent = false;
  this.titleToChildMap_ = {};
  this.metersPerSecondPosition = 6;

};
goog.inherits(lgb.world.model.vo.ViewpointNode, lgb.world.model.vo.BaseVo);




lgb.world.model.vo.ViewpointNode.prototype.getCameraOffset = function() {

    var vpName = this.object3d.viewpoint;
    
    
    lgb.assert (vpName);
    
    if (vpName == "default" || vpName == "") {
      if (this.object3d.geometry && this.object3d.geometry.viewpoint) {
        vpName = this.object3d.geometry.viewpoint;
      }
    }
    
    var offsetAry = lgb.world.model.vo.ViewpointNode.offsetMap_[vpName];
    var offsetVector3 = new THREE.Vector3(offsetAry[0], offsetAry[1], offsetAry[2]);
    
    return offsetVector3;
};


lgb.world.model.vo.ViewpointNode.getNodeByIdx = function(idx) {
  
  var theNode = null;
  var allNodes = lgb.world.model.vo.ViewpointNode.allNodes;
  
  if(allNodes && allNodes.length > idx ) {
    theNode = allNodes[idx];
  }
  
  return theNode;
};




lgb.world.model.vo.ViewpointNode.prototype.getTargetPosition = function(cameraPositionWorld) {
  
   var worldPosition = new THREE.Vector3();

    
  if (this.camera_) {
    
    var cameraPositionLocal = this.camera_.position.clone();
    this.camera_.localToWorld(cameraPositionWorld);
    
    var cameraPositionDelta = cameraPositionWorld.clone();
    cameraPositionDelta.sub(cameraPositionLocal);
    
    var cameraTargetLocal = this.camera_.target.clone();
    var cameraTargetWorld = this.camera_.target.clone();

    cameraTargetWorld.add(cameraPositionDelta);

    return  cameraTargetWorld;
    
  } else if (this.object3d) {
    

    this.object3d.localToWorld(worldPosition);
    
    return worldPosition;
  }

  
};


lgb.world.model.vo.ViewpointNode.prototype.getCameraPosition = function() {

  if (this.camera_) {
    
    var cameraPositionLocal = this.camera_.position.clone(); 
    var anchorObj = this.getAnchorObj();
    
    if (anchorObj) {
      
      var cameraPositionWorld = anchorObj.localToWorld(cameraPositionLocal);
      
      return cameraPositionWorld;
      
    } else {
      
      return cameraPositionLocal;
      
    }

  } else if (this.object3d) {
    
    return this.generateCameraPosition();
  }
  
};



lgb.world.model.vo.ViewpointNode.prototype.updateWorldPositions = function() {
  
  var fov = 40;
  
  
  if (this.camera_) {
    fov = this.camera_.fov;
  }
  
 
  var cameraTemplate = new THREE.PerspectiveCamera(fov, 16/9, 1, 10000);
  
  var position = this.getCameraPosition();
  lgb.assert(position);
  
  var targetPosition = this.getTargetPosition(position);
  lgb.assert(targetPosition);
  
  
  this.viewpointCamera_ = new THREE.PerspectiveCamera(
    cameraTemplate.fov, 
    cameraTemplate.aspect, 
    cameraTemplate.near, 
    cameraTemplate.far
  );

  this.viewpointCamera_.position = position;
  this.viewpointCamera_.lookAt(targetPosition);
  
};



lgb.world.model.vo.ViewpointNode.prototype.getAnchorObj = function() {
    
    if (this.anchorObj_) return this.anchorObj_;
      
    if (this.anchor) {
      this.anchorObj_ = lgb.world.model.vo.ViewpointNode.anchors[this.anchor];
      
      if (null == this.anchorObj_) {
        debugger;
      } else {
        return this.anchorObj_;
      }

    } else {
      return null;
    }
  
};



lgb.world.model.vo.ViewpointNode.prototype.generateCameraPosition = function() {

    var cameraPosition = new THREE.Vector3();
    this.object3d.localToWorld(cameraPosition);
    
    var offset = this.getCameraOffset();
    cameraPosition.add(offset);

    return cameraPosition;
  
};


lgb.world.model.vo.ViewpointNode.prototype.initObject3D = function(object, recurseDepth) {

    
    this.object3d = object;

    if (this.object3d.children.length > 0 && recurseDepth > 0) {
      this.hasChildren = true;
      this.children = [];

      this.each(this.object3d.children, this.initOneChild, recurseDepth);
    }
    
};


lgb.world.model.vo.ViewpointNode.prototype.initOneChild = function(object, recurseDepth) {
  
    var childNode = new lgb.world.model.vo.ViewpointNode.make(object, recurseDepth-1);
    
    childNode.parent = this;
    this.children.push(childNode);
    this.titleToChildMap_[childNode.title] = childNode;
};



lgb.world.model.vo.ViewpointNode.prototype.initFromArray = function(ary, recurseDepth) {

    this.hasChildren = true;
    this.children = [];
    
    this.each(ary, this.initOneChild, recurseDepth);

};

lgb.world.model.vo.ViewpointNode.prototype.generateCamera = function(cameraTemplate) {

  return this.viewpointCamera_;
};


lgb.world.model.vo.ViewpointNode.prototype.getViewpoint = function(name) {

  //var vp = this.children[0];
  
  
  return this.titleToChildMap_[name];
  
};






lgb.world.model.vo.ViewpointNode.idx = 0;
lgb.world.model.vo.ViewpointNode.allNodes = [];

lgb.world.model.vo.ViewpointNode.offsetMap_ = [];
lgb.world.model.vo.ViewpointNode.offsetMap_["default"] = [0, 2, 5];

lgb.world.model.vo.ViewpointNode.offsetMap_["vp1"] = [0, 2, 7];
lgb.world.model.vo.ViewpointNode.offsetMap_["vp2"] = [0, 2, 9];
lgb.world.model.vo.ViewpointNode.offsetMap_["vp3"] = [0, 2, 30];
lgb.world.model.vo.ViewpointNode.offsetMap_["vpRootop"] = [0, 30, 15];
lgb.world.model.vo.ViewpointNode.offsetMap_["defaultScene"] = [0, 10, 30];
lgb.world.model.vo.ViewpointNode.offsetMap_["defaultZone"] = [0, 2, 5];
lgb.world.model.vo.ViewpointNode.offsetMap_["ZonesScene"] = [0, 50, 3];
lgb.world.model.vo.ViewpointNode.offsetMap_["RoofTopScene"] = [0, 25, 20];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeGroup"] = [0, 3, 6];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeChair1"] = [1.1, 1.2, -1.8];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeChair2"] = [0, 1.2, 1.5];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeChair3"] = [1.1, 1.2, -1.8];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeChair4"] = [0, 1.2, 1.5];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeTaskLight1"] = [1.1, 1.2, -1.8];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeTaskLight2"] = [1.1, 1.2, -1.8];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeTaskLight3"] = [0, 1.2, 1.5];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeTaskLight4"] = [0, 1.2, 1.5];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeComputer1"] = [1.2, 0.5, -1.0];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeComputer2"] = [-1.2, 0.5, -1.0];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeComputer3"] = [1.2, 0.5, -1.0];
lgb.world.model.vo.ViewpointNode.offsetMap_["officeComputer4"] = [-1.2, 0.5, -1.0];
lgb.world.model.vo.ViewpointNode.offsetMap_["crosssection"] = [-0.5, 1.2, 0.5];

lgb.world.model.vo.ViewpointNode.offsetMap_["crosssectionTop"] = [-2.7, 2.4, 2.0];
lgb.world.model.vo.ViewpointNode.offsetMap_["crosssectionAir"] =  [0.0, 1.0, 2.0];
lgb.world.model.vo.ViewpointNode.offsetMap_["crosssectionMain"] = [-2.5, 1.0, 1.6];
lgb.world.model.vo.ViewpointNode.offsetMap_["crosssectionVeneer"] = [-2.7, 1.2, -3.0];
lgb.world.model.vo.ViewpointNode.offsetMap_["crosssectionSide"] = [-2.7, 0.3, -0.2];


lgb.world.model.vo.ViewpointNode.make= function(object, recurseDepth) {

  if (object && object instanceof THREE.Camera) {
    return new lgb.world.model.vo.ViewpointNode.makeFromCamera(object, recurseDepth);
  } else if  (object && object instanceof THREE.Object3D) {
    return new lgb.world.model.vo.ViewpointNode.makeFromObject3D(object, recurseDepth);
  } else if (object && object instanceof Array) {
    return new lgb.world.model.vo.ViewpointNode.makeFromArray(object, recurseDepth);
  } else if  (object && object instanceof lgb.world.model.vo.ViewpointNode){
    return object;
  }
  
};



lgb.world.model.vo.ViewpointNode.makeFromCamera= function(camera, recurseDepth) {

  var node = new lgb.world.model.vo.ViewpointNode(camera.name);
  
  node.camera_ = camera;
  node.hasChildren = false;
  node.anchor = camera.getAnchor();
  
  return node;
  
};




lgb.world.model.vo.ViewpointNode.makeFromObject3D = function(object3D, recurseDepth) {

  var node = new lgb.world.model.vo.ViewpointNode(object3D.name);
  node.initObject3D(object3D, recurseDepth);
  return node;
};




lgb.world.model.vo.ViewpointNode.makeFromArray= function(title, ary, recurseDepth) {

    var node = new lgb.world.model.vo.ViewpointNode(title);
    node.initFromArray(ary,  recurseDepth);
    
    return node;
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.ViewpointModel');

goog.require('lgb.world.model.BaseModel');
goog.require('lgb.world.model.vo.ViewpointNode');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.ViewpointModel = function() {

  /**@const */
  this._TITLE = 'ViewpointModel2';
  lgb.world.model.BaseModel.call(this);
  this.init_();
  this.name = "";
};
goog.inherits(lgb.world.model.ViewpointModel, lgb.world.model.BaseModel);



lgb.world.model.ViewpointModel.prototype.init_ = function() {
 
  this.nodeList_= [];

};
 
 
lgb.world.model.ViewpointModel.prototype.addNode = function(viewpointNode) {
 
  this.nodeList_.push(viewpointNode);
  this.dispatchChangedEx("viewpointNode", viewpointNode);

};
 
 
lgb.world.model.ViewpointModel.prototype.setAnchors = function(anchors) {
 
  this.anchors_ = anchors;

};
 





lgb.world.model.ViewpointModel.prototype.getViewpoint = function(kNode) {
  
   var id = kNode.id;
   var viewpointNode = lgb.world.model.vo.ViewpointNode.getNodeByIdx(id);

   return viewpointNode;

};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.BaseView');

goog.require('lgb.world.model.ViewpointModel');
goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.core.Config');
goog.require('lgb.scenario.model.System');
goog.require('lgb.scenario.model.SubSystem');


/**
 * @constructor
 * @param {lgb.world.model.ViewpointModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUIGUI}
 */
lgb.scenario.view.BaseView = function(dataModel, debugFlag) {
  this.disableIDs_ = true;
  this.setDebugFlag(debugFlag);
  
  this.cssClassName_ = 'input-' + this.getClassName();
  
  if (debugFlag) {
    this.cssClassName_ += 'Debug';
  }
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
};
goog.inherits(lgb.scenario.view.BaseView, lgb.gui.view.BaseGUI);


lgb.scenario.view.BaseView.prototype.setDebugFlag = function(debugFlag) {
  
  if (undefined == debugFlag) {
    this.debugFlag_ = false;
  } else {
    this.debugFlag_ = debugFlag;
  }

};

lgb.scenario.view.BaseView.prototype.setEnabled = function(isEnabled) {
 
   this.setEnabled = isEnabled;

};




  
lgb.scenario.view.BaseView.prototype.appendTitle_ = function() {
  
  var html = this.dataModel.name;
  
  if (this.debugFlag_) {
    html += " ({0})".format(this.dataModel.abbr);
  }
  
  this.append(html);
  
  
};


  
lgb.scenario.view.BaseView.prototype.makeChildren_ = function(parentElement) {
  
  this.each(this.dataModel.children_, this.appendChildTo_, parentElement);
  
};






lgb.scenario.view.BaseView.prototype.appendChildTo_ = function(childNode, parentElement) {
  

  var childClassName = childNode.getClassName();


  if ("description" == childClassName) {
    
    
  } else {

    var classConstructor = this.getClassConstructor();
    var childClassConstructor = classConstructor.childClassMap[childClassName];
    
    if(childClassConstructor) {
      var child = new childClassConstructor(childNode, this.debugFlag_);
      child.appendTo(parentElement);
      
    } else {
      debugger;
    }
  }
  
};

lgb.scenario.view.BaseView.prototype.makeChildrenAndListen_ = function(parentElement) {
  
  this.each(this.dataModel.children_, this.appendChildToAndListen_, parentElement);
  
};



lgb.scenario.view.BaseView.prototype.appendChildToAndListen_ = function(childNode, parentElement) {
  

  var childClassName = childNode.getClassName();
  goog.asserts.assert("description" != childClassName);
  
  var classConstructor = this.getClassConstructor();
  goog.asserts.assertFunction(classConstructor);
  
  var childClassConstructor = classConstructor.childClassMap[childClassName];
  goog.asserts.assertFunction(childClassConstructor);
  

  var child = new childClassConstructor(childNode, this.debugFlag_);
  goog.asserts.assertInstanceof(child, childClassConstructor);
    
  this.relayLocal(
    child, 
    se.RequestModelicaVariableChange
    );
    
  // this.listenTo(child, se.RequestModelicaVariableChange, this.onRequestModelicaVariableChange_);
  
  
  child.appendTo(parentElement);
      

};


// lgb.scenario.view.BaseView.prototype.onRequestModelicaVariableChange_ = function(event) {
//   
  // return;
// };


lgb.scenario.view.BaseView.prototype.appendDebugProperty_ = function(propertyName) {
  
  var value = this.dataModel[propertyName];
  
  if(null == value) {
    value = '{null}';
  }

  var html = "{0} : {1} <br />".format(propertyName, value);
  this.append(html);
  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Integer');

goog.require('lgb.scenario.view.BaseView');


lgb.scenario.view.Integer = function(dataModel, debugFlag, unit) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
  this.unit_ = unit;
};
goog.inherits(lgb.scenario.view.Integer, lgb.scenario.view.BaseView);



lgb.scenario.view.Integer.prototype.appendTo = function(parentElement) {

  if (this.debugFlag_) {

    this.append('type : Integer <br />');
    this.appendDebugProperty_('min');
    this.appendDebugProperty_('max');
    this.appendDebugProperty_('default');

  } else {


    this.inputElement_ = $('<input>')
    .addClass('input-Integer-textbox')
    .attr("type", "text")
    .attr("value", this.dataModel['default']);
    
     // if (!this.isEnabled) {
       // // this.inputElement_.attr( "disabled", "disabled" );
     // }
     
    this.append(this.inputElement_);
    
    
    if (undefined == this.unit_) {
      var html = "({0}-{1})".format(this.dataModel.min, this.dataModel.max);
    } else {
      var html = "{0} ({1}-{2})".format(this.unit_, this.dataModel.min, this.dataModel.max);
      
    }
        
    this.append(html);
  }

  this.injectInto(parentElement);
};

lgb.scenario.view.Integer.prototype.setEnabled = function(enabledFlag) {
  
  
   this.isEnabled = enabledFlag;
   
   // if (this.isEnabled) {
//      
   // } else {
     // this.inputElement_.attr( "disabled", "disabled" );
   // }

};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Option');

goog.require('lgb.scenario.view.BaseView');


lgb.scenario.view.Option = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
};
goog.inherits(lgb.scenario.view.Option, lgb.scenario.view.BaseView);



lgb.scenario.view.Option.prototype.appendTo = function(parentElement) {

  this.injectInto(parentElement);  
  this.appendDebugProperty_('name');
  this.appendDebugProperty_('disabled');
  this.appendDebugProperty_('default');
  
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.OptionList');

goog.require('lgb.scenario.view.BaseView');
goog.require('lgb.scenario.view.Option');


lgb.scenario.view.OptionList = function(dataModel, debugFlag, unit) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
  this.unit_ = unit;
};
goog.inherits(lgb.scenario.view.OptionList, lgb.scenario.view.BaseView);



lgb.scenario.view.OptionList.prototype.appendTo = function(parentElement) {
  

  this.injectInto(parentElement);

  if (this.debugFlag_) {

    this.append('type : OptionList <br />');
    this.makeChildren_(parentElement);

  } else {

    this.makeListBox_();

  }



  
};


lgb.scenario.view.OptionList.prototype.makeListBox_ = function() {

    var div = this.makeDiv();
        
     div
    .addClass('input-ListBox')
    .addClass('select')
    .append('<input>')
    .attr('value', '1');
    
    this.append(div);
    
    this.kendoDropDownList = 
      div.kendoDropDownList({
        dataSource: this.dataModel.getChildren(),
            dataTextField: 'name',
            dataValueField: 'name',
        change: this.d(this.onDropDownChange)
      }).data('kendoDropDownList');
      
      
      if (undefined != this.unit_) {

        var html = " {0}".format(this.unit_);
        this.append(html);
      }
        
        


      

};

lgb.scenario.view.OptionList.prototype.onDropDownChange = function(event) {
  
  return;
};




lgb.scenario.view.OptionList.childClassMap = {
    "Option" : lgb.scenario.view.Option
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Boolean');

goog.require('lgb.scenario.view.BaseView');


lgb.scenario.view.Boolean = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
};
goog.inherits(lgb.scenario.view.Boolean, lgb.scenario.view.BaseView);




lgb.scenario.view.Boolean.prototype.appendTo = function(parentElement) {
  
  if (this.debugFlag_) {
    
    this.append('type : Boolean <br />');
    this.appendDebugProperty_('default');
    
  } 
  else {

        this.inputElement_ = $('<input>')
          .attr("type", "checkbox");
          
          if (true == this.dataModel['default']) {
            this.inputElement_.attr("checked", "true");
          }
          

        this.append(this.inputElement_);

    }
  
  this.injectInto(parentElement);  
  
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Decimal');

goog.require('lgb.scenario.view.BaseView');


lgb.scenario.view.Decimal = function(dataModel, debugFlag, unit) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
  this.unit_ = unit;
};
goog.inherits(lgb.scenario.view.Decimal, lgb.scenario.view.BaseView);




lgb.scenario.view.Decimal.prototype.appendTo = function(parentElement) {
  
  if (this.debugFlag_) {
    
    this.append('type : Decimal <br />');
    this.appendDebugProperty_('min');
    this.appendDebugProperty_('max');
    this.appendDebugProperty_('default');
    
  } else {

        this.inputElement_ = $('<input>')
          .addClass('input-Integer-textbox')
          .attr("type", "text")
          .attr( "size", "6" )
          .attr( "maxlength", "10" )
          .attr("value", this.dataModel['default']);
          

           
         // if (this.isEnabled == false) {
           // // this.inputElement_.attr( "disabled", "disabled" );
         // } else {
//            
// 
         // }
     
     
        this.append(this.inputElement_);
        
        
        if (undefined == this.unit_) {
          var html = "({0}-{1})".format( this.dataModel.min, this.dataModel.max);
        } else {
          var html = "{0} ({1}-{2})".format(this.unit_, this.dataModel.min, this.dataModel.max);
          
        }
        
        

        this.append(html);


        this.inputElement_.blur(this.d(this.onblur_));
      
    }
  
  this.injectInto(parentElement);  
  
};




lgb.scenario.view.Decimal.prototype.onblur_ = function(event) {
  
  
  var stringValue = this.inputElement_[0].value;
  var floatValue = parseFloat(stringValue);
  
  this.triggerLocal(e.GuiValueChanged, floatValue);
};

lgb.scenario.view.Decimal.prototype.setEnabled = function(enabledFlag) {

   this.isEnabled = enabledFlag;
   
   if (enabledFlag) {
     this.inputElement_
      .removeAttr("disabled");
   } else {
     this.inputElement_
      .attr("disabled", "disabled");
   }

};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Temperature');

goog.require('lgb.scenario.view.BaseView');
goog.require('lgb.scenario.view.Decimal');


lgb.scenario.view.Temperature = function(dataModel, debugFlag, unit) {
  lgb.scenario.view.Decimal.call(this, dataModel, debugFlag, unit);
};
goog.inherits(lgb.scenario.view.Temperature, lgb.scenario.view.Decimal);







/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Variable');

goog.require('lgb.scenario.view.BaseView');
goog.require('lgb.scenario.view.Integer');
goog.require('lgb.scenario.view.OptionList');
goog.require('lgb.scenario.view.Decimal');
goog.require('lgb.scenario.view.Boolean');
goog.require('lgb.scenario.view.Temperature');
//goog.require('lgb.simulation.model.voNative.ScalarValueRealStruct');

goog.require('goog.events.Event');


lgb.scenario.view.Variable = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
  
  lgb.scenario.view.Variable.variablesList.push(this);
  
  if(this.dataModel.modName) {
    lgb.scenario.view.Variable.variablesMap[this.dataModel.modName] = this;
  }

  
};
goog.inherits(lgb.scenario.view.Variable, lgb.scenario.view.BaseView);



lgb.scenario.view.Variable.prototype.appendTo = function(parentElement) {
    
   if (null == this.dataModel.modName || "" == this.dataModel.modName) {
     this.isEnabled = false;
   } else {
     this.isEnabled = true;
   }
       
  this.injectInto(parentElement);
  
  this.childList_ = [];
  
  if (this.debugFlag_) {
    
    this.debugProperties_();
    this.makeChildren_(this.getMainElement());
    
  } 
  else {
  
     var txt = "{0} ({1})".format(this.dataModel.name, this.dataModel.abbr);
    
      this.label_.text(txt);

      var el = this.getMainElement();
      this.makeChildrenAndListen_(el);
      
    }
  
};




lgb.scenario.view.Variable.prototype.appendChildToAndListen_ = function(childNode, parentElement) {
  

  var childClassName = childNode.getClassName();
  goog.asserts.assert("description" != childClassName);
  
  var classConstructor = this.getClassConstructor();
  goog.asserts.assertFunction(classConstructor);
  
  var childClassConstructor = classConstructor.childClassMap[childClassName];
  goog.asserts.assertFunction(childClassConstructor);
  

  var child = new childClassConstructor(childNode, this.debugFlag_);
  goog.asserts.assertInstanceof(child, childClassConstructor);
    
    
    

    
    
  this.listenTo(child, e.GuiValueChanged, this.onGuiValueChanged_);
  
  child.appendTo(parentElement);
      
    
  if ("parameter" == this.dataModel.variability) {
    
    child.setEnabled(false);
  
  }
  
};


lgb.scenario.view.Variable.prototype.onGuiValueChanged_ = function(event) {

 var newPayload = {
   modName : this.dataModel.modName,
   value : event.payload
 };
 
 this.triggerLocal(se.RequestModelicaVariableChange, newPayload);
  

};



lgb.scenario.view.Variable.showIcontentPopup = function(abbr) {
  
  
    var url = "info-pages/iv-{0}.html".format(abbr);
    
    
    newwindow=window.open(url,'name','height=600,width=450');
    if (window.focus) {newwindow.focus()}
    return false;
};




lgb.scenario.view.Variable.prototype.getMainElement = function() {

  if (undefined == this.mainElement_) {
    
    var li = $('<li>');

    var divMore = $('<div>');
    divMore.addClass('more');
    
    var abbr = this.dataModel.abbr;
    var tooltip = 'Show info page for the variable: {0}'.format(abbr);
    
    var tag = '<a href="#" class="info" title="{0}"' +
    ' onclick="return lgb.scenario.view.Variable.showIcontentPopup (\'{1}\');"' +
    '></a>';
    
    
    tag = tag.format(tooltip, abbr);


    divMore.append (tag);
    
    if ("parameter" == this.dataModel.variability) {
      
      divMore.append ('<a href="#" class="param"></a>');  
    
    } else {
      
      divMore.append ('<a href="#" class="param disabled"></a>');  
      
    }
    

    
    
    li.append(divMore);
    this.label_ = $('<label for="textfield">');
    li.append(this.label_);
    
    
    this.mainElement_ = li;
    
    
    if (undefined != this.htmlID) {
      this.mainElement_.attr('id', this.htmlID);
    }

  }



  return this.mainElement_;
};









lgb.scenario.view.Variable.prototype.injectDebugContent = function() {

  this.makeChildren_(div);
};


lgb.scenario.view.Variable.prototype.debugProperties_ = function() {
  
  this.appendDebugProperty_('name');
  this.appendDebugProperty_('abbr');
  this.appendDebugProperty_('scope');
  this.appendDebugProperty_('phase');
  this.appendDebugProperty_('variability');
  this.appendDebugProperty_('unit');
  this.appendDebugProperty_('modName');
  
};



lgb.scenario.view.Variable.childClassMap = {
    "Integer" : lgb.scenario.view.Integer,
    "OptionList" : lgb.scenario.view.OptionList,
    "Decimal" : lgb.scenario.view.Decimal,
    "Boolean" : lgb.scenario.view.Boolean,
    "Temperature" : lgb.scenario.view.Temperature
};


lgb.scenario.view.Variable.variablesList = [];
lgb.scenario.view.Variable.variablesMap = {};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Component');

goog.require('lgb.scenario.view.BaseView');


lgb.scenario.view.Component = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
};
goog.inherits(lgb.scenario.view.Component, lgb.scenario.view.BaseView);




lgb.scenario.view.Component.prototype.appendTo = function(parentElement) {
  
  this.injectInto(parentElement);
  
  this.append(
    'name : ' + this.dataModel.name
  );
  
    
};


/*

lgb.scenario.view.Component.childClassMap = {
  "Component" : lgb.scenario.view.Component,
  "Component" : lgb.scenario.view.Component
};

*/
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.Category');

goog.require('lgb.scenario.view.BaseView');
goog.require('lgb.scenario.view.Variable');
goog.require('lgb.scenario.view.Component');
goog.require('goog.asserts');


lgb.scenario.view.Category = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
};

goog.inherits(lgb.scenario.view.Category, lgb.scenario.view.BaseView);




lgb.scenario.view.Category.prototype.appendTo = function(parentElement) {
  
  this.injectInto(parentElement);  
  this.appendTitle_();
  //this.append('<br />');
  
  this.makeChildren_(parentElement);
  
};


lgb.scenario.view.Category.childClassMap = {
  "Variable" : lgb.scenario.view.Variable,
  "Component" : lgb.scenario.view.Component
};


lgb.scenario.view.Category.prototype.getMainElement = function() {

  if (undefined == this.mainElement_) {
      
    if ("NONE" == this.dataModel.name) {
      this.mainElement_ = $('<div>');
    } else {
      this.mainElement_ = $('<h3>');
    }
  

    
    if (undefined != this.htmlID) {
      this.mainElement_.attr('id', this.htmlID);
    }

  }

  return this.mainElement_;
};

lgb.scenario.view.Category.prototype.appendTitle_ = function() {
  
  var html = this.dataModel.name;
  
  if (this.debugFlag_) {
    html += " ({0})".format(this.dataModel.abbr);
  }
    
    if ("NONE" == this.dataModel.name) {
      //this.append(html);
    } else {
      this.append(html);
    }

};


  
lgb.scenario.view.Category.prototype.makeChildren_ = function(parentElement) {
  
  this.ul_ = $('<ul>');
  this.ul_.appendTo(parentElement);
  this.each(this.dataModel.children_, this.appendChildToAndListen_, this.ul_);
  
};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.SubSystem');

goog.require('lgb.scenario.view.BaseView');
goog.require('lgb.scenario.view.Category');



lgb.scenario.view.SubSystem = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
};
goog.inherits(lgb.scenario.view.SubSystem, lgb.scenario.view.BaseView);


lgb.scenario.view.SubSystem.prototype.appendTo = function(parentElement) {
  
  this.injectInto(parentElement);
  this.appendTitle_();
  this.makeChildrenAndListen_(parentElement);
  
};


lgb.scenario.view.SubSystem.prototype.getMainElement = function() {

  if (undefined == this.mainElement_) {
    this.mainElement_ = $('<h2>');
    
    if (undefined != this.htmlID) {
      this.mainElement_.attr('id', this.htmlID);
    }

  }

  return this.mainElement_;
};




lgb.scenario.view.SubSystem.childClassMap = {
    "Category" : lgb.scenario.view.Category,
    "Variable" : lgb.scenario.view.Variable
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.System');

goog.require('lgb.scenario.view.BaseView');
goog.require('lgb.scenario.view.SubSystem');


lgb.scenario.view.System = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
};
goog.inherits(lgb.scenario.view.System, lgb.scenario.view.BaseView);



lgb.scenario.view.System.prototype.init = function() {
    this.triggerLocal(e.RequestAddToParentGUI);
};


lgb.scenario.view.System.prototype.appendTo = function(parentElement) {
  
  this.injectInto(parentElement);
  this.appendTitle_();
  this.makeChildrenAndListen_(parentElement);
};




lgb.scenario.view.System.prototype.getMainElement = function() {

  if (undefined == this.mainElement_) {
    this.mainElement_ = $('<h1>');
    
    if (undefined != this.htmlID) {
      this.mainElement_.attr('id', this.htmlID);
    }

  }

  return this.mainElement_;
};



lgb.scenario.view.System.childClassMap = {
    "SubSystem" : lgb.scenario.view.SubSystem
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.view.SystemList');

goog.require('lgb.scenario.view.BaseView');
goog.require('lgb.scenario.view.System');


lgb.scenario.view.SystemList = function(dataModel, debugFlag) {
  lgb.scenario.view.BaseView.call(this, dataModel, debugFlag);
};
goog.inherits(lgb.scenario.view.SystemList, lgb.scenario.view.BaseView);




lgb.scenario.view.SystemList.prototype.init = function() {
   this.triggerLocal(e.RequestAddToParentGUI);
};

lgb.scenario.view.SystemList.prototype.getVariables = function() {
  return lgb.scenario.view.Variable.variablesList;
};


lgb.scenario.view.SystemList.prototype.appendTo = function(parentElement) {
  
  this.injectInto(parentElement);
  
  this.append(this.dataModel.name);
  this.makeChildren_(parentElement);
  
};



lgb.scenario.view.SystemList.childClassMap = {
    "System" : lgb.scenario.view.System
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.SystemList');
goog.require('lgb.scenario.model.NodeBase');

goog.require('lgb.utils.XmlWrapper');
goog.require('lgb.scenario.model.System');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.scenario.model.SystemList = function(node) {

  lgb.scenario.model.NodeBase.call(this, node);
  
};
goog.inherits(lgb.scenario.model.SystemList, lgb.scenario.model.NodeBase);



lgb.scenario.model.SystemList.prototype.parse_ = function(node) {
  this.setPropertyStr_('name');
  this.systemMap_ = {};
  
  this.makeChildren_();
  
};


lgb.scenario.model.SystemList.prototype.parseChild_ = function(childNode) {
  
    goog.base(this, 'parseChild_', childNode);
    
    
    var childObj = this.children_[this.children_.length-1];
    
    if (this.systemMap_.hasOwnProperty(childObj.name)) {
      debugger;
    } else {
      this.systemMap_[childObj.name] = childObj;
    }

};


lgb.scenario.model.SystemList.prototype.getSystem = function(name) {
  
    if (this.systemMap_.hasOwnProperty(name)) {
      return this.systemMap_[name];
    } else {
      debugger;
    }
    
};



lgb.scenario.model.SystemList.childClassMap = {
    "System" : lgb.scenario.model.System
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.model.ScenarioModel');

goog.require('lgb.world.model.BaseModel');
goog.require('lgb.scenario.model.SystemList');
goog.require('lgb.utils.XmlWrapper');
goog.require('lgb.core.Config');


/**
 * @constructor
 * @extends lgb.world.model.ScenarioModelModel
 */
lgb.scenario.model.ScenarioModel = function() {

  lgb.world.model.BaseModel.call(this);
  
  this.xml = null;
  this.systemNodeArray = [];
  this.idxToNodeMap = {};
  this.selectedSystemNode = null;


};
goog.inherits(lgb.scenario.model.ScenarioModel, lgb.world.model.BaseModel);



/**
 * Loads the scario from a remote XML file.
 */
lgb.scenario.model.ScenarioModel.prototype.load = function(fileName) {
  
  
  
  var url = lgb.core.Config.WEBROOT + lgb.core.Config.XML_BASE_PATH + fileName + ".xml";

  var delegate = this.d(this.parse);
  
    $.ajax({
      type: 'GET',
      url: url,
      dataType: 'xml',
      success: delegate
    });
    
};



/**
 * After the XML  file is loaded it is parsed here.
 * @param {Document} xml The XML document to parse.
 */
lgb.scenario.model.ScenarioModel.prototype.parse = function(xml) {

  var xmlWrapper = new lgb.utils.XmlWrapper(xml);
  var node = xmlWrapper.makeRootNode('/SystemList');
  
  if (null == node) {
    debugger;
  }
  
  this.systemList = new lgb.scenario.model.SystemList(node);
  
 // this.systemMap = systemList.systemMap;
 // this.systemList = this.systemList.systemList;
  
  this.triggerLocal(e.DataModelInitialized);

};














goog.provide('lgb.gui.controller.ScenarioController');

goog.require('lgb.core.BaseController');

goog.require('lgb.gui.model.BaseGuiModel');
goog.require('lgb.scenario.model.ScenarioModel');
goog.require('lgb.scenario.model.SystemList');

goog.require('lgb.gui.view.ScenarioGUI');
goog.require('lgb.scenario.view.SystemList');

goog.require('lgb.scenario.model.SystemList');


lgb.gui.controller.ScenarioController = function() {

  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.gui.controller.ScenarioController, lgb.core.BaseController);


/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.ScenarioController.prototype.init = function(systemListDataModel) {

  this.systemListDataModel_ = systemListDataModel;
  this.systemListView_ = new lgb.scenario.view.SystemList (this.systemListDataModel_, true);
  
  this.bind_();
  
  this.dataModel = new lgb.gui.model.BaseGuiModel();
  

  
  this.guiView = new lgb.gui.view.ScenarioGUI(this.dataModel);
  
  
  this.guiView.init();
  
  
  this.guiView.add(this.systemListView_);
  // this.variableList_ = systemListView.getVariables();
  
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);

  
  
};





lgb.gui.controller.ScenarioController.prototype.bind_ = function() {
  
      this.listenTo(
        this.systemListDataModel_, 
        se.RequestModelicaVariableChange,
        this.onRequestModelicaVariableChange_
        );

};


lgb.gui.controller.ScenarioController.prototype.onRequestModelicaVariableChange_ = function(event) {
  

  return;

};
goog.provide('lgb.gui.view.BuildingGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');

lgb.gui.view.BuildingGUI = function(dataModel) {

  this._TITLE = 'Building';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);


};
goog.inherits(lgb.gui.view.BuildingGUI, lgb.gui.view.BaseGUI);




lgb.gui.view.BuildingGUI.prototype.init = function() {
  
  this.tabTitleMap_ = {};
  
  this.dataSource = new lgb.component.TabStripDataSource('buildingInputGUI-tabStrip');
  this.dataSource.setIcon("images/tabs/systemBtn_grid_25.png", 25, 25);
  
  
  this.tabStrip = new lgb.component.TabStrip(this.dataSource);
};



lgb.gui.view.BuildingGUI.prototype.add = function(gui) {


  var title = gui.getTitle();

  if (undefined === title) {
    debugger;
  }

  var contentElement;
  
  if (this.tabTitleMap_[title]) {
    contentElement = this.tabTitleMap_[title];
  } else {
    this.dataSource.addTab('', '<br />');
    
    contentElement = this.tabStrip.getContentElement();
    this.tabTitleMap_[title] = contentElement;
  }
  
  
  gui.injectInto(contentElement);
  
};


/**
 * @public
 */
lgb.gui.view.BuildingGUI.prototype.injectInto = function(parentElement) {
  
  this.tabStrip.injectInto(parentElement);
  this.tabStrip.injectCss();
  
  
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.BuildingSubControllerGUI');

goog.require('lgb.world.model.ViewpointModel');
goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.core.Config');


/**
 * @constructor
 * @param {lgb.world.model.ViewpointModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.BuildingSubControllerGUI = function(dataModel, title) {
  
  this._TITLE = title;
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
  this.cssClassName_ = "panel input";
  
};
goog.inherits(lgb.gui.view.BuildingSubControllerGUI, lgb.gui.view.BaseGUI);



lgb.gui.view.BuildingSubControllerGUI.prototype.add = function(gui) {
  var el = this.getMainElement();
  gui.appendTo(el, false);
};


lgb.gui.view.BuildingSubControllerGUI.prototype.calculateLayout = function() {
  
  var el = this.getMainElement();
  
  var h = window.innerHeight;

  
  var p1 = this.getParentElement();
  var h1 = p1.height();
  
 // var p2 = el.parent();
 //  var hh2 = p2.height();
  
  
  var height = (h-295);
  
  el.height(height);
  
  
  return;
};



/*

lgb.gui.view.BuildingSubControllerGUI.prototype.injectInto = function(parentElement) {
  goog.base(this,  'injectInto', parentElement);
};

*/

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.controller.BuildingSubController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.model.BaseGuiModel');

goog.require('lgb.scenario.view.System');
goog.require('lgb.scenario.model.ScenarioModel');
goog.require('lgb.gui.view.BuildingSubControllerGUI');


/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.BuildingSubController = function(  ) {
  
  // this.TITLE_ = title;
  lgb.core.BaseController.call(this);
  
};
goog.inherits(lgb.gui.controller.BuildingSubController, lgb.core.BaseController);


/**
 * Initialized the controller.
 */
lgb.gui.controller.BuildingSubController.prototype.init = function( system ) {
  
  this.dataModel = new lgb.gui.model.BaseGuiModel();
  this.guiView = new lgb.gui.view.BuildingSubControllerGUI (this.dataModel, system.name);
  
  var systemView = new lgb.scenario.view.System (system);

  // this.listenTo(systemView, se.RequestModelicaVariableChange, this.onRequestModelicaVariableChange_);
  this.relay(systemView, se.RequestModelicaVariableChange);
  
  this.guiView.add(systemView);
  
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  
  this.bind_();
  this.guiView.calculateLayout();
};





lgb.gui.controller.BuildingSubController.prototype.bind_ = function() {
  
  this.listen(e.WindowResize, this.onWindowResize_);
};


lgb.gui.controller.BuildingSubController.prototype.onWindowResize_ = function(event) {

    this.guiView.calculateLayout();
};


goog.provide('lgb.gui.controller.BuildingController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.BuildingGUI');
goog.require('lgb.gui.model.BaseGuiModel');

goog.require('lgb.gui.controller.BuildingSubController');




lgb.gui.controller.BuildingController = function() {

  lgb.core.BaseController.call(this);
  this.subControllerList_ = [];
};
goog.inherits(lgb.gui.controller.BuildingController, lgb.core.BaseController);


/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.BuildingController.prototype.init = function(systemListDataModel) {

  this.dataModel = new lgb.gui.model.BaseGuiModel();
  this.guiView = new lgb.gui.view.BuildingGUI(this.dataModel);
  this.guiView.init();
    
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  this.systemListDataModel_ = systemListDataModel;
  
  var children = this.systemListDataModel_.getChildren();
  this.each (children, this.makeBuildingSubController_);
  
};



lgb.gui.controller.BuildingController.prototype.makeBuildingSubController_ = function(system) {

  this.makeChildGUIcontroller_(lgb.gui.controller.BuildingSubController, system);
  
};



  
goog.provide('lgb.gui.view.LeftPanelGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');

lgb.gui.view.LeftPanelGUI = function(dataModel) {

  this._TITLE = 'LeftPanelGUI';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.init_();
};
goog.inherits(lgb.gui.view.LeftPanelGUI, lgb.gui.view.BaseGUI);


/**
 * @public
 */
lgb.gui.view.LeftPanelGUI.prototype.init_ = function() {

  this.dataSource = new lgb.component.TabStripDataSource('leftPanelGUI-tabStrip');
  this.tabStrip1 = new lgb.component.TabStrip(this.dataSource);


  this.tabTitleMap_ = {};
  
};


lgb.gui.view.LeftPanelGUI.prototype.add = function(gui) {


  var title = gui.getTitle();

  var contentElement;
  
  if (this.tabTitleMap_[title]) {
    contentElement = this.tabTitleMap_[title];
  } else {
    
    contentElement = this.tabStrip1.addTab(title);
    this.tabTitleMap_[title] = contentElement;
  }
  
  gui.injectInto(contentElement);
  
};


/**
 * @public
 */
lgb.gui.view.LeftPanelGUI.prototype.injectInto = function(parentElement) {
  
  this.tabStrip1.injectInto(parentElement);
  this.tabStrip1.injectCss();
  
  var el = this.tabStrip1.getMainElement();
  el.css("padding-top","68px");

};


goog.provide('lgb.gui.controller.LeftPanelController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.controller.TestController');
goog.require('lgb.gui.controller.ScenarioController');
goog.require('lgb.gui.controller.BuildingController');
goog.require('lgb.gui.controller.SimulationStateController');
goog.require('lgb.gui.view.SimulationStateControlGUI');

goog.require('lgb.gui.view.LeftPanelGUI');
goog.require('lgb.gui.model.BaseGuiModel');
goog.require('lgb.gui.view.BottomPanelGUI');

lgb.gui.controller.LeftPanelController = function() {

  lgb.core.BaseController.call(this);

};
goog.inherits(lgb.gui.controller.LeftPanelController, lgb.core.BaseController);


/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.LeftPanelController.prototype.init = function() {

  this.dataModel = new lgb.gui.model.BaseGuiModel();
  
  this.guiView = new lgb.gui.view.LeftPanelGUI(this.dataModel);
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  
  this.bind_();
  
  this.makeChildGUIcontroller_(lgb.gui.controller.TestController);
  
};



lgb.gui.controller.LeftPanelController.prototype.bind_ = function() {

  this.listenOnce (
    e.ScenarioDataModelLoaded,
    this.onScenarioDataModelLoaded_
  );
  
  this.listenOnce (
      e.SimulationEngineLoaded,
      this.onSimulationEngineLoaded_
  );
    
};


lgb.gui.controller.LeftPanelController.prototype.onSimulationEngineLoaded_ = function(event) {

  var simulationMainController = event.payload;
  this.init3_(simulationMainController);
  
};


lgb.gui.controller.LeftPanelController.prototype.onScenarioDataModelLoaded_ = function(event) {

  var systemListDataModel = event.payload;
  this.init2_(systemListDataModel);
  
};


lgb.gui.controller.LeftPanelController.prototype.init2_ = function(systemListDataModel) {

  this.makeChildGUIcontroller_(lgb.gui.controller.ScenarioController, systemListDataModel);
  this.makeChildGUIcontroller_(lgb.gui.controller.BuildingController, systemListDataModel);

};


lgb.gui.controller.LeftPanelController.prototype.init3_ = function(simulationMainController) {
  
  this.makeChildGUIcontroller_(lgb.gui.controller.SimulationStateController, simulationMainController);

};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.chart.model.GraphGUImodel');
goog.require('lgb.world.model.BaseModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.chart.model.GraphGUImodel = function() {

  /**@const */
  this._TITLE = 'GraphGUImodel';


  lgb.world.model.BaseModel.call(this);
  this.data = [];
  
  this.init_();

  
};
goog.inherits(lgb.chart.model.GraphGUImodel, lgb.world.model.BaseModel);



lgb.chart.model.GraphGUImodel.prototype.generateData = function() {
  
  // this.data = [
   // { timeString: "07:45:00", value: 20.0},
   // { timeString: "07:46:00", value: 22.0},
   // { timeString: "07:47:00", value: 23.0},
   // { timeString: "07:48:00", value: 24.0}
  // ];
  
  this.data = [];
  
  
};


lgb.chart.model.GraphGUImodel.prototype.extractFromResults = function(scalarValueResultsConverted) {
  
  var realList = scalarValueResultsConverted.output.realList;
  
  var scalarValue = realList[7];
 // var scalarValue = realList[10];
  
  var value = parseFloat(scalarValue.value_);
  var timeString = scalarValueResultsConverted.time_;
  var dateObj = this.formatDateObj_ .parse(timeString);
    

  var newRecord = { dateObj: dateObj ,  value:  value};
  
  this.data.push(newRecord); 
    
};






lgb.chart.model.GraphGUImodel.prototype.init_ = function() {
  
  this.generateData();
   
  
  var formatDateObj = d3.time.format("%H:%M:%S");
  this.formatDateObj_ = formatDateObj;

  this.data.forEach(function(d,i) {
    d.dateObj = formatDateObj.parse(d.timeString);
  });

  
  this.y = {
    max:295,
    min:288,
    mean:295,
    deviation:4
  };
  
  
  
  this.domainY_ = [
    this.y.min,
    this.y.max
  ];
  
  
  var minDate = formatDateObj.parse("7:45:00");
  var maxDate  = formatDateObj.parse("8:00:00");
  



  this.domainX_ = [
    minDate,
    maxDate
  ];
  
  var that = this;
  
  
  this.generateRandomFunction = function() {
    var randomFunction = d3.random.normal(that.y.mean, that.y.deviation);
    return randomFunction;
  };
  

};

lgb.chart.model.GraphGUImodel.prototype.getDomainX = function() {
 
    return this.domainX_;
};


lgb.chart.model.GraphGUImodel.prototype.getDomainY = function() {
 
    return this.domainY_;
};





goog.provide('lgb.chart.view.GraphGUI_04');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.chart.model.GraphGUImodel');


lgb.chart.view.GraphGUI_04 = function(dataModel, chartModel) {

  this._TITLE = 'GraphGUI_04';
  this.chartModel_ = chartModel;
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.totalHeaderHeight_ = 70;
  this.isDirty_ = false;
  this.blockUpdates_ = false;
};
goog.inherits(lgb.chart.view.GraphGUI_04, lgb.gui.view.BaseGUI);



lgb.chart.view.GraphGUI_04.prototype.init = function() {

    this.listenForChange_('scalarValueResultsConverted');
    this.tickDelegate_ = this.d(this.tick_);
    this.contentArea_ = {};
    
};




lgb.chart.view.GraphGUI_04.prototype.onChange_scalarValueResultsConverted_ = function(scalarValueResultsConverted) {
  
  this.chartModel_.extractFromResults(scalarValueResultsConverted);
  

  //redraw the line
  this.chart_.path
      .attr("d", this.chart_.line);
    
  return;
  
};









lgb.chart.view.GraphGUI_04.prototype.makeChart_ = function() {
  
  var chartModel = this.chartModel_;

  var el = this.getMainElement();
  
  
  this.calculateContentArea_();
  
  var margin = {top: 20, right: 40, bottom: 20, left: 40},
      width = this.contentArea_.width - margin.left - margin.right,
      height = this.contentArea_.height - margin.top - margin.bottom;
   
   
  var scaleObjectX = d3.time.scale();
  var domainX = chartModel.getDomainX(); 
  
  var x = scaleObjectX
      .domain(domainX)
      .range([0, width]);
   
  var scaleObjectY = d3.scale.linear();
  
  
  
  var domainY = chartModel.getDomainY();
  var y = scaleObjectY
      .domain(domainY)
      .range([height, 0]);
   
   
  var line = d3.svg.line()
      .x(function(d, i) { return x(d.dateObj); })
      .y(function(d, i) { return y(d.value); });
   

   
   
  var svg = d3.select(el[0]).append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
   
  svg.append("defs").append("clipPath")
      .attr("id", "clip")
    .append("rect")
      .attr("width", width)
      .attr("height", height);
   
  svg.append("g")
      .attr("class", "x axis")
      .call(d3.svg.axis().scale(x).orient("bottom"));
   
  //make the y axis
  svg.append("g")
      .attr("class", "y axis")
      .call(d3.svg.axis().scale(y).orient("left"));
   
   
  var path = svg.append("g")
    .append("path")
      .datum(chartModel.data)
      .attr("class", "line")
      .attr("d", line);
   

      
      
 this.chart_={};
 this.chart_.data = chartModel.data;
 this.chart_.path = path;
 this.chart_.x = x;
 this.chart_.line = line;
 
    

};




lgb.chart.view.GraphGUI_04.prototype.tick_ = function() {
  
    var chartModel = this.chartModel_;
    var rndfunction = chartModel.generateRandomFunction();
    
    // push a new data point onto the back
    this.chart_.data.push(rndfunction());
   
    // redraw the line, and slide it to the left
    this.chart_.path
        .attr("d", this.chart_.line)
        .attr("transform", null)
      .transition()
        .duration(500)
        .ease("linear")
        .attr("transform", "translate(" + this.chart_.x(-1) + ",0)");
   
   
    // pop the old data point off the front
    this.chart_.data.shift();
    
    
};


lgb.chart.view.GraphGUI_04.prototype.injectInto = function(parentElement) {
  

    goog.base(this,  'injectInto', parentElement);
    this.makeChart_();

};







lgb.chart.view.GraphGUI_04.prototype.calculateContentArea_ = function() {
  

      this.contentArea_.width = window.innerWidth -30;
      this.contentArea_.height = window.innerHeight -150;

};













goog.provide('lgb.chart.view.GraphGUI_05');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.chart.model.GraphGUImodel');


lgb.chart.view.GraphGUI_05 = function(dataModel, chartModel) {

  this._TITLE = 'GraphGUI_05';
  
  this.chartModel = chartModel;
  
  lgb.gui.view.BaseGUI.call(this, dataModel);

};
goog.inherits(lgb.chart.view.GraphGUI_05, lgb.gui.view.BaseGUI);



lgb.chart.view.GraphGUI_05.prototype.init = function() {


    this.listenForChange_('scalarValueResultsConverted');
    // this.listenForChange_('xmlParsedInfo');
    
    this.tickDelegate_ = this.d(this.tick_);
    
    this.contentArea_ = {};
    
    this.triggerLocal(e.RequestAddToParentGUI);

};



lgb.chart.view.GraphGUI_05.prototype.onChange_xmlParsedInfo_ = function(xmlParsedInfo) {
  
  this.xmlParsedInfo = xmlParsedInfo;
   
  return;
};





lgb.chart.view.GraphGUI_05.prototype.onChange_scalarValueResultsConverted_ = function(scalarValueResultsConverted) {
  
  var realList = scalarValueResultsConverted.output.realList;
  var newRecord = { time: scalarValueResultsConverted.time_};
  
  var testTempRealVo = realList[7];
  
  this.chart_.data.push(testTempRealVo.value_);
 
  // redraw the line, and slide it to the left
  this.chart_.path
      .attr("d", this.chart_.line)
      .attr("transform", null)
    .transition()
      .duration(500)
      .ease("linear")
      .attr("transform", "translate(" + this.chart_.x(-1) + ",0)");
 
 
  // pop the old data point off the front
  this.chart_.data.shift();
    
  return;
  
};






lgb.chart.view.GraphGUI_05.prototype.makeChart_ = function() {
  
  var dm = this.chartModel;
  var n = dm.x.max;
  
  
  var el = this.getMainElement();
  
  var data = d3.range(n).map(dm.generateRandomFunction());
  
  this.calculateContentArea_();
  
  var margin = {top: 20, right: 40, bottom: 20, left: 40},
      width = this.contentArea_.width - margin.left - margin.right,
      height = this.contentArea_.height - margin.top - margin.bottom;
   
  var scaleObjectX = d3.scale.linear();
  var x = scaleObjectX
      .domain(dm.getDomainX())
      .range([0, width]);
   
  var scaleObjectY = d3.scale.linear();
  var y = scaleObjectY
      .domain(dm.getDomainY())
      .range([height, 0]);
   
   
  var line = d3.svg.line()
      .x(function(d, i) { return x(i); })
      .y(function(d, i) { return y(d); });
   
  var svg = d3.select(el[0]).append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
   
  svg.append("defs").append("clipPath")
      .attr("id", "clip")
    .append("rect")
      .attr("width", width)
      .attr("height", height);
   
  svg.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + y(0) + ")")
      .call(d3.svg.axis().scale(x).orient("bottom"));
   
  svg.append("g")
      .attr("class", "y axis")
      .call(d3.svg.axis().scale(y).orient("left"));
   
  var path = svg.append("g")
    .append("path")
      .datum(data)
      .attr("class", "line")
      .attr("d", line);
   
   
 this.chart_={};
 this.chart_.data =data;
 this.chart_.path =path;
 this.chart_.x = x;
 this.chart_.line = line;
 


};



lgb.chart.view.GraphGUI_05.prototype.tick_ = function() {
  
    var dm = this.chartModel_;
    var rndfunction = dm.generateRandomFunction();
    
    // push a new data point onto the back
    this.chart_.data.push(rndfunction());
   
    // redraw the line, and slide it to the left
    this.chart_.path
        .attr("d", this.chart_.line)
        .attr("transform", null)
      .transition()
        .duration(500)
        .ease("linear")
        .attr("transform", "translate(" + this.chart_.x(-1) + ",0)");
   
   
    // pop the old data point off the front
    this.chart_.data.shift();
    
    
};



lgb.chart.view.GraphGUI_05.prototype.injectInto = function(parentElement) {
  

    goog.base(this,  'injectInto', parentElement);
    this.makeChart_();

};







lgb.chart.view.GraphGUI_05.prototype.calculateContentArea_ = function() {
  
    var url = $.url(); // parse the current page URL
    var width = url.param('width');
    var height = url.param('height');
    
    if (undefined == width) {
      this.contentArea_.width = window.innerWidth -30;
    } else {
      this.contentArea_.width = parseFloat (width)-20 ;
    }

    if (undefined == height) {
      this.contentArea_.height = window.innerHeight -30;
    } else {
      this.contentArea_.height = parseFloat (height) -20 ;
    }
    
};










/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 

goog.provide('lgb.gui.controller.SimulationGraphController');

goog.require('lgb.core.BaseController');
goog.require('lgb.chart.view.GraphGUI_05');
goog.require('lgb.chart.view.GraphGUI_04');
goog.require('lgb.chart.model.GraphGUImodel');


/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.SimulationGraphController = function() {

  this.TITLE_ = 'Graph';
  lgb.core.BaseController.call(this);
  


};
goog.inherits(lgb.gui.controller.SimulationGraphController, lgb.core.BaseController);



lgb.gui.controller.SimulationGraphController.prototype.init = function(simDataModel) {

  this.dataModel = simDataModel;
  this.bind1_();
  
};




lgb.gui.controller.SimulationGraphController.prototype.bind1_ = function() {


    this.listen (
        e.SimulationInitialized,
        this.onSimulationInitialized_
    );
    
};

lgb.gui.controller.SimulationGraphController.prototype.onSimulationInitialized_ = function(event) {


  this.init2_();

};


lgb.gui.controller.SimulationGraphController.prototype.bind2_ = function() {

  this.relayLocal(
    this.guiView,
    e.RequestAddToParentGUI);
   
};


lgb.gui.controller.SimulationGraphController.prototype.onLayoutChange_ = function(event) {

  this.guiView.calculateLayout(event.payload);

};



lgb.gui.controller.SimulationGraphController.prototype.init2_ = function() {
  
  this.chartModel = new lgb.chart.model.GraphGUImodel();
  
  this.guiView = new lgb.chart.view.GraphGUI_04 (this.dataModel, this.chartModel);




  this.bind2_();
  this.guiView.init();
  
  this.listen(e.LayoutChange, this.onLayoutChange_);
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
    
    
};



goog.provide('lgb.gui.view.SimulationResultsGUI');


lgb.gui.view.SimulationResultsGUI = function(dataModel) {

  this._TITLE = 'Results';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.totalHeaderHeight_ = 94;
  this.isDirty_ = false;
  this.blockUpdates_ = false;
};
goog.inherits(lgb.gui.view.SimulationResultsGUI, lgb.gui.view.BaseGUI);



lgb.gui.view.SimulationResultsGUI.prototype.init = function() {


    this.listenForChange_('scalarValueResultsConverted');
    this.listenForChange_('xmlParsedInfo');
    
    this.triggerLocal(e.RequestAddToParentGUI);
    
    
};



lgb.gui.view.SimulationResultsGUI.prototype.onChange_xmlParsedInfo_ = function(xmlParsedInfo) {
  
  this.realVarList_ = xmlParsedInfo.scalarVariablesAll_.output_.realVarList_;
  
  var len = this.realVarList_.length;
  // for (var i=0; i < len; i++) {
    // if (this.realVarList_[i].unit_ == "K") {
      // this.realVarList_[i].unit_ = "C";
    // }
  // };
  
  
  this.makeTable_(  this.realVarList_ );
  
};


lgb.gui.view.SimulationResultsGUI.prototype.onChange_scalarValueResultsConverted_ = function(scalarValueResultsConverted) {
  
  var realList = scalarValueResultsConverted.output.realList;
  var newRecord = { time: scalarValueResultsConverted.time_};
  
  var len = realList.length;
  for (i=0;i<len;i++) {

     varName = this.idxToNameMap_[i];
     newRecord[varName] = realList[i].value_;
  }
  
  var dataItem = this.gridDS_.insert(0, newRecord );
  
  var count = this.gridDS_._data.length;
  if (count  > 500) {

    var model = this.gridDS_.at(count-1);
    this.gridDS_.remove(model);
  }
  
};



lgb.gui.view.SimulationResultsGUI.prototype.calculateLayout = function() {
  
  if (this.kendoGridContent_) {
    
    var p = this.getParentElement();
    var gp = p[0].parentElement;
    var paneHeight = gp.clientHeight;
    
    var contentHeight = paneHeight - this.totalHeaderHeight_;
    var cssStr = contentHeight + 'px';
    
    this.kendoGridContent_.css("height", cssStr);
  }
     

};



lgb.gui.view.SimulationResultsGUI.prototype.injectInto = function(parentElement) {
  

  goog.base(this,  'injectInto', parentElement);

  
};





lgb.gui.view.SimulationResultsGUI.prototype.updateAll_ = function() {
  
  this.gridDS_.read();
  this.isDirty_ = false;
  
};




lgb.gui.view.SimulationResultsGUI.prototype.makeTable_ = function(varList) {
  
  this.idxToNameMap_ ={};
  
  fields = {};
  fields['time'] = { type: "number" };
  
  columns = [];
  columns.push({ field: 'time', title: 'time' , width: "70px"});
  
  var data = {};
  
  
  len = varList.length;
  for (i=0;i<len;i++) {
    
    varName = varList[i].name_;
    varName = varName.split('.').join('_');
    varName = varName.split('y_').join('');
    varName = varName.split('[').join('_');
    varName = varName.split(']').join('');
    
    fields[varName] = { type: "number" };
    
    columns.push({ field: varName, title: varName , width: "80px"});
    
    this.idxToNameMap_[i] = varName;
  }
  
  
  var ds = {
              data: {},
              schema: {
                  model: {
                    fields : fields
                  }
              }
            };
        
        
      
      this.gridDS_ = new kendo.data.DataSource(ds);
      var el = this.getMainElement();
   
      this.kendoGrid_ = el.kendoGrid({
          dataSource: this.gridDS_,
          scrollable: true,
          sortable: true,
          filterable: false,
          columnResize: false,
          columns : columns
      });
      
    this.kendoGridContent_ = this.kendoGrid_.find('.k-grid-content');
    this.calculateLayout();
      
};







/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 

goog.provide('lgb.gui.controller.SimulationResultsController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.SimulationResultsGUI');



/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.SimulationResultsController = function() {

  lgb.core.BaseController.call(this);
  

};
goog.inherits(lgb.gui.controller.SimulationResultsController, lgb.core.BaseController);


lgb.gui.controller.SimulationResultsController.prototype.bind_ = function() {
    this.listen(e.LayoutChange, this.onLayoutChange_);
};




lgb.gui.controller.SimulationResultsController.prototype.init = function(simulationDataModel) {
  
  this.dataModel = simulationDataModel;
  this.guiView = new lgb.gui.view.SimulationResultsGUI (this.dataModel, this.TITLE_);
  
  this.guiView.init();
  this.bind_();
  
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  
};



lgb.gui.controller.SimulationResultsController.prototype.onLayoutChange_ = function(event) {

  this.guiView.calculateLayout(event.payload);

};

goog.provide('lgb.gui.view.SimulationOutputGUI');


lgb.gui.view.SimulationOutputGUI = function(dataModel) {

  this._TITLE = 'Output';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.totalHeaderHeight_ = 94;

};
goog.inherits(lgb.gui.view.SimulationOutputGUI, lgb.gui.view.BaseGUI);



lgb.gui.view.SimulationOutputGUI.prototype.init = function() {


    this.listenForChange_('scalarValueResultsConverted');
    this.listenForChange_('xmlParsedInfo');
    //this.listenForChange_('scalarValueResults');
    
    
    this.triggerLocal(e.RequestAddToParentGUI);
    
    
};



lgb.gui.view.SimulationOutputGUI.prototype.onChange_xmlParsedInfo_ = function(xmlParsedInfo) {
  
  this.realVarList_ = xmlParsedInfo.scalarVariablesAll_.output_.realVarList_;
  
  var len = this.realVarList_.length;
  
  // for (var i=0; i < len; i++) {
    // if (this.realVarList_[i].unit_ == "K") {
      // this.realVarList_[i].unit_ = "C";
    // }
  // };
  
  
  this.makeTable_(  this.realVarList_ );
  

  
};

// lgb.gui.view.SimulationOutputGUI.prototype.onChange_scalarValueResults_ = function(scalarValueResults) {
//   
//   
  // this.eachIdx(scalarValueResults.output.realList, this.updateOneRow_);
  // this.gridDS_.read();
//   
// };


lgb.gui.view.SimulationOutputGUI.prototype.onChange_scalarValueResultsConverted_ = function(scalarValueResultsConverted) {
  
  
  this.eachIdx(scalarValueResultsConverted.output.realList, this.updateOneRow_);
  this.gridDS_.read();
  
};



lgb.gui.view.SimulationOutputGUI.prototype.updateOneRow_ = function(realVo, idx) {
  
/*
  var value = row.value_.toFixed(4);
  var theVar = this.realVarList_[idx];
  
  var degC = value-273.15;
  var degF = 1.8 * degC +32;
  
  switch(theVar.unit_) {
    case "C" :
      value = degC.toFixed(4);
    case "F" :
      value = degF.toFixed(4);
  }
  
 this.gridDS_.options.data[idx].value = value;
    
    */

    
  var existingValue = this.gridDS_.options.data[idx].value;
  var newValue = realVo.value_;

  if (newValue != existingValue) {
     this.gridDS_.options.data[idx].value_ = newValue;
  }
   

};



lgb.gui.view.SimulationOutputGUI.prototype.calculateLayout = function() {
  
  if (this.kendoGridContent_) {
    
    var p = this.getParentElement();
    var gp = p[0].parentElement;
    var paneHeight = gp.clientHeight;
    
    var contentHeight = paneHeight - this.totalHeaderHeight_;
    var cssStr = contentHeight + 'px';
    
    this.kendoGridContent_.css("height", cssStr);
  }
     

};



/*
lgb.gui.view.SimulationOutputGUI.prototype.injectInto = function(parentElement) {
  
  goog.base(this,  'injectInto', parentElement);

};

*/



lgb.gui.view.SimulationOutputGUI.prototype.makeTable_ = function(varList) {
  
  
  
  var ds = {
              data: varList,
              schema: {
                  model: {
                      fields: {
                          causality_: { type: "number" },
                          description_: { type: "string" },
                          idx_: { type: "number" },
                          name_: { type: "string" },
                          value_: { type: "number" },
                          "typeSpecReal_.unit": { type: "string" },
                          "typeSpecReal_.min" : { type: "number" },
                          "typeSpecReal_.max" : { type: "number" },
                          "typeSpecReal_.start" : { type: "number" },
                          valueReference_: { type: "number" },
                          variability_: { type: "number" }
                      }
                  }
              }

        };
        
    this.gridDS_ = new kendo.data.DataSource(ds);
    
    
      var el = this.getMainElement();
   
      this.kendoGrid_ = el.kendoGrid({
          dataSource: this.gridDS_,
          scrollable: true,
          sortable: true,
          filterable: false,
          columnResize: true,
          columns: [
              { field: "idx_", title: "idx" , width: "40px"},
              { field: "name_", title: "Name", width: "60px" },
              { field: "value_", title: "Value", width: "60px" },
              { field: "typeSpecReal_.unit", title: "Unit", width: "60px" },
              { field: "description_", title: "Description" , width: "140px"},
              { field: "typeSpecReal_.min", title: "Min" , width: "20px"},
              { field: "typeSpecReal_.max", title: "Max" , width: "30px"},
              { field: "typeSpecReal_.start", title: "Start" , width: "30px"},
              { field: "variability_", title: "Var" , width: "20px"}
          ]
      });
      
    this.kendoGridContent_ = this.kendoGrid_.find('.k-grid-content');
    this.calculateLayout();  
      
};







/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 

goog.provide('lgb.gui.controller.SimulationOutputController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.SimulationOutputGUI');



/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.SimulationOutputController = function() {

  lgb.core.BaseController.call(this);

};
goog.inherits(lgb.gui.controller.SimulationOutputController, lgb.core.BaseController);


lgb.gui.controller.SimulationOutputController.prototype.init = function(simulationDataModel) {

  this.dataModel = simulationDataModel;
  this.guiView = new lgb.gui.view.SimulationOutputGUI (this.dataModel);
  
  this.bind_();
  
  this.triggerGUI();


};


lgb.gui.controller.SimulationOutputController.prototype.bind_ = function() {

    this.listen(e.LayoutChange, this.onLayoutChange_);

};


lgb.gui.controller.SimulationOutputController.prototype.onLayoutChange_ = function(event) {

  this.guiView.calculateLayout(event.payload);

};

goog.provide('lgb.gui.view.SimulationInputGUI');


lgb.gui.view.SimulationInputGUI = function(dataModel) {

  this._TITLE = 'Input';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.totalHeaderHeight_ = 94;
  this.blockUpdates_ = false;
};
goog.inherits(lgb.gui.view.SimulationInputGUI, lgb.gui.view.BaseGUI);



lgb.gui.view.SimulationInputGUI.prototype.init = function() {

    this.listenForChange_('xmlParsedInfo');
    this.listenForChange_('scalarValueResultsConverted');
    
};



lgb.gui.view.SimulationInputGUI.prototype.onChange_scalarValueResultsConverted_ = function(scalarValueResultsConverted) {
  
  this.updateTable_(scalarValueResultsConverted.input.realList);
  
};


lgb.gui.view.SimulationInputGUI.prototype.updateTable_ = function(realList) {
  
  this.eachIdx(realList, this.updateRow_);
  this.gridDS_.read();

};


lgb.gui.view.SimulationInputGUI.prototype.updateRow_ = function(realVo, idx) {
  
  var existingValue = this.gridDS_.options.data[idx].value;
  var newValue = realVo.value_;

  if (newValue != existingValue) {
     this.gridDS_.options.data[idx].value = newValue;
  }
   
};





lgb.gui.view.SimulationInputGUI.prototype.onChange_xmlParsedInfo_ = function(xmlParsedInfo) {
  
  
/*
  var Input_= xmlParsedInfo.scalarVariablesAll_.Input_;
  var internal_= xmlParsedInfo.scalarVariablesAll_.internal_;
  var input_= xmlParsedInfo.scalarVariablesAll_.input_;*/

  this.realVarList_ = xmlParsedInfo.scalarVariablesAll_.input_.realVarList_;
  
  // var len = this.realVarList_.length;
  // for (var i=0; i < len; i++) {
    // if (this.realVarList_[i].unit_ == "K") {
      // this.realVarList_[i].unit_ = "C";
    // }
  // };
  
  
  this.makeTable_(  this.realVarList_ );
  
  

};




lgb.gui.view.SimulationInputGUI.prototype.calculateLayout = function() {
  
  if (this.kendoGridContent_) {
    
    var p = this.getParentElement();
    var gp = p[0].parentElement;
    var paneHeight = gp.clientHeight;
    
    var contentHeight = paneHeight - this.totalHeaderHeight_;
    var cssStr = contentHeight + 'px';
    
    this.kendoGridContent_.css("height", cssStr);
  }

     

};



lgb.gui.view.SimulationInputGUI.prototype.injectInto = function(parentElement) {
  

  goog.base(this,  'injectInto', parentElement);

  
};



lgb.gui.view.SimulationInputGUI.prototype.makeTable_ = function(varList) {
  

  var ds = {
              data: varList,
              schema: {
                  model: {
                      fields: {
                          causality_: { type: "number" },
                          description_: { type: "string" },
                          idx_: { type: "number" },
                          name_: { type: "string" },
                          value_: { type: "number" },
                          "typeSpecReal_.unit": { type: "string" },
                          "typeSpecReal_.min" : { type: "number" },
                          "typeSpecReal_.max" : { type: "number" },
                          "typeSpecReal_.start" : { type: "number" },
                          valueReference_: { type: "number" },
                          variability_: { type: "number" }
                      }
                  }
              }

        };
        
    this.gridDS_ = new kendo.data.DataSource(ds);
    
    
      var el = this.getMainElement();
   
      this.kendoGrid_ = el.kendoGrid({
          dataSource: this.gridDS_,
          scrollable: true,
          sortable: true,
          filterable: false,
          columnResize: true,
          columns: [
              { field: "idx_", title: "idx" , width: "40px"},
              { field: "name_", title: "Name", width: "60px" },
              { field: "value_", title: "Value", width: "60px" },
              { field: "typeSpecReal_.unit", title: "Unit", width: "60px" },
              { field: "description_", title: "Description" , width: "140px"},
              { field: "typeSpecReal_.min", title: "Min" , width: "20px"},
              { field: "typeSpecReal_.max", title: "Max" , width: "30px"},
              { field: "typeSpecReal_.start", title: "Start" , width: "30px"},
              { field: "variability_", title: "Var" , width: "20px"}
          ]
      });
      
      
    this.kendoGridContent_ = this.kendoGrid_.find('.k-grid-content');
    this.calculateLayout();  
      
      
};







/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 

goog.provide('lgb.gui.controller.SimulationInputController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.SimulationInputGUI');



/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.SimulationInputController = function() {

  lgb.core.BaseController.call(this);
  
};
goog.inherits(lgb.gui.controller.SimulationInputController, lgb.core.BaseController);


lgb.gui.controller.SimulationInputController.prototype.init = function(simulationDataModel) {
  
  this.dataModel = simulationDataModel;
  this.guiView = new lgb.gui.view.SimulationInputGUI (this.dataModel);
  
  this.bind_();
  
  this.triggerGUI();

  
};



lgb.gui.controller.SimulationInputController.prototype.bind_ = function() {

    this.listen(e.LayoutChange, this.onLayoutChange_);

};


lgb.gui.controller.SimulationInputController.prototype.onLayoutChange_ = function(event) {

  this.guiView.calculateLayout(event.payload);

};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 

goog.provide('lgb.gui.controller.SimulationConsoleController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.SimulationConsoleGUI');


/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.SimulationConsoleController = function() {
;
  lgb.core.BaseController.call(this);
  
};
goog.inherits(lgb.gui.controller.SimulationConsoleController, lgb.core.BaseController);



lgb.gui.controller.SimulationConsoleController.prototype.init = function(simulationDataModel) {

  this.dataModel = simulationDataModel;
  this.guiView = new lgb.gui.view.SimulationConsoleGUI (this.dataModel);
  
  this.bind_();
  
  this.triggerGUI();

};


lgb.gui.controller.SimulationConsoleController.prototype.bind_ = function() {

    this.listen(e.LayoutChange, this.onLayoutChange_);

};


lgb.gui.controller.SimulationConsoleController.prototype.onLayoutChange_ = function(event) {

  this.guiView.calculateLayout(event.payload);

};


goog.provide('lgb.chart.view.SimulationIframeGraphGUI');


lgb.chart.view.SimulationIframeGraphGUI = function(dataModel) {

  this._TITLE = 'Graph-Iframe';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.totalHeaderHeight_ = 70;
  this.isDirty_ = false;
  this.blockUpdates_ = false;
};
goog.inherits(lgb.chart.view.SimulationIframeGraphGUI, lgb.gui.view.BaseGUI);



lgb.chart.view.SimulationIframeGraphGUI.prototype.init = function() {

    this.sessionID_ = 'last';
    this.server_ = 'localhost';

};






lgb.chart.view.SimulationIframeGraphGUI.prototype.calculateLayout = function(theVar) {
  
  
  this.setWidthAndHeight_();

  var src = this.getSrc_();
  this.iframe.attr("src", src);
  this.iframe.attr("width", this.width);
  this.iframe.attr("height", this.height);

  return;
};


lgb.chart.view.SimulationIframeGraphGUI.prototype.injectInto = function(parentElement) {
  
  
  
  
  this.graphContainerDiv_ = this.makeDiv();
  this.append(this.graphContainerDiv_);
  
  goog.base(this, 'injectInto', parentElement);
  
  this.setWidthAndHeight_();
  
  var sessionID = this.dataModel.xmlParsedInfo.sessionID_;

  var src = "/LearnHPB/chartIframe.html?width={0}&height={1}&sessionID={2}"
  .format(this.width, this.height, sessionID);
  
  //this.iframe.attr("src", src);
  
  
  

  
  // var src = this.getSrc_();
  var src = "#";
  
  var tag = '<iframe src="{0}" width="{1}" height="{2}" frameborder="0"></iframe>'.
    format(src, this.width, this.height);
  
  
  this.iframe = $(tag);

  this.graphContainerDiv_.append(this.iframe);

};



lgb.chart.view.SimulationIframeGraphGUI.prototype.setWidthAndHeight_ = function() {
  
  var p = this.getParentElement().parent();
  this.width = p.width() - 36;
  this.height = p.height();
  
};

lgb.chart.view.SimulationIframeGraphGUI.prototype.getSrc_ = function(server, sessionID) {
 

  var src = "/LearnHPB/test/chart_04.html?server={0}&sessionID={1}&width={2}&height={3}".
    format(this.server_, this.sessionID_, this.width, this.height);
    

  return src;
  
};









/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 

goog.provide('lgb.gui.controller.SimulationIframeGraphController');

goog.require('lgb.core.BaseController');
goog.require('lgb.chart.view.SimulationIframeGraphGUI');



/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.SimulationIframeGraphController = function() {

  this.TITLE_ = 'Graph';
  lgb.core.BaseController.call(this);
  
  this.bind1_();

};
goog.inherits(lgb.gui.controller.SimulationIframeGraphController, lgb.core.BaseController);




lgb.gui.controller.SimulationIframeGraphController.prototype.init = function(simulationDataModel) {
  
  this.dataModel = simulationDataModel;

};


lgb.gui.controller.SimulationIframeGraphController.prototype.init2_ = function() {
  
 
  this.guiView = new lgb.chart.view.SimulationIframeGraphGUI (this.dataModel, this.TITLE_);
  this.guiView.init();
  
  this.listen(e.LayoutChange, this.onLayoutChange_);
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
      
};





lgb.gui.controller.SimulationIframeGraphController.prototype.onSimulationInitialized_ = function(event) {

  this.init2_();

};



lgb.gui.controller.SimulationIframeGraphController.prototype.bind1_ = function() {

    this.listen (
        e.SimulationInitialized,
        this.onSimulationInitialized_
    );

   
};






lgb.gui.controller.SimulationIframeGraphController.prototype.onLayoutChange_ = function(event) {

  this.guiView.calculateLayout(event.payload);

};



goog.provide('lgb.gui.controller.BottomPanelIframeGUIController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.BottomPanelGUI');
goog.require('lgb.gui.model.BaseGuiModel');

goog.require('lgb.gui.controller.SimulationConsoleController');
goog.require('lgb.gui.controller.SimulationOutputController');
goog.require('lgb.gui.controller.SimulationInputController');
goog.require('lgb.gui.controller.SimulationResultsController');
goog.require('lgb.gui.controller.SimulationGraphController');
goog.require('lgb.gui.controller.SimulationIframeGraphController');




lgb.gui.controller.BottomPanelIframeGUIController = function() {

  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.gui.controller.BottomPanelIframeGUIController, lgb.core.BaseController);


/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.BottomPanelIframeGUIController.prototype.init = function() {

  this.dataModel = new lgb.gui.model.BaseGuiModel();
  this.guiView = new lgb.gui.view.BottomPanelGUI(this.dataModel);
  
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  
  this.bind_();

};

lgb.gui.controller.BottomPanelIframeGUIController.prototype.bind_ = function() {

    this.listenOnce (
        e.SimulationEngineLoaded,
        this.onSimulationEngineLoaded_
    );
    
};


lgb.gui.controller.BottomPanelIframeGUIController.prototype.onSimulationEngineLoaded_ = function(event) {
  
  simMainController = event.payload;
  var simDataModel = simMainController.getDataModel();
  
  this.init2_(simDataModel);

};


lgb.gui.controller.BottomPanelIframeGUIController.prototype.init2_ = function(simDataModel) {
  

  this.makeChildGUIcontroller_
    (lgb.gui.controller.SimulationConsoleController, simDataModel);

  // this.makeChildGUIcontroller_
    // (lgb.gui.controller.SimulationInputController, simDataModel);


  this.makeChildGUIcontroller_
    (lgb.gui.controller.SimulationOutputController, simDataModel);
    
    
     
  this.makeChildGUIcontroller_
    (lgb.gui.controller.SimulationResultsController, simDataModel);
    
    
  this.makeChildGUIcontroller_
    (lgb.gui.controller.SimulationIframeGraphController, simDataModel);
    
    

   
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

/**
 * @author Raj Dye - raj@rajdye.com
 */

goog.provide('lgb.component.TreeDataSourceH');
goog.require('lgb.component.BaseDataSource');


lgb.component.TreeDataSourceH = function(lgbNode, propertyName, parentHtmlID, subID, title) {

  
  if(title) {
    this.title_ = title;
  }
  
  this.propertyName_ = propertyName;
  
  lgb.component.BaseDataSource.call(this);

  this.parentHtmlID = parentHtmlID;
  this.generateHTMLid_();
  
  this.changedItems_ = [];
  
  if(lgbNode) {
    this.build_(lgbNode);
    
    if (!this.title_) {
        this.title_ = lgbNode.title;
    }
  }
  
  this.selectedKNode = null;
  this.showKNode = null;
  this.hideKNode = null;
  
  
  this.options =  (
    {
      events : {mouseOver:false}
    }
  );

};
goog.inherits(lgb.component.TreeDataSourceH, lgb.component.BaseDataSource);


lgb.component.TreeDataSourceH.prototype.setOptions = function(options) {
  this.options = options;
};


lgb.component.TreeDataSourceH.prototype.select = function(uid) {
    var knode = this.kendoDS.getByUid(uid);
    this.changePropertyEx('selectedKNode', knode);
};

lgb.component.TreeDataSourceH.prototype.setFocus = function(uid) {
    var knode = this.kendoDS.getByUid(uid);
    this.changePropertyEx('showKNode', knode);
    this.hideKNode = null;
};

lgb.component.TreeDataSourceH.prototype.removeFocus = function(uid) {
    var knode = this.kendoDS.getByUid(uid);
    this.changePropertyEx('hideKNode', knode);
    this.showKNode = null;
};


lgb.component.TreeDataSourceH.prototype.generateHTMLid_ = function(node) {
  
    var str = this.title_.split(' ').join('');
    str = str.split('.').join('');
    
    this.htmlID = this.parentHtmlID + '-' + str;
    
};

lgb.component.TreeDataSourceH.prototype.update = function(lgbNode) {

  if (this.rootNode) {
    var n = this.makeKendoNodes_(lgbNode);
    this.kendoDS.add(n);
  } else {
    this.build_(lgbNode);
  }

};

lgb.component.TreeDataSourceH.prototype.build_ = function(lgbNode) {


  this.rootKendoNode = this.makeKendoNodes_(lgbNode);
  
  var options = {
    data : [this.rootKendoNode]
  };

  this.kendoDS = new kendo.data.HierarchicalDataSource(options);
  this.kendoDS.read();

  this.rootNode = this.kendoDS.get(this.rootKendoNode.id);
  this.rootNode.load();

  this.bind_();
  
};
  


lgb.component.TreeDataSourceH.prototype.makeOneKendoNode_ = function(lgbNode) {
  
  var knode = {
    text : lgbNode.title,
    hasChildren : lgbNode.hasChildren,
    id :lgbNode.idx,
    focusEvent : lgbNode.focusEvent
  };
  
  
  if (this.propertyName_ != null) {
    knode.checked = lgbNode[this.propertyName_];
  }
  
  return knode;
  
};

lgb.component.TreeDataSourceH.prototype.makeKendoNodes_ = function(lgbNode, parentKendoNode) {
  
  //convert node
  var knode = this.makeOneKendoNode_(lgbNode);
  
  //add to parent
  if (parentKendoNode) {
    if(undefined == parentKendoNode.items) {
      parentKendoNode.items = [knode];
    } else {
      parentKendoNode.items.push(knode);
    }
  }
  
  if (knode.hasChildren) {
    this.each(lgbNode.children, this.makeKendoNodes_, knode);
  }
  
  return knode;
};

  
lgb.component.TreeDataSourceH.prototype.bind_ = function() {
  
  this.kendoDS.bind("change", this.d(this.onChangeDS_));
  
};



lgb.component.TreeDataSourceH.prototype.onChangeDS_ = function(event) {

  if (event.field == "checked") {

    this.changedItems_ = [];
    this.view_ = this.kendoDS.view();
    
    event.items.forEach(this.d(this.processOneItem));
    
    if (this.changedItems_.length > 0) {
      this.dispatchChangedEx('changedItems', this.changedItems_);
    }

  }

};

lgb.component.TreeDataSourceH.prototype.processOneItem = function(node, idx, that) {


  if (node.id > -1) {
    
    var statusItem = {
      id : node.id,
      newValue : node.checked,
      text : node.text
    };
  
    this.changedItems_.push(statusItem);
    
  }

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

/**
 * @author Raj Dye - raj@rajdye.com
 */

goog.provide('lgb.component.TreeH');

goog.require('lgb.world.view.BaseV');
goog.require('lgb.component.TreeDataSourceH');

/**
 * Html component that contains a cusmtom TreeH
 * @param {string} parentHtmlID The CSS id of the parent.
 * @param {string} subID The second  part fo the CSS id.
 * @param {string} title Ysed for the label of the component.
 * @constructor
 * @extends {lgb.BaseV}
 */
lgb.component.TreeH = function(ds) {

  lgb.world.view.BaseV.call(this);

  lgb.assert(ds);
  this.ds = ds;

  this.nodeStatusList_ = [];
  
};
goog.inherits(lgb.component.TreeH, lgb.world.view.BaseV);

lgb.component.TreeH.prototype.bind_ = function() {

  this.kendoTreeView_.bind("select", this.d(this.onSelect_));

  if (true == this.ds.options.events.mouseOver ) {
    this.kendoTreeView_.wrapper.on("mouseenter.kendoTreeView", ".k-in", this.d(this.onMouseEnter_));
    this.kendoTreeView_.wrapper.on("mouseleave.kendoTreeView", ".k-in", this.d(this.onMouseLeave_));
  }

};


lgb.component.TreeH.prototype.onChange_showKNode_ = function(knode) {

  var uid = event.node.dataset.uid;
  this.ds.select(uid);

};


lgb.component.TreeH.prototype.onSelect_ = function(event) {

  var uid = event.node.dataset.uid;
  this.ds.select(uid);

};

lgb.component.TreeH.prototype.onMouseEnter_ = function(event) {

  var liElement = event.currentTarget.parentElement.parentElement;
  var dataItem = this.kendoTreeView_.dataItem(liElement);

  if (dataItem.focusEvent) {
    this.ds.setFocus(dataItem.uid);
  }

};

lgb.component.TreeH.prototype.onMouseLeave_ = function(event) {

  var liElement = event.currentTarget.parentElement.parentElement;
  var dataItem = this.kendoTreeView_.dataItem(liElement);

  if (dataItem.focusEvent) {
    this.ds.removeFocus(dataItem.uid);
  }
};




lgb.component.TreeH.prototype.getHtml = function() {

  var el = $('<div>');
  this.setMainElement(el);

  var options = {
    expanded : true,
    loadOnDemand : false,
    dataSource : this.ds.kendoDS
  };

  if (this.ds.propertyName_ != null) {
    options.checkboxes = {
      checkChildren : true
    };
  }

  this.kendoTreeView_ = el.kendoTreeView(options).data("kendoTreeView");

  this.bind_();

  return el;
};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.vo.VisibilityNode');

goog.require('lgb.world.model.vo.BaseVo');

lgb.world.model.vo.VisibilityNode = function(title, object3d, recurseDepth) {
  

  this.idx = lgb.world.model.vo.VisibilityNode.idx++;
  lgb.world.model.vo.VisibilityNode.allNodes[this.idx] = this;
  
  this.title = title;
  recurseDepth = recurseDepth || 0;
  this.children = undefined;
  this.hasChildren = false;
  this.parent = undefined;
  this.children = [];
  this.focusEvent = false;
  
  if (object3d && object3d instanceof THREE.Object3D) {
    this.init_(object3d,recurseDepth);
  } else if (object3d && object3d instanceof Array) {
    this.initArray_(object3d, recurseDepth);
  }

};
goog.inherits(lgb.world.model.vo.VisibilityNode, lgb.world.model.vo.BaseVo);


lgb.world.model.vo.VisibilityNode.prototype.initArray_ = function(ary, recurseDepth) {
    
    this.hasChildren = true;
    this.each(ary, this.initOneChild_, recurseDepth); 
};


lgb.world.model.vo.VisibilityNode.prototype.init_ = function(object3d, recurseDepth) {
  
    this.object3d = object3d;
    this.isVisible = object3d.visible;

    if (object3d.children.length > 0 && recurseDepth > 0) {
      this.hasChildren = true;

      
      this.each(object3d.children, this.initOneChild_, recurseDepth);
    }
    
    return;
    
};

lgb.world.model.vo.VisibilityNode.prototype.isRoot = function() {
  return (undefined == this.parent);
};




lgb.world.model.vo.VisibilityNode.prototype.initOneChild_ = function(object3dChild, recurseDepth) {
  
    var childNode = new lgb.world.model.vo.VisibilityNode(object3dChild.name, object3dChild, recurseDepth-1);
    
    childNode.parent = this;
    this.children.push(childNode);
};



lgb.world.model.vo.VisibilityNode.prototype.setVisible = function(isVisible) {
  
  if (this.isVisible != isVisible) {
    
    this.isVisible = isVisible;
    
    if(this.object3d) {
      var includeDecendants = !this.hasChildren;
      this.object3d.setProperty( 'visible', isVisible, includeDecendants);
    }

  }

};


lgb.world.model.vo.VisibilityNode.prototype.add = function(childNode) {
  
    if (! this.hasChildren ) {
      this.hasChildren = true;
      this.children = [];
    }
    
    childNode.parent = this;
    this.children.push(childNode);
};



lgb.world.model.vo.VisibilityNode.getNodeByIdx = function(idx) {
  
  var theNode = null;
  var allNodes = lgb.world.model.vo.VisibilityNode.allNodes;
  
  if(allNodes && allNodes.length > idx ) {
    theNode = allNodes[idx];
  }
  
  return theNode;
};



lgb.world.model.vo.VisibilityNode.idx = 0;
lgb.world.model.vo.VisibilityNode.allNodes = [];
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.VisibilityModel');

goog.require('lgb.world.model.BaseModel');
goog.require('lgb.world.model.vo.VisibilityNode');



lgb.world.model.VisibilityModel = function() {
  this.init_();

};
goog.inherits(lgb.world.model.VisibilityModel, lgb.world.model.BaseModel);



lgb.world.model.VisibilityModel.prototype.init_ = function() {
  this.nodeList_= [];
};
 
 
 
lgb.world.model.VisibilityModel.prototype.addNode = function(visibilityNode) {
 
  this.nodeList_.push(visibilityNode);
  
  if (this.nodeList_.length == 1) {
    this.dispatchChangedEx('init', visibilityNode);
  } else {
    this.dispatchChangedEx('addNode', visibilityNode);
  }

};


lgb.world.model.VisibilityModel.prototype.changeVisibility = function(changeRequestAry) {
  
    var changeRequest = changeRequestAry[0];
    var visibilityNode = lgb.world.model.vo.VisibilityNode.getNodeByIdx(changeRequest.id);
         
     if (visibilityNode) {
       visibilityNode.setVisible(changeRequest.newValue);
     } else {
       debugger;
     }
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.input.VisibilityGUI');

goog.require('lgb.world.model.VisibilityModel');
goog.require('lgb.gui.view.BaseGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TreeH');
goog.require('lgb.component.TreeDataSourceH');
goog.require('lgb.core.Config');

/**
 * @constructor
 * @param {lgb.world.model.VisibilityModel} dataModel The data model to display.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.world.view.input.VisibilityGUI = function(dataModel) {

  this._TITLE = "Visibility";
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
  this.listenForChange_('addNode');
  this.listenForChange_('init');
  this.listenForChange_('changedItems');
  
  
};
goog.inherits(lgb.world.view.input.VisibilityGUI, lgb.gui.view.BaseGUI);



lgb.world.view.input.VisibilityGUI.prototype.onChange_addNode_ = function(visibilityNode) {
    this.treeDS_.update(visibilityNode);
};

lgb.world.view.input.VisibilityGUI.prototype.onChange_init_ = function(visibilityNode) {
  this.init_(visibilityNode);
};

lgb.world.view.input.VisibilityGUI.prototype.onChange_changedItems_ = function(changedItems) {
  this.requestDataModelChange("changedItems", changedItems);
};


/**
 * Initializes the View
 */

lgb.world.view.input.VisibilityGUI.prototype.init_ = function(visibilityNode) {
  
  this.treeDS_ = new lgb.component.TreeDataSourceH(visibilityNode,'isVisible',this.htmlID,  'tree', 'Visibility');

  this.treeDS_.setOptions (
    {
      events : {mouseOver:false}
    }
  );
  
  this.listenTo(
    this.treeDS_,
    e.DataModelChangedEx,
    this.onTreeDS_DataModelChangedEx_);
    
    
  this.treeComponent_ = new lgb.component.TreeH(this.treeDS_);
  
  var treeElement = this.treeComponent_.getHtml();
  this.append(treeElement);
  

   
};



lgb.world.view.input.VisibilityGUI.prototype.onTreeDS_DataModelChangedEx_ = function(event) {
 
   this.requestDataModelChange("changeVisibility", event.payload.changedItems);
};


lgb.world.view.input.VisibilityGUI.prototype.onChangeDataSource_ = function(event) {
    this.triggerLocal(e.RequestDataModelChange, event.payload);
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.controller.VisibilityController');

goog.require('lgb.core.BaseController');


goog.require('lgb.world.view.input.VisibilityGUI');
goog.require('lgb.world.model.VisibilityModel');




/**
 * MVC controller for the VisibilityController
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.VisibilityController = function() {

  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.world.controller.VisibilityController, lgb.core.BaseController);



/**
 * initializes the controller
 * @private
 */
lgb.world.controller.VisibilityController.prototype.init = function() {

  this.dataModel = new lgb.world.model.VisibilityModel();
  this.guiView = new lgb.world.view.input.VisibilityGUI ( this.dataModel );

  this.bind_();

  this.trigger(e.RequestAddToTestingInput, this.guiView);
};


lgb.world.controller.VisibilityController.prototype.getGui = function() {
  
  return this.guiView;
  
};



/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.VisibilityController.prototype.bind_ = function() {


  this.listen(
    e.VisibilityNodesLoaded,
    this.onVisibilityNodesLoaded_
   );
    
  this.listenTo(
    this.guiView,
    e.RequestDataModelChange,
    this.onRequestDataModelChange_
   );


};




lgb.world.controller.VisibilityController.prototype.onVisibilityNodesLoaded_ =
  function(event) {

  this.dataModel.addNode(event.payload);
  
};




lgb.world.controller.VisibilityController.prototype.onRequestDataModelChange_ =
  function(event) {

  var changeRequest = event.payload;

  if ("changeVisibility" == changeRequest.property) {
    
     this.dataModel.changeVisibility(changeRequest.newValue);
  
  } else {
    debugger;
  }
  


  
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.model.TopMenuModel');

goog.require('lgb.world.model.BaseModel');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.gui.model.TopMenuModel = function() {

  this._TITLE = 'TopMenu';
  this.init_();

  this.viewTitleToEnabledMap_ = {};
  this.viewTitleToIdxMap_ = {};
  this.viewTitleToGuiMap_ = {};
  
};
goog.inherits(lgb.gui.model.TopMenuModel, lgb.world.model.BaseModel);


/**
 * Sets default properties.
 * @private
 */
lgb.gui.model.TopMenuModel.prototype.init_ = function() {

  this.viewItems_ = [];
                   
 
  this.ds =
      [
          {
              text: "Profiles",
              items: []
          },
          
          {
             text: "View",
             encoded: false,
             items: this.viewItems_
          }
      ];

     
};




lgb.gui.model.TopMenuModel.prototype.getGuiView = function(title) {
  
    var guiView = this.viewTitleToGuiMap_[title];
    
    return guiView;
    
};

lgb.gui.model.TopMenuModel.prototype.toggleCheck = function(title) {
    

    
    this.viewTitleToEnabledMap_[title] = !this.viewTitleToEnabledMap_[title];
    
    var isCheckeded = this.viewTitleToEnabledMap_[title];
    var idx = this.viewTitleToIdxMap_[title];
    

    
    if (isCheckeded) {
      this.viewItems_[idx].imageUrl = "images/check.png";
    } else {
      this.viewItems_[idx].imageUrl = null;
    }
    
    this.dispatchChangedEx('ds', this.ds);
    

};


lgb.gui.model.TopMenuModel.prototype.add = function(guiView) {
    
  var title = guiView.getTitle();
  
  
  
  if (title != 'TopMenu') {
    
    
    if ( this.viewTitleToEnabledMap_.hasOwnProperty(title) ) {
      
      debugger;
  
    } else {
      
      this.viewTitleToEnabledMap_[title] = true;
      
      this.viewItems_.push({ 
        text: '' + title,
        imageUrl: "images/check.png"
      });
      
      this.viewTitleToIdxMap_[title] = this.viewItems_.length - 1;
      this.viewTitleToGuiMap_[title] = guiView;
      
    }
    
    this.dispatchChangedEx('ds', this.ds);
  }

};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.TopMenuGUI');


goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.core.Config');



lgb.gui.view.TopMenuGUI = function(dataModel) {

  this._TITLE = "TopMenu";
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
  this.listenForChange_('ds');

};
goog.inherits(lgb.gui.view.TopMenuGUI, lgb.gui.view.BaseGUI);




lgb.gui.view.TopMenuGUI.prototype.onChange_ds_ = function(ds) {
 
  this.kendoMenu_.setOptions(
    {
      dataSource:ds
    }
  );
  
};



/**
 * Initializes the View
 */
lgb.gui.view.TopMenuGUI.prototype.init = function() {


  var el = this.getMainElement();
  
  this.kendoMenu_ =        
      el.kendoMenu().data("kendoMenu");
        
  
  this.kendoMenu_.setOptions(
    {
      dataSource:this.dataModel.ds
    }
  );
  
  
  this.bind_();
  

  
};


lgb.gui.view.TopMenuGUI.prototype.bind_ = function() {
  
    this.kendoMenu_.bind('select', this.d(this.onSelect_));
  
};



lgb.gui.view.TopMenuGUI.prototype.onSelect_ = function(event) {
  

    var item = event.item;
    var title = item.textContent;

    //var i = item.attributes.item();
    
        
   if (title != "TopMenu" &&
       title != "Profiles"
    ) {
   
      var guiView = this.dataModel.getGuiView(title);
      
      if(guiView == null) {
        return;
      }

      
      this.dataModel.toggleCheck(title);
      this.triggerLocal(e.RequestLayoutVisibilityChange, guiView);
     
   }

  
};





goog.provide('lgb.gui.controller.TopMenuController');

goog.require('lgb.core.BaseController');

goog.require('lgb.gui.model.TopMenuModel');
goog.require('lgb.gui.view.TopMenuGUI');


lgb.gui.controller.TopMenuController = function() {

  lgb.core.BaseController.call(this);

};
goog.inherits(lgb.gui.controller.TopMenuController, lgb.core.BaseController);

/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.TopMenuController.prototype.init = function() {

  this.dataModel = new lgb.gui.model.TopMenuModel();
  this.guiView = new lgb.gui.view.TopMenuGUI(this.dataModel);
  
  this.bind_();
  
  this.guiView.init();
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);


};

lgb.gui.controller.TopMenuController.prototype.bind_ = function() {


  this.relay (this.guiView, e.RequestLayoutVisibilityChange );
  
  //this.relay(this.guiView, e.RequestAddToLayout );
  //this.relayLocal(this.guiView, e.RequestAddToParentGUI );
  
  this.listen(e.RequestAddToLayout, this.onRequestAddToLayout_);
};



lgb.gui.controller.TopMenuController.prototype.onRequestAddToLayout_ = function(event) {
  
    this.dataModel.add(event.payload);
    
};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.LayoutUtil');

goog.require('lgb.gui.view.BaseGUI');



lgb.gui.view.LayoutUtil = function(guiView) {
  
  this.guiView_ = guiView;
  this.element_ = guiView.getMainElement();

  lgb.core.BaseController.call(this);

};
goog.inherits(lgb.gui.view.LayoutUtil, lgb.gui.view.BaseGUI);



lgb.gui.view.LayoutUtil.prototype.init = function() {


};


lgb.gui.view.LayoutUtil.prototype.alignHorizontal = function(alignTo, offset) {
  
  this.alignHorizontal_ = alignTo;
  this.offsetHorizontal_ = offset;

};


/**
 * show the button.
 */
lgb.gui.view.LayoutUtil.prototype.show = function() {
  this.jumpToPosition();
};

/**
 * Set the position.
 */
lgb.gui.view.LayoutUtil.prototype.jumpToPosition = function() {

  var x = this.getXpos_();

  var props = {left: x + 'px'};
    this.element_.css(props);

};



lgb.gui.view.LayoutUtil.prototype.tweenToPosition = function(event) {

    var x = this.getXpos_();

    var options = {
      duration: 500,
      easing: 'easeInOutSine'
  };
  
  var props = {left: x + 'px'};

  this.element_.animate(
      props,
      options
  );
};


/**
 * Get the Xposition for the button.
 * @return {number} The X.
 */
lgb.gui.view.LayoutUtil.prototype.getXpos_ = function() {

  if (this.alignHorizontal_ == lgb.gui.view.LayoutUtil.ALIGN.Right) {
    
    var parentWidth = this.guiView_.getParentElement().width();
    var selfWidth = this.guiView_.getMainElement().width();
    
    x = parentWidth - this.offsetHorizontal_ - selfWidth;
  
  } else if (this.alignHorizontal_ == lgb.gui.view.LayoutUtil.ALIGN.Left) {
    x = this.offsetHorizontal_;
  }

    
  return x;

};


lgb.gui.view.LayoutUtil.ALIGN = function() {};

lgb.gui.view.LayoutUtil.ALIGN.Right = 0;
lgb.gui.view.LayoutUtil.ALIGN.Left = 1;
lgb.gui.view.LayoutUtil.ALIGN.Top = 2;
lgb.gui.view.LayoutUtil.ALIGN.Bottom = 3;
lgb.gui.view.LayoutUtil.ALIGN.Center = 4;
lgb.gui.view.LayoutUtil.ALIGN.None = 5;


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 	 
 	 /**
 * @author Raj Dye - raj@rajdye.com
*/

goog.provide('lgb.component.SplitPanel');
goog.require('lgb.world.view.BaseV');


/**
 * Html component that contains a cusmtom SplitPanel
 * @param {string} parentHtmlID The CSS id of the parent.
 * @param {string} subID The second  part fo the CSS id.
 * @param {string} title Ysed for the label of the component.
 * @constructor
 * @extends {lgb.BaseV}
 */
lgb.component.SplitPanel = function(ds) {
    
  lgb.world.view.BaseV.call(this);
  
  lgb.assert (ds);
  this.ds = ds;
  this.panes_ = [];
  
  this.splitterBarContainerCss = {
    width : "100%",
    height : "100%",
    overflow:"hidden",
    "background":"transparent"
  };
  
  
  this.paneOneCss = 
  {
    position : "fixed !important",
    position : "absolute",
    top : "0",
    right : "0",
    bottom : "0",
    left : "0",
    
    "overflow-y":"scroll",
    "overflow-x":"hidden"
  };
  
  this.paneTwoCss = 
  {

  };
  
  
  
};
goog.inherits(lgb.component.SplitPanel, lgb.world.view.BaseV);






lgb.component.SplitPanel.prototype.makeElement = function() {


};


lgb.component.SplitPanel.prototype.getPane = function(idx) {
  
  return this.panes_[idx];
};




lgb.component.SplitPanel.prototype.getContainer = function(idx) {
  
  return this.splitterBarContainer_;
};


lgb.component.SplitPanel.prototype.onResize_ = function(event) {
  
  return this.triggerLocal(e.Resize);
  
};


lgb.component.SplitPanel.prototype.injectInto = function(parentElement) {


  
  this.paneOne_ = this.makeDiv();
  this.paneTwo_ = this.makeDiv();
  
  this.panes_.push(this.paneOne_);
  this.panes_.push(this.paneTwo_);
  
  this.splitterBarContainer_ = this.makeDiv();
  
  this.splitterBarContainer_.css(this.splitterBarContainerCss);
  this.paneOne_.css(this.paneOneCss);
  this.paneTwo_.css(this.paneTwoCss);
  
  
  
  
  this.splitterBarContainer_.append(this.paneOne_).append(this.paneTwo_);
  this.setMainElement(this.splitterBarContainer_);
  
  goog.base(this, 'injectInto', parentElement);
  
  var theOptions = {panes :  this.ds.panes};


  if (this.ds.splitsAlongHorizontalAxis) {
    theOptions.orientation = 'horizontal';
  } else {
    theOptions.orientation = 'vertical';
  }
  
  this.splitterBarContainer_.kendoSplitter(theOptions);
  
  this.kendoSplitter_ = this.splitterBarContainer_.data("kendoSplitter");
  this.kendoSplitter_.bind('resize', this.d(this.onResize_));
  
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 	 
 	 /**
 * @author Raj Dye - raj@rajdye.com
*/

goog.provide('lgb.component.SplitPanelDataSource');

goog.require('lgb.world.view.BaseV');
goog.require('lgb.component.BaseDataSource');

/**
 * Html component that contains a cusmtom SplitPanel
 * @param {string} parentHtmlID The CSS id of the parent.
 * @param {string} subID The second  part fo the CSS id.
 * @param {string} title Ysed for the label of the component.
 * @constructor
 * @extends {lgb.BaseV}
 */
lgb.component.SplitPanelDataSource = function() {
    
  lgb.component.BaseDataSource.call(this);

  
  this.pane1 = {
    size:'250px'
  };
  
  
};
goog.inherits(lgb.component.SplitPanelDataSource, lgb.component.BaseDataSource);






lgb.component.SplitPanelDataSource.prototype.makeElement = function() {


};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.model.LayoutModel');

goog.require('lgb.world.model.BaseModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.gui.model.LayoutModel = function() {

  /**@const */
  this._TITLE = 'LayoutModel';

  lgb.world.model.BaseModel.call(this);

};
goog.inherits(lgb.gui.model.LayoutModel, lgb.world.model.BaseModel);


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.gui.view.LayoutView');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.SplitPanel');
goog.require('lgb.component.SplitPanelDataSource');
goog.require('lgb.gui.view.LayoutUtil');
goog.require('lgb.core.Config');
goog.require('lgb.gui.model.LayoutModel');




/**
 * @constructor
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.LayoutView = function(dataModel) {

  lgb.gui.view.BaseGUI.call(this, dataModel, 'pageContainer', 'theBody');
  this.layoutUtils_ = [];
  
};
goog.inherits(lgb.gui.view.LayoutView, lgb.gui.view.BaseGUI);



lgb.gui.view.LayoutView.prototype.init = function() {

  this.splitPanelHorizontalDS_ = new lgb.component.SplitPanelDataSource();
  
  this.splitPanelHorizontalDS_.panes =  [{
      collapsible : true,
      size:"340px"
    }, {
      collapsible : false
    }];
    
  this.splitPanelHorizontalDS_.splitsAlongHorizontalAxis = true;
  this.splitPanelHorizontal_ = new lgb.component.SplitPanel(this.splitPanelHorizontalDS_);
  
  this.splitPanelHorizontal_.paneOneCss["overflow-y"] = "hidden";
  this.splitPanelHorizontal_.paneOneCss["height"] = "100%";
  
  
  this.splitPanelVerticalDS_ = new lgb.component.SplitPanelDataSource();

  this.splitPanelVerticalDS_.panes =  [{
      collapsible : false
    }, {
      size:"400px",
      collapsible : true
    }];
    
    
  this.splitPanelVerticalDS_.splitsAlongHorizontalAxis = false;
  this.splitPanelVertical_ = new lgb.component.SplitPanel(this.splitPanelVerticalDS_);
  
  this.splitPanelVertical_.paneOneCss["overflow-y"] = "hidden";
  
  this.splitPanelVertical_.paneTwoCss["overflow-y"] = "hidden";
  this.splitPanelVertical_.paneTwoCss["overflow-x"] = "hidden";
  
  this.bind_();
  this.inject();
};


lgb.gui.view.LayoutView.prototype.bind_ = function(guiView) {
  
  this.listenTo(this.splitPanelHorizontal_, e.Resize, this.onSplitterResizeHorizontal_);
  this.listenTo(this.splitPanelVertical_, e.Resize, this.onSplitterResizeVertical_);
  
};




lgb.gui.view.LayoutView.prototype.toggleVisibility = function(guiView) {
  
  guiView.isVisible_ = !guiView.isVisible_;
  var el = guiView.getMainElement();
  
  el.toggle();

};



lgb.gui.view.LayoutView.prototype.add = function(guiView) {
  

  var className = guiView.getClassName();

  switch(className ) {
    
   
    case "ButtonsTopRightHUD":
      guiView.injectInto(this.viewportTop_);
      break;

    case "LeftPanelSimpleGUI":
      guiView.injectInto(this.leftPanel_);
      break;

    case "TestGUI":
      guiView.injectInto(this.leftPanel_);
      break;
    case "BottomPanelGUI":
      var util = new lgb.gui.view.LayoutUtil(guiView);
      
      guiView.injectInto(this.bottomRightPanel_);
      break;

    default:
      debugger;
  }


  
};




lgb.gui.view.LayoutView.prototype.onSplitterResizeVertical_ = function(event) {
  this.triggerLocal(e.LayoutChange);
};


lgb.gui.view.LayoutView.prototype.onSplitterResizeHorizontal_ = function(event) {
  this.triggerLocal(e.LayoutChange);
};

lgb.gui.view.LayoutView.prototype.calculateLayout = function(windowDimensions) {
  
  //this.splitPanelHorizontal_.calculateLayout();
  
  this.each(this.layoutUtils_, this.calculateOneLayout);
};

lgb.gui.view.LayoutView.prototype.calculateOneLayout = function(layoutUtil) {
  layoutUtil.tweenToPosition();
};


lgb.gui.view.LayoutView.prototype.inject = function() {

  goog.base(this,'inject');

  this.splitPanelHorizontal_.injectInto(this.getMainElement());
  this.leftPanel_ = this.splitPanelHorizontal_.getPane(0);
  this.rightPanel_ = this.splitPanelHorizontal_.getPane(1);

  this.splitPanelVertical_.injectInto(this.rightPanel_);
  this.topRightPanel_ = this.splitPanelVertical_.getPane(0);
  this.bottomRightPanel_ = this.splitPanelVertical_.getPane(1);

  this.webGLcontainer_ = this.makeDiv(lgb.core.Config.WEBGL_CONTAINER_DIV_ID);
  
  this.viewportTop_ = this.makeDiv('viewportTop');
  
  this.topRightPanel_.append(this.viewportTop_);
  this.topRightPanel_.append(this.webGLcontainer_);

  this.webGLcontainer_.css({
    width : "100%",
    height : "95%"
  });
  

  this.viewportTop_.css({
    width : "100%",
    height : "64px",
    background:"transparent"
  });
  


};





/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.ButtonsTopRightHUD');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.core.Config');
goog.require('lgb.component.TabStripDataSource');
goog.require('lgb.component.TabStrip');


/**
 * @constructor
 * @param {lgb.world.model.ViewpointModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.ButtonsTopRightHUD = function(dataModel) {
  
  this._TITLE = "RightTop";
  lgb.gui.view.BaseGUI.call(this, dataModel, 'RightTopInputGUI');
};
goog.inherits(lgb.gui.view.ButtonsTopRightHUD, lgb.gui.view.BaseGUI);


/**
 * Initializes the View
 */
lgb.gui.view.ButtonsTopRightHUD.prototype.init = function() {
  
  // this.dataSource1 = new lgb.component.TabStripDataSource('RightTopInputGUI-tabStrip');
  // this.dataSource1.setIcon("images/tabs/optionsBtn_grid_25.png", 25, 25);
  // this.dataSource1.addTab('', '', 1);
  // this.dataSource1.addTab('', '', 2);
  // this.dataSource1.addTab('', '', 3);
  // this.dataSource1.addTab('', '', 4);
  // this.dataSource1.addTab('', '', 5);
//   
  // this.tabStrip1 = new lgb.component.TabStrip(this.dataSource1);
//   
// 
  // this.dataSource2 = new lgb.component.TabStripDataSource('RightTopInputGUI2-tabStrip');
  // this.dataSource2.setIcon("images/tabs/viewBtn_grid_25.png", 25, 25);
  // this.dataSource2.addTab('', '', 1);
  // this.dataSource2.addTab('', '', 2);
  // this.dataSource2.addTab('', '', 3);
  // this.dataSource2.addTab('', '', 4);
  // this.dataSource2.addTab('', '', 5);
//   
  // this.tabStrip2 = new lgb.component.TabStrip(this.dataSource2);
  
  
};


lgb.gui.view.ButtonsTopRightHUD.prototype.add = function(gui) {


  var title = gui.getTitle();

  var el = this.getMainElement();;
  
  gui.injectInto(el);
  
};





lgb.gui.view.ButtonsTopRightHUD.prototype.injectInto = function(parentElement) {
  
  goog.base(this,  'injectInto', parentElement);
  
  // this.tabStrip1.injectInto(parentElement);
  // this.tabStrip1.injectCss();
//   
  // this.tabStrip2.injectInto(parentElement);
  // this.tabStrip2.injectCss();

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.controller.ButtonsTopRightHUDController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.model.BaseGuiModel');
goog.require('lgb.gui.view.ButtonsTopRightHUD');

/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.ButtonsTopRightHUDController = function( ) {

  lgb.core.BaseController.call(this);
  
};
goog.inherits(lgb.gui.controller.ButtonsTopRightHUDController, lgb.core.BaseController);


/**
 * Initialized the controller.
 */
lgb.gui.controller.ButtonsTopRightHUDController.prototype.init = function() {
  
  this.dataModel = new lgb.gui.model.BaseGuiModel();
  this.guiView = new lgb.gui.view.ButtonsTopRightHUD (this.dataModel);

  this.guiView.init();
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  
  this.bind_();
  
};




lgb.gui.controller.ButtonsTopRightHUDController.prototype.bind_ = function() {


  this.listenOnce (
      e.SimulationEngineLoaded,
      this.onSimulationEngineLoaded_
  );
    

};


lgb.gui.controller.ButtonsTopRightHUDController.prototype.onSimulationEngineLoaded_ = function(event) {

  var simulationMainController = event.payload;
  this.init3_(simulationMainController);
  
};


lgb.gui.controller.ButtonsTopRightHUDController.prototype.init3_ = function(simulationMainController) {
  
  this.makeChildGUIcontroller_(lgb.gui.controller.SimulationStateController, simulationMainController);

};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.TitleBarGUI');
goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.core.Config');


/**
 * @constructor
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.TitleBarGUI = function() {
    
    
  this._TITLE='TitleBar';
  lgb.gui.view.BaseGUI.call(this);
  
  this.init_();

};
goog.inherits(lgb.gui.view.TitleBarGUI, lgb.gui.view.BaseGUI);



lgb.gui.view.TitleBarGUI.prototype.init_ = function() {
    
    var el = this.getMainElement();
    
    el.css({
        top: '0px',
        width: '237px',
        height: '69px',
        'z-index': '101',
        'background-image': 'url(images/top_title2.png)'
      })
    .center({
      vertical: false
    });
    
    
    this.isVisible_ = true;
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.component.TabStripDataSourceH');
goog.require('lgb.component.BaseDataSource');

/**
 * @constructor
 * @extends lgb.component.BaseDataSource
 * @param {string} title The HTML title in the Link.
 * @param {string} parentHtmlID The CSS ID of the parent in the DOM.
 * @param {string} subID The second part of the CSS ID for this element.
 */
lgb.component.TabStripDataSourceH = function(title, htmlID, parentHtmlID) {

  lgb.component.BaseDataSource.call(this);
  this.offsets = [];
  this.title = title;
  
  if (undefined == title || '' == title) {
    debugger;
  }
  
  
  this.parentHtmlID = parentHtmlID;
  
  if (undefined === htmlID) {
    this.htmlID = title;
    //debugger;
  } else {
    this.htmlID = htmlID;
  }
  


  this.isEnabled = true;

  this.showIcon = false;
  this.tabCollection = [];

};
goog.inherits(lgb.component.TabStripDataSourceH, lgb.component.BaseDataSource);

lgb.component.TabStripDataSourceH.prototype.setIcon = function(imageUrl, iconHeight, iconWidth) {

  this.imageUrl = imageUrl;
  this.iconHeight = iconHeight;
  this.iconWidth = iconWidth;
  this.showIcon = true;

};



lgb.component.TabStripDataSourceH.prototype.setOffsets = function(offsets) {
  this.offsets = offsets;
};


lgb.component.TabStripDataSourceH.prototype.getTabCount = function() {
  return this.tabCollection.length;
};


lgb.component.TabStripDataSourceH.prototype.removeAllTabs = function() {
  
  this.tabCollection = [];
  
  if (this.kendoDS) {
    var data = this.kendoDS.data();
    
    var len = data.length;
    
    for (var i=0; i < len; i++) {
      var dataItem = data.pop();
      this.kendoDS.remove(dataItem);
    };
    
    
  }
  
};



lgb.component.TabStripDataSourceH.prototype.addTab = function(title, content, yPosition) {

  //if (undefined == title || '' == title) {
   // debugger;
 // }
 
 
  if (null == yPosition) { 
    yPosition = this.tabCollection.length + 1;
  };

  if (null == content) { 
    content = '<span></span>';
  };


  var cssClassName = 'tab' + (yPosition);

  var tab = {
    title : title,
    content : content,
    cssClass : cssClassName,
    yPosition : yPosition
  };

  this.tabCollection.push(tab);
  
  if (this.kendoDS) {
    this.kendoDS.add(tab);
  }
  
  this.dispatchChangedEx('addTab', tab);
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.component.TabStripH');
goog.require('lgb.component.TabStripDataSourceH');
goog.require('lgb.world.view.BaseV');


/**
 * Html radio button group that will be inserted into the DOM
 * @constructor
 * @extends {lgb.world.view.BaseV}
 * @param {lgb.component.TabStripHDataSource} ds the datasource
 * for this component.
 */
lgb.component.TabStripH = function(ds) {

  lgb.world.view.BaseV.call(this, ds, ds.htmlID, ds.parentHtmlID);
  this.ds = ds;
  
  this.listenForChange_('addTab');
};
goog.inherits(lgb.component.TabStripH, lgb.world.view.BaseV);


lgb.component.TabStripH.prototype.onChange_addTab_ = function(tab) {
  

    if (this.ds.showIcon) {
      
      var idx = tab.yPosition-1;

      var cssInner = this.makeBackgroundPosition(' .' + tab.cssClass, 0, idx);
      cssInner += this.makeBackgroundPosition(' .k-state-hover .' + tab.cssClass, 1, idx);
      cssInner += this.makeBackgroundPosition(' .k-state-active .' + tab.cssClass, 2, idx);

      var cssStr = "<style type='text/css'>{0}</style>".format(cssInner);
      $(cssStr).appendTo('head');
      
      var children = this.kendoTabStrip_.tabGroup.children();
      if (idx < children.length) {
        
        var newChildTab = $(children[idx]);
        
        if (idx < this.ds.offsets.length) {
          var offset = this.ds.offsets[idx];
          
          newChildTab.css("margin-left", offset.x);
          newChildTab.css("margin-top", offset.y);

        }
        
      }
      
      
    }
    
};




lgb.component.TabStripH.prototype.select = function(idx) {
  this.kendoTabStrip_.select(idx);   
};

  
  
/**
 * @param {string} appendToSelector The second part of the
 * jQuery selector string.
 * @param {number} yPosition Used to calculate the pixel shift.
 * @return {string} the Css.
 */
lgb.component.TabStripH.prototype.makeBackgroundPosition = function(appendToSelector, xPosition, yPosition) {

  var pixelShiftY = this.ds.iconHeight * yPosition * -1;
  var pixelShiftX = this.ds.iconWidth * xPosition * -1;

  var cssStr = '#{0}{1}{background-position: {2}px {3}px;}'.format(this.htmlID, appendToSelector, pixelShiftX.toString(), pixelShiftY.toString());

  return cssStr;
};


lgb.component.TabStripH.prototype.setContentHeight = function(height) {
  
  var len = this.kendoTabStrip_.contentElements.length;
  
   for (var i = 0; i < len; i++) {
     var contentElement = $(this.kendoTabStrip_.contentElements[i]);
     contentElement.height(height);
   }
  
  return;
};


lgb.component.TabStripH.prototype.setContentCss = function(cssClass, cssValue) {
  
  var len = this.kendoTabStrip_.contentElements.length;
   for (var i = 0; i < len; i++) {
     
     var contentElement = $(this.kendoTabStrip_.contentElements[i]);
     contentElement.css(cssClass, cssValue);
     
   }

};


lgb.component.TabStripH.prototype.getContentElement = function() {
  
  var len = this.kendoTabStrip_.contentElements.length;
  var contentElement = this.kendoTabStrip_.contentElements[len - 1];
  
  return $(contentElement);
};


/*
lgb.component.TabStripH.prototype.setOptions = function(options) {

  this.options = options;

  if (this.options.width) {
    this.getMainElement().css('width', this.options.width);
  }

};
*/

lgb.component.TabStripH.prototype.bind_ = function() {

  this.kendoTabStrip_.bind('select', this.d(this.onSelect_));
  this.kendoTabStrip_.bind('activate', this.d(this.onActivate_));
  
};

lgb.component.TabStripH.prototype.onActivate_ = function(event) {
  
  var payload = event.item;
  
  //var item = $(payload.childNodes[0]);
  //item.css("border", "2px solid #231F20");
  
  this.triggerLocal(e.Activate, payload);
  
};

lgb.component.TabStripH.prototype.onSelect_ = function(event) {
  
  var payload = event.item;
  
  //var item = $(payload.childNodes[0]);
  //item.css("border", "2px solid #0294DD");
  
  //this.triggerLocal(e.MouseClick, payload);
  
};


lgb.component.TabStripH.prototype.injectCss = function() {

  if (this.ds.showIcon) {
    //inject background image for tab
    var cssInner = '#{0} .k-sprite '.format(this.ds.htmlID);
    cssInner += '{background-image: url("{0}");'.format(this.ds.imageUrl);
    cssInner += 'margin: 0px;';
    cssInner += 'width: {0}px;}'.format(this.ds.iconWidth);

    // //eliminate margin and padding
    // cssInner += '#{0} .k-TabStripH-items .k-link {margin:0px;padding:0px }'.format(this.ds.htmlID);
    // var len = this.ds.tabCollection.length;
// 
    // for (var i = 0; i < len; i++) {
      // var cssStr = '.tab' + (i + 1) + ' ';
// 
      // cssInner += this.makeBackgroundPosition(' ' + cssStr, i, 1);
      // cssInner += this.makeBackgroundPosition(' .k-state-active ' + cssStr, i, 0);
      // cssInner += this.makeBackgroundPosition(' .k-state-hover ' + cssStr, i, 2);
//       
      // cssInner += this.makeBackgroundPosition(' .k-state-selected .' + tab.cssClass, i, 4);
// 
// 
//       
    // };

    var cssStr = "<style type='text/css'>{0}</style>".format(cssInner);
    $(cssStr).appendTo('head');
  }

};



/**
 * @public
 */
lgb.component.TabStripH.prototype.injectInto = function(parentElement) {

  var el = this.getMainElement();

  this.kendoTabStrip_ = el.kendoTabStrip({
    dataTextField : "title",
    dataSpriteCssClass : "cssClass",
    dataContentField : "content",
    dataSource : this.ds.tabCollection
  }).data("kendoTabStrip");

  this.bind_();
  
  this.kendoTabStrip_.select(0);
  this.ds.kendoDS = this.kendoTabStrip_.dataSource;
  
  
  goog.base(this,'injectInto', parentElement);

};

goog.provide('lgb.gui.view.BuildingSimpleGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStripH');
goog.require('lgb.component.TabStripDataSourceH');

lgb.gui.view.BuildingSimpleGUI = function(dataModel) {

  this._TITLE = 'Building';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);


};
goog.inherits(lgb.gui.view.BuildingSimpleGUI, lgb.gui.view.BaseGUI);




lgb.gui.view.BuildingSimpleGUI.prototype.init = function() {
  
  this.tabTitleMap_ = {};
  
  this.dataSource = new lgb.component.TabStripDataSourceH('BuildingSimpleGUI-tabStrip');
  
  
  var path = lgb.core.Config.WEBROOT + "images/icons-building-all.png";
  
  this.dataSource.setIcon(path, 28, 30);
  
  this.dataSource.setOffsets([
    {x:76, y:0},
    {x:0, y:-18},
    {x:0, y:-12},
    {x:-2, y:15},
    {x:-30, y:50}
  ]);

  
  this.tabStrip_ = new lgb.component.TabStripH(this.dataSource);
  

  
}; 



lgb.gui.view.BuildingSimpleGUI.prototype.init2 = function() {
  this.tabStrip_.select(0);
  
};


lgb.gui.view.BuildingSimpleGUI.prototype.loadNew = function(dataModel) {
  this.dataModel = dataModel;
};


lgb.gui.view.BuildingSimpleGUI.prototype.clear = function() {
  
    this.tabTitleMap_ = {};
  
    this.dataSource.removeAllTabs();
    
    
};


lgb.gui.view.BuildingSimpleGUI.prototype.add = function(gui) {


  var title = gui.getTitle();

  if (undefined === title) {
    debugger;
  }

  var contentElement;
  
  if (this.tabTitleMap_[title]) {
    contentElement = this.tabTitleMap_[title];
  } else {
    this.dataSource.addTab('', ' ');
    
    contentElement = this.tabStrip_.getContentElement();
    contentElement.css("padding", "0 0 0 0");
    
    this.tabTitleMap_[title] = contentElement;
  }
  
  
  gui.injectInto(contentElement);
  
};


/**
 * @public
 */
lgb.gui.view.BuildingSimpleGUI.prototype.injectInto = function(parentElement) {
  
   var el = this.getMainElement();
   el.addClass("input-controls");
   
    
   this.tabStrip_.injectInto(el);
   this.tabStrip_.injectCss();
  
   var tabEl = this.tabStrip_.getMainElement();
   tabEl.addClass("building-icons");
   
   
   tabEl.css("padding","0 0 0 0");
   tabEl.css("background","transparent");
   tabEl.css("width","100%");
   tabEl.css("min-height","100%");
   
   
    var buildingLevelUl = $('<ul>')
    .addClass("building-level");
    
    var li1 = $('<li>')
    .append('<a href="#">Roof</a>');
    buildingLevelUl.append(li1);
    
    var li2 = $('<li>')
    .append('<a href="#">Floor</a>');
    buildingLevelUl.append(li2);
    
    
    var li3 = $('<li>')
    .append('<a href="#">Site</a>');
    buildingLevelUl.append(li3);
    
    
    
   this.append(buildingLevelUl);
   
   
    var miniMap = $('<div>')
    .addClass("mini-map");
    
    miniMap.append('<a href="#" class="mini-map-zone top-left"></a>');
    miniMap.append('<a href="#" class="mini-map-zone top-center"></a>');
    
    miniMap.append('<a href="#" class="mini-map-zone top-right"></a>');
    miniMap.append('<a href="#" class="mini-map-zone middle-left"></a>');
    
    miniMap.append('<a href="#" class="mini-map-zone middle-center"></a>');
    miniMap.append('<a href="#" class="mini-map-zone bottom-left"></a>');
    miniMap.append('<a href="#" class="mini-map-zone bottom-center"></a>');
    miniMap.append('<a href="#" class="mini-map-zone bottom-right"></a>');
    
   
   el.append(miniMap);
   
   parentElement.append(el);
    
    
    
    
    
    return;

    

  
  

};

goog.provide('lgb.gui.controller.BuildingSimpleController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.view.BuildingSimpleGUI');
goog.require('lgb.gui.model.BaseGuiModel');

goog.require('lgb.gui.controller.BuildingSubController');




lgb.gui.controller.BuildingSimpleController = function() {

  lgb.core.BaseController.call(this);
  this.subControllerList_ = [];
};
goog.inherits(lgb.gui.controller.BuildingSimpleController, lgb.core.BaseController);


/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.BuildingSimpleController.prototype.init = function(systemListDataModel) {

  this.dataModel = new lgb.gui.model.BaseGuiModel();
  this.guiView = new lgb.gui.view.BuildingSimpleGUI(this.dataModel);
  this.guiView.init();
    
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  this.systemListDataModel_ = systemListDataModel;
  
  var children = this.systemListDataModel_.getChildren();
  this.each (children, this.makeBuildingSubController_);
  
  this.guiView.init2();
    
};






lgb.gui.controller.BuildingSimpleController.prototype.loadNew = function(systemListDataModel) {


  // this.guiView.loadNew(systemListDataModel);
  this.guiView.clear();
  
  this.systemListDataModel_ = systemListDataModel;
  var children = this.systemListDataModel_.getChildren();
  this.eachIdx (children, this.updateBuildingSubController_);
  
  this.guiView.init2();
};


lgb.gui.controller.BuildingSimpleController.prototype.updateBuildingSubController_ = function(system, idx) {
  

  
  var controller = this.childGUIcontrollers_[idx];
  controller.init(system);
  
  // /controller.loadNew(system);
  
};

lgb.gui.controller.BuildingSimpleController.prototype.makeBuildingSubController_ = function(system) {

  this.makeChildGUIcontroller_(lgb.gui.controller.BuildingSubController, system);
  
};

goog.provide('lgb.gui.view.ScenarioMasterGUI');

goog.require('lgb.gui.view.BaseGUI');



lgb.gui.view.ScenarioMasterGUI = function(dataModel) {

  this._TITLE = 'ScenarioMasterGUI';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  
};
goog.inherits(lgb.gui.view.ScenarioMasterGUI, lgb.gui.view.BaseGUI);


/**
 * @public
 */
lgb.gui.view.ScenarioMasterGUI.prototype.init = function() {


  this.listenForChange_('selectedFileName');
  
};


lgb.gui.view.ScenarioMasterGUI.prototype.onChange_selectedFileName_ = function(selectedFileName) {
  
  
  this.triggerLocal(e.RequestLoadScenario, selectedFileName);

};



lgb.gui.view.ScenarioMasterGUI.prototype.add = function(gui) {

  var el = this.getMainElement();
  gui.appendTo(el);
  
};



lgb.gui.view.ScenarioMasterGUI.prototype.bind_ = function() {
  
  this.kendoDropDownList_.bind('select', this.d(this.onDropDownSelect_));

};


lgb.gui.view.ScenarioMasterGUI.prototype.onDropDownSelect_ = function(event) {
  
  var idx = event.item.index();
  var dataItem = this.kendoDropDownList_.dataItem(idx);
  var value = dataItem.value;
  
  this.dataModel.changePropertyEx('selectedFileName', value);
  
  
};




lgb.gui.view.ScenarioMasterGUI.prototype.showPopup_ = function(filename) {
  
    if (lgb.core.Config.SHOW_POPUPS) {
      
      var url = "info-pages/scenerios/{0}".format(filename);
      
      newwindow=window.open(url,'name','height=600,width=450');
      if (window.focus) {newwindow.focus()}
    
    }



};




/**
 * @public
 */
lgb.gui.view.ScenarioMasterGUI.prototype.injectInto = function(parentElement) {
  

   goog.base(this,  'injectInto', parentElement);
   
   var scenarios = this.dataModel.getScenarioList();
   
    var div = this.makeDiv();
        
     div
    .addClass('input-ListBox')
    .addClass('select')
    .append('<input>')
    .attr('value', '1');
    
    this.append(div);
    
    this.kendoDropDownList_ = 
      div.kendoDropDownList({
        dataSource: scenarios,
            dataTextField: 'name',
            dataValueField: 'value',
        change: this.d(this.onDropDownChange)
      }).data('kendoDropDownList');
      
     this.bind_();
     
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.model.ScenarioMasterModel');

goog.require('lgb.world.model.BaseModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.gui.model.ScenarioMasterModel = function() {

  /**@const */
  this._TITLE = 'ScenarioMasterModel';
  
  lgb.world.model.BaseModel.call(this);
  
  this.init_();
  

  
};
goog.inherits(lgb.gui.model.ScenarioMasterModel, lgb.world.model.BaseModel);



lgb.gui.model.ScenarioMasterModel.prototype.init_ = function() {
  
  this.scenarios_ = [

    {
      name:"Very Simple Scenario1",
      value:"VerySimpleScenario1"
    },
    {
      name:"Very Simple Scenario5",
      value:"VerySimpleScenario5"
    },
    {
      name:"Very Simple Scenario9",
      value:"VerySimpleScenario9"
    },
    {
      name:"Complete Scenario",
      value:"Complete"
    }
    ];
  
  
  
  this.selectedFileName = this.scenarios_[0].value;
  
};


lgb.gui.model.ScenarioMasterModel.prototype.getScenarioList = function() {


 
    return this.scenarios_;

};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.scenario.controller.ScenarioController');

goog.require('lgb.core.BaseController');
goog.require('lgb.scenario.model.ScenarioModel');


/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.scenario.controller.ScenarioController = function() {

  lgb.core.BaseController.call(this);
  this.init_();

};
goog.inherits(lgb.scenario.controller.ScenarioController, lgb.core.BaseController);


lgb.scenario.controller.ScenarioController.prototype.init_ = function() {
  

  this.dataModel = new lgb.scenario.model.ScenarioModel();

  this.listenTo(this.dataModel,
     e.DataModelInitialized,
      this.onDataModelInitialized_);

  this.bind_();
  
};


lgb.scenario.controller.ScenarioController.prototype.bind_ = function() {
  this.listen(e.RequestLoadScenario, this.onRequestLoadScenario_);
};



lgb.scenario.controller.ScenarioController.prototype.onRequestLoadScenario_ = function(event) {
  
  var fileName = event.payload;
  this.dataModel.load(fileName);
  
  
};


lgb.scenario.controller.ScenarioController.prototype.load = function(fileName) {
    this.dataModel.load(fileName);
};




lgb.scenario.controller.ScenarioController.prototype.onDataModelInitialized_ =
  function(event) {

  this.trigger(e.ScenarioDataModelLoaded, this.dataModel.systemList);
  
  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.controller.ScenarioMasterController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.model.ScenarioMasterModel');
goog.require('lgb.gui.view.ScenarioMasterGUI');
goog.require('lgb.scenario.controller.ScenarioController');

/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.ScenarioMasterController = function() {

  lgb.core.BaseController.call(this);


};
goog.inherits(lgb.gui.controller.ScenarioMasterController, lgb.core.BaseController);


lgb.gui.controller.ScenarioMasterController.prototype.init = function() {
  
  this.dataModel = new lgb.gui.model.ScenarioMasterModel();
  this.guiView = new lgb.gui.view.ScenarioMasterGUI(this.dataModel);
  
  this.bind_();
  
  this.guiView.init();
  
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  this.trigger(e.RequestLoadScenario, this.dataModel.selectedFileName);
  
};





lgb.gui.controller.ScenarioMasterController.prototype.bind_ = function() {
  
  
  this.relay(this.guiView, e.RequestLoadScenario);
  
  this.listen(e.RequestLoadScenario, this.onRequestLoadScenario_);
    
    
};



lgb.gui.controller.ScenarioMasterController.prototype.onRequestLoadScenario_ =
  function(event) {

  
    //his.dataModel.changePropertyEx('selectedFileName', value);
    
     this.guiView.showPopup_(event.payload + "_start.html");
  
};






lgb.gui.controller.ScenarioMasterController.prototype.onDataModelInitialized_ =
  function(event) {

  this.trigger(e.ScenarioDataModelLoaded, this.dataModel.systemList);
  
  
  
};


goog.provide('lgb.gui.view.LeftPanelSimpleGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.TabStrip');
goog.require('lgb.component.TabStripDataSource');

lgb.gui.view.LeftPanelSimpleGUI = function(dataModel) {

  this._TITLE = 'LeftPanelGUI';
  
  lgb.gui.view.BaseGUI.call(this, dataModel);
  this.init_();
};
goog.inherits(lgb.gui.view.LeftPanelSimpleGUI, lgb.gui.view.BaseGUI);


/**
 * @public
 */
lgb.gui.view.LeftPanelSimpleGUI.prototype.init_ = function() {


  
};


lgb.gui.view.LeftPanelSimpleGUI.prototype.add = function(gui) {


  var el = this.getMainElement();
  gui.injectInto(el);
  
};


/**
 * @public
 */
lgb.gui.view.LeftPanelSimpleGUI.prototype.injectInto = function(parentElement) {
  
    
  var el = this.getMainElement();
  
    
   var titleDiv = $('<div>')
    .attr('title', 'Learn High Performance Buildings')
    .addClass("logo-lhpb");
    
    var toolTipConfig = {
      skin: 'light',
      hook: {
        target: 'leftmiddle',
        tooltip: 'rightmiddle'
      },
      background: { color: '#fff', opacity: .95 },
      closeButton: false
    };

   Tipped.create(titleDiv, toolTipConfig);
  
  
   this.append(titleDiv);
   
 
   parentElement.append(el);  
     


  
    
};




goog.provide('lgb.gui.controller.LeftPanelSimpleController');

goog.require('lgb.core.BaseController');
goog.require('lgb.gui.controller.TestController');
goog.require('lgb.gui.controller.BuildingSimpleController');


goog.require('lgb.gui.controller.SimulationStateController');
goog.require('lgb.gui.view.SimulationStateControlGUI');

goog.require('lgb.gui.view.LeftPanelSimpleGUI');
goog.require('lgb.gui.model.BaseGuiModel');
goog.require('lgb.gui.view.BottomPanelGUI');
goog.require('lgb.gui.controller.ScenarioMasterController');

lgb.gui.controller.LeftPanelSimpleController = function() {

  lgb.core.BaseController.call(this);

};
goog.inherits(lgb.gui.controller.LeftPanelSimpleController, lgb.core.BaseController);


/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.LeftPanelSimpleController.prototype.init = function() {

  this.dataModel = new lgb.gui.model.BaseGuiModel();
  
  this.guiView = new lgb.gui.view.LeftPanelSimpleGUI(this.dataModel);
  this.triggerLocal(e.RequestAddToParentGUI, this.guiView);
  this.makeChildGUIcontroller_(lgb.gui.controller.ScenarioMasterController);
  
  this.bind_();
  
};




lgb.gui.controller.LeftPanelSimpleController.prototype.bind_ = function() {

  this.listenOnce (
    e.ScenarioDataModelLoaded,
    this.onScenarioDataModelLoadedFirstTime_
  );
  
  // this.simStateNativeNotifyKey_ = this.listen (
    // se.SimStateNativeNotify,
    // this.onSimStateNativeNotify_
  // );
  
  
};


// lgb.gui.controller.LeftPanelSimpleController.prototype.onSimStateNativeNotify_ = function(event) {
// 
  // var simStateNativeWrapper = event.getPayload();
//   
  // var theInt = simStateNativeWrapper.getIntValue();
//   
  // if (theInt == lgb.simulation.model.voNative.SimStateNativeEnum.simStateNative_3_ready) {
//     
    // this.unlisten (this.simStateNativeNotifyKey_);
    // this.makeChildGUIcontroller_(lgb.gui.controller.ScenarioMasterController);
//     
  // }
//   
//   
  // return;
// };



// lgb.gui.controller.LeftPanelSimpleController.prototype.onSimulationEngineLoaded_ = function(event) {
// 
  // var simulationMainController = event.payload;
  // this.init3_(simulationMainController);
//   
// };


lgb.gui.controller.LeftPanelSimpleController.prototype.onScenarioDataModelLoadedFirstTime_ = function(event) {


  var systemListDataModel = event.payload;

   // this.makeChildGUIcontroller_(lgb.gui.controller.ScenarioController, systemListDataModel);
   
   this.buildingSimpleController_ = this.makeChildGUIcontroller_
    (lgb.gui.controller.BuildingSimpleController, systemListDataModel);


    this.listen (
      e.ScenarioDataModelLoaded,
      this.onScenarioDataModelLoadedNTime_
    );
  
};


lgb.gui.controller.LeftPanelSimpleController.prototype.onScenarioDataModelLoadedNTime_ = function(event) {


  var systemListDataModel = event.payload;
  this.buildingSimpleController_.loadNew(systemListDataModel);
  

};



// 
// lgb.gui.controller.LeftPanelSimpleController.prototype.init3_ = function(simulationMainController) {
//   
  // this.makeChildGUIcontroller_(lgb.gui.controller.SimulationStateController, simulationMainController);
// 
// };
// 


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.controller.LayoutController');

goog.require('lgb.core.BaseController');
goog.require('goog.debug.Logger');
goog.require('lgb.core.Config');
goog.require('lgb.gui.view.LayoutView');
goog.require('lgb.gui.model.LayoutModel');


goog.require('lgb.gui.controller.LeftPanelController');
goog.require('lgb.gui.controller.LeftPanelSimpleController');


goog.require('lgb.gui.controller.ButtonsTopRightHUDController');
goog.require('lgb.gui.controller.TopMenuController');
goog.require('lgb.world.controller.VisibilityController');
goog.require('lgb.gui.controller.BottomPanelIframeGUIController');


goog.require('lgb.gui.view.TitleBarGUI');


/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.LayoutController = function() {

  lgb.core.BaseController.call(this);
  this.init_();
};
goog.inherits(lgb.gui.controller.LayoutController, lgb.core.BaseController);



/**
 * Initializes the Main Controller after the document is ready
 */
lgb.gui.controller.LayoutController.prototype.init_ = function() {
    
    
    this.dataModel = new lgb.gui.model.LayoutModel();
    this.guiView  = new lgb.gui.view.LayoutView(this.dataModel);
    this.guiView.init();
    
    this.bind_();
    
    this.leftPanelSimpleController_ = this.makeChildGUIcontroller_(lgb.gui.controller.LeftPanelSimpleController);
    this.buttonsTopRightHUDController_ = this.makeChildGUIcontroller_(lgb.gui.controller.ButtonsTopRightHUDController);
    this.bottomPanelGUIController_ = this.makeChildGUIcontroller_(lgb.gui.controller.BottomPanelIframeGUIController);
    
};



lgb.gui.controller.LayoutController.prototype.bind_ = function() {
  
  this.listenTo(this.guiView, e.LayoutChange, this.onLayoutChange_);
  this.listen(e.WindowResize, this.onWindowResize_);
  this.listen(e.RequestLayoutVisibilityChange, this.onRequestLayoutVisibilityChange_);
  

    
};




lgb.gui.controller.LayoutController.prototype.onRequestAddToParentGUI_ = function(event) {
    this.guiView.add(event.payload);
};


lgb.gui.controller.LayoutController.prototype.onRequestLayoutVisibilityChange_ = function(event) {
    this.guiView.toggleVisibility(event.payload);
};



lgb.gui.controller.LayoutController.prototype.onWindowResize_ = function(event) {
    this.guiView.calculateLayout(event.payload);
};

lgb.gui.controller.LayoutController.prototype.onLayoutChange_ = function(event) {
    
    this.guiView.calculateLayout();
    this.dispatch(event);
    
};





/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.core.EventBus');
goog.require('goog.events.EventTarget');


/**
 * Global Event Bus
 * @constructor
 * @extends {goog.events.EventTarget}
 */
lgb.core.EventBus = function() {
  goog.events.EventTarget.call(this);
};
goog.inherits(lgb.core.EventBus, goog.events.EventTarget);


/**
 * Dispatches and event on the global event bus.
 * @param {goog.events.Event} event Could be any event.
 */
lgb.core.EventBus.prototype.dispatch = function(event) {
  goog.events.dispatchEvent(this, event);
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.CameraCraneController');

goog.require('lgb.core.BaseController');


/**
 * Moves the camera through the scene
 * depends on the TweenJs library by G.kinner.
 * I need to ride my Super Techno Crane!
 * http://www.youtube.com/watch?v=Rb6NqHHOR4M
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.CameraCraneController = function() {
  lgb.core.BaseController.call(this);
  this.debugMode = false;
  
  this.moveDuration = 5 * 1000; // milliseconds
  this.lookAtDuration = 2 * 1000; // milliseconds
  this.fovDuration = 2 * 1000; // milliseconds
  
  this.metersPerSecondPosition = 6;
  this.metersPerSecondRotation = .1;
 // this.degreesPerSecondFOV = 4;
  
  this.easing = createjs.Ease.quadInOut;
  
  this.fov = 40;
  this.fovWrapper_ = new THREE.Vector3(40,0,0);
  this.destFovWrapper_ = new THREE.Vector3(40,0,0);

   
};
goog.inherits(lgb.world.controller.CameraCraneController, lgb.core.BaseController);


/**
 * initializes the controller
 * @private
 */
lgb.world.controller.CameraCraneController.prototype.init =
  function(cameraOnCrane) {

  
  this.cameraOnCrane_ = cameraOnCrane;
  this.lookAtPosition = cameraOnCrane.lookAtPosition;
  this.fov = cameraOnCrane.fov;
  
  
  if (this.debugMode) {
    
    this.debugPath = this.makeLine(this.cameraOnCrane_, this.destinationCamera_);

    this.masterGroup_= new THREE.Object3D();
      
    var blueMaterial = new THREE.MeshLambertMaterial( { color: 0x0077ff } );
    var dummyGeo = new THREE.CubeGeometry( 2, 2, 4 );

    this.debugObject = new THREE.Mesh(dummyGeo, blueMaterial);
    this.masterGroup_.add(this.debugObject);
    this.masterGroup_.add(this.debugPath);
    
    this.trigger(e.AddToWorldRequest, this.masterGroup_);
  };

  this.onRenderKey = this.listen(e.RenderNotify, this.onRender_);
    
};

lgb.world.controller.CameraCraneController.prototype.setDuration =
  function() {
    
    var pos1 = this.cameraOnCrane_.position;
    var pos2 = this.destinationCamera_.position;
         
    var positionDistance = pos1.distanceTo(pos2);
    var durationPosition = positionDistance /this.metersPerSecondPosition;
    
    this.moveDuration = durationPosition * 1000;
    this.lookAtDuration = this.moveDuration * 0.6;
      
    if (this.moveDuration < 1000) {
      this.moveDuration = 1000;
      this.lookAtDuration = 1000;
    }
    
    if (this.moveDuration > 4500) {
      this.moveDuration = 4500;
      this.lookAtDuration = 3000;
    }
    
    this.fovDuration = this.moveDuration - 50;

};

lgb.world.controller.CameraCraneController.prototype.moveToViewpoint =
  function(viewpointNode) {

   this.destinationCamera_ = viewpointNode.generateCamera( this.cameraOnCrane_ );

  this.metersPerSecondPosition = viewpointNode.metersPerSecondPosition;
    
  this.setDuration();
  this.listenForRender = true;
  

  var props = {
    override : true
  };
  
  
  //position tween

  this.tweenPosition = createjs.Tween.get(this.cameraOnCrane_.position, props);
  
    if (isNaN(this.moveDuration)) {
      debugger;
    }
  
    this.tweenPosition.to(
      this.destinationCamera_.position,
      this.moveDuration,
      this.easing 
      )
    .call(this.d(this.onTweenComplete));

    
    
  //tween target
  if (undefined !== this.destinationCamera_.lookAtPosition) {
    
    this.lookAtPosition = this.destinationCamera_.lookAtPosition;
    
    var tweenTarget = new createjs.Tween(this.lookAtPosition, props);
    
    tweenTarget.to (
      this.destinationCamera_.lookAtPosition,
      this.lookAtDuration,
      this.easing 
      );
  } else {
    debugger;
  }
  
  

  //camera up tween
  var upTween = {
    x: this.destinationCamera_.up.x,
    y: this.destinationCamera_.up.y,
    z: this.destinationCamera_.up.z
  };
  
  new createjs.Tween(this.cameraOnCrane_.up, props).to(
    upTween,
    this.lookAtDuration,
    this.easing 
    );
    
    
  if (undefined !== this.destinationCamera_.lookAtPosition) {
    
    this.lookAtPosition = this.cameraOnCrane_.lookAtPosition;
    
    var tweenTargetLookAt = new createjs.Tween(this.lookAtPosition, props);
    
    tweenTargetLookAt.to (
      this.destinationCamera_.lookAtPosition,
      this.lookAtDuration,
      this.easing 
      );
  } else {
    debugger;
  }
  
  
  //fov tween
  if (this.cameraOnCrane_.fov != this.destinationCamera_.fov) {
    
    this.destFovWrapper_ = new THREE.Vector3(this.destinationCamera_.fov,0,0);

    var tweenTargetFov = new createjs.Tween(this.fovWrapper_, props);
    
    tweenTargetFov.to (
      this.destFovWrapper_,
      this.fovDuration,
      this.easing 
      );
  } else {
    debugger;
  }
  
  
    
};



/**
 * 
 */
lgb.world.controller.CameraCraneController.prototype.makeLine = function(startObject, endObject) {
  
  var lineBasicMaterial = new THREE.LineBasicMaterial(
    { color: 0xff0000, opacity: 1, linewidth: 3 }
  );

  var vertices = [];

  var vector3Start = startObject.position.clone();
 // var vertexStart = new THREE.Vertex(vector3Start);
  vertices.push(vector3Start);
 
  var vector3End = endObject.position.clone();
 // var vertexEnd = new THREE.Vertex(vector3End);
  vertices.push(vector3End);
     
  var geometry = new THREE.Geometry();
  geometry.vertices = vertices;

  var visibleLine = new THREE.Line(geometry, lineBasicMaterial);

  return visibleLine;

};


/**
 * 
 */
lgb.world.controller.CameraCraneController.prototype.onRender_ = function(event) {
  
  if (this.listenForRender) {
    this.cameraOnCrane_.lookAt(this.lookAtPosition);
    this.cameraOnCrane_.fov = this.fovWrapper_.x;
    this.cameraOnCrane_.updateProjectionMatrix();
  }
};

/**
 * 
 */
lgb.world.controller.CameraCraneController.prototype.onTweenComplete = function(event) {
  
  this.cameraOnCrane_.lookAt(this.lookAtPosition);
  this.cameraOnCrane_.fov = this.fovWrapper_.x;
    this.cameraOnCrane_.updateProjectionMatrix();
      
      
  this.listenForRender = false;
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.view.BaseWorldView');

goog.require('lgb.core.BaseClass');
goog.require('lgb.utils');
goog.require('lgb.core.Config');



/**
 * MVC View base class
 * @constructor
 * @extends {lgb.world.view.BaseV}
 * @param {lgb.world.model.BaseModel=} dataModel that the view with display.
 */
lgb.world.view.BaseWorldView = function(dataModel) {
  lgb.core.BaseClass.call(this);


  this.dataModel = dataModel;
  
  this.masterGroup_ = new THREE.Object3D();
  this.masterGroup_.name = this._TITLE;
  this.masterGroup_.name = this.masterGroup_.name || this._ASSETS_FOLDER;

  this.filename = this.filename || 'scene.json';

};
goog.inherits(lgb.world.view.BaseWorldView, lgb.core.BaseClass);




lgb.world.view.BaseWorldView.prototype.listenForChange_ = function(changedPropertyString) {
    
    if (this.changeMap_ === undefined) {
      this.changeMap_ = {};
      this.listenHelper_(this.dataModel, e.DataModelChangedEx, this, this.onChangeEx_);
    }

    this.listenForOneChange_(changedPropertyString);
};


lgb.world.view.BaseWorldView.prototype.listenForOneChange_ = function(changedPropertyString) {
  
    var handlerName = 'onChange_' + changedPropertyString + '_';
    var func = this[handlerName];

    if (func && func instanceof Function) {
      var delegate = this.d(func);
      this.changeMap_[changedPropertyString] = delegate;
    } else {
      debugger;
    }
};


lgb.world.view.BaseWorldView.prototype.onChangeEx_ = function(event) {
  
   var whatIsDirty = event.payload;
  
    //loop through all the dirty properties and fire their event listeners
   for (var prop in whatIsDirty) {
      
      if(prop !== undefined || prop !== null) {
        
        if(whatIsDirty.hasOwnProperty(prop)){
          
          var delegate = this.changeMap_[prop];
          var arg = whatIsDirty[prop];
          
          if (delegate) {
            delegate(arg);
          }
        }
      }
   }
};


/**
 * Initializes the View
 * and loads the meshes from remote files
 * @protected
 */
lgb.world.view.BaseWorldView.prototype.init = function() {

  if (undefined === this._ASSETS_FOLDER) {
    throw ("You must define this._ASSETS_FOLDER");
  }

  this.loadSceneFromFolder_(this._ASSETS_FOLDER);
};

/**
 * Initiates the loading of the scene
 * @param {string} the folder name form which to load the 'scene.json' file
 * @protected
 */
lgb.world.view.BaseWorldView.prototype.loadSceneFromFolder_ = function(folderName) {

  var path = LGB_WEBROOT + lgb.core.Config.ASSETS_BASE_PATH + folderName + '/' + this.filename;
  this.loader_ = new THREE.SceneLoaderEx();
  this.loader_.addGeometryHandler( "binary", THREE.BinaryLoader );
  
  
  
  this.loader_.load(path, this.d(this.onSceneLoadedBase_));
};


/**
 * Event handler called when the the scene is loaded.
 * @param {Object} result From the THREE.js lib.
 * @private
 */
lgb.world.view.BaseWorldView.prototype.onSceneLoadedBase_ = function(result) {

  this.scene_ = result.scene;
  this.groups_ = result.groups;
  this.cameras_ = result.cameras;
  this.appData_ = result.appData;
  this.containers_ = result.containers;
  this.geometries_ = result.geometries;
  this.objects_ = result.objects;
  this.meshes_ = {};
  this.object3ds_ = {};
  
  this.masterGroup_.position = this.scene_.position;
  this.masterGroup_.rotation = this.scene_.rotation;
  this.masterGroup_.scale = this.scene_.scale;
  this.masterGroup_.viewpoint = "defaultScene";
  
  this.objectTypeMap_ = {
    Mesh : this.meshes_,
    Object3D : this.object3ds_,
    PerspectiveCamera : this.cameras_,
    Camera : this.cameras_,
    OrthographicCamera : this.cameras_
  };
  

  
  if ( !COMPILED  && lgb.core.Config.DEBUG_3D) {
    this.eachProperty(this.geometries_, this.analyzeOneGeometry_);
  }
 
  this.eachPropertyName(this.objects_, this.processOneObject_);
  
  if (this.containers_ != null) {
    this.placeContainers_();
  }
  
  if (this.onSceneLoaded_ !== undefined) {
    this.onSceneLoaded_();
  }
  
  this.requestAddToWorld(this.masterGroup_);
  delete this.loader_;
  
  this.triggerLocal(e.ViewInitialized);

};



//this add the object to  this.objects_,  this.meshes_ or this.cameras_
lgb.world.view.BaseWorldView.prototype.processOneObject_ = function(object, name) {
  

  var className = object.getClassName();
  
  if ('' == object.name) {
    object.name = name;
  }


  if (!this.objectTypeMap_.hasOwnProperty(className)) {
    this.objectTypeMap_[className] = {};
  }

  this.objectTypeMap_[className][name] = object;


  if (undefined !== object.groups) {
    
    for (var i = 0; i < object.groups.length; i++) {
      var groupID = object.groups[i];
  
      if (this.groups_[groupID] === undefined) {
        this.groups_[groupID] = [];
      }
      
      this.groups_[groupID].push(object);
    }
  }
};




lgb.world.view.BaseWorldView.prototype.analyzeOneGeometry_ = function(geometry) {

  var result = geometry.analyze();
  
  
  if (!result.isCentered) {

    var msg = "geometry:{0} - Geometry is not centered. offset: {1}".format(geometry.name, result.v3Offset.toString());

    lgb.logWarning(msg, this._TITLE);
  }
  

  if (result.duplicateVerticesCount > 0) {
    var msg = "geometry:{0} - Duplicate vertices found. duplicate count:{1} ".format(geometry.name, result.duplicateVerticesCount);

    lgb.logWarning(msg, this._TITLE);
  }
  
};




lgb.world.view.BaseWorldView.prototype.addAlltoMasterGroup_ = function() {

/*
   for(var mesh in this.meshes_) {
       this.masterGroup_.add(mesh); 
   }
   for(var object3d in this.object3ds_) {
       this.masterGroup_.add(object3d); 
   }*/

  var len = this.scene_.children.length;
  
  for (var i = 0; i < len; i++) {

    var child = this.scene_.children.pop();
    var className = child.getClassName();
    
    if (className == 'Mesh' || className == 'Object3d') {
       this.masterGroup_.add(child); 
    }
    
  }

  


};


lgb.world.view.BaseWorldView.prototype.placeContainers_ = function() {
    
    for(var containerName in this.containers_) {
      var containerObject = this.containers_[containerName];
      
      
      if (undefined !== containerObject.position ) {
          containerObject.position = new THREE.Vector3().fromArray(containerObject.position);
      } else {
          containerObject.position = new THREE.Vector3();
      }
      
      
      if (undefined !== containerObject.rotation ) {
          containerObject.rotation = new THREE.Euler().fromArray(containerObject.rotation);
      } else {
          containerObject.rotation = new THREE.Euler();
      }
      
      
      if (undefined !== containerObject.scale ) {
          containerObject.scale = new THREE.Vector3().fromArray(containerObject.scale);
      } else {
          containerObject.scale = new THREE.Vector3(1,1,1);
      }

      
      this.placeOneContainer_(containerName, containerObject);
    }

};



lgb.world.view.BaseWorldView.prototype.chromeBlinkingFix_ = function(mesh) {
  
    mesh.material.opacity = 1;
    
    if (mesh.geometry && mesh.geometry.materials) {
      var l = mesh.geometry.materials.length;

      for (var i = 0; i < l; i++) {
        mesh.geometry.materials[i].opacity = 1;
      }

    }
    
    
};


lgb.world.view.BaseWorldView.prototype.placeOneContainer_ = function(containerName, containerObject) {
    
    if (containerObject.type == "group") {
        
        var groupName = containerObject.groupName;
        var obj3D = new THREE.Object3D();
        obj3D.name = containerName;
        
        var ary = this.groups_[groupName];
        
        lgb.assert(ary);
        
        if (goog.userAgent.WEBKIT) {
          this.each(ary, this.chromeBlinkingFix_);
        }
        
        obj3D.cloneArray(ary);
          
        obj3D.position = containerObject.position;
        obj3D.rotation = containerObject.rotation;
        obj3D.scale = containerObject.scale;
        
        
        if (containerObject.viewpoint == null) {
           obj3D.viewpoint = "default";
        } else {
           obj3D.viewpoint = containerObject.viewpoint;
        }
        
        
        this.masterGroup_.add(obj3D);
        
    }
  
};



lgb.world.view.BaseWorldView.prototype.requestDataModelChange = function(propertyName, propertyValue) {
  
  var payload = {name:propertyName, value:propertyValue};
  this.triggerLocal(e.RequestDataModelChange, payload);
  
};


/**
 * @protected
 */
lgb.world.view.BaseWorldView.prototype.moveGroupToObject3D_ = function(groupName) {
  
  var obj3D = new THREE.Object3D();
  
  obj3D.name = this._NAME + "_GROUP_" + groupName;
  obj3D.addArray(this.groups_[groupName]);
  
  return obj3D;
};




/**
 * @param {THREE.Object3D|THREE.Mesh} object3D the object we would like
 * added to the world.
 * @protected
 */
lgb.world.view.BaseWorldView.prototype.requestAddToWorld = function(object3D) {

  object3D.name = object3D.name || this._TITLE;
  object3D.name = object3D.name || this._NAME;

  this.triggerLocal(e.AddToWorldRequest, object3D);
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.view.CameraView');

goog.require('lgb.world.controller.CameraCraneController');
goog.require('lgb.world.view.BaseWorldView');

/**
 * @constructor
 * @extends {BaseView3dScene}
 * @param {Node} domElement Needed to create the camera.
 */
lgb.world.view.CameraView = function(domElement) {


 lgb.world.view.BaseWorldView.call(this);

  this.domElement_ = domElement;

  this.offset_ = new THREE.Vector3(0, 2, 5);
};
goog.inherits(lgb.world.view.CameraView,lgb.world.view.BaseWorldView);

lgb.world.view.CameraView.prototype.init = function() {

  this.camera = new THREE.PerspectiveCamera(40, this.domElement_.width / this.domElement_.height, 1, 10000);

  this.orbitRadius = 69;
  
  this.camera.position.x = 0.6694;
  this.camera.position.y = 31.08;
  this.camera.position.z = 68.00;


  var lookat = new THREE.Vector3(0.9247, 5.451, 0);
  this.camera.lookAt(lookat);
  this.camera.name = 'ActiveCamera';

  this.bind_();
  
  this.cameraCraneController_ = new lgb.world.controller.CameraCraneController();
  this.cameraCraneController_.debugMode = false;
  this.cameraCraneController_.init(this.camera);
  
};


lgb.world.view.CameraView.prototype.bind_ = function() {
  this.listen(e.LayoutChange, this.onLayoutChange_);
};


lgb.world.view.CameraView.prototype.goToViewpointNode = function(viewpointNode) {

  this.cameraCraneController_.moveToViewpoint(viewpointNode);
  
};

/**
 * @param {THREE.Camera} camera The viewpoint to go to.
 */
lgb.world.view.CameraView.prototype.goToViewpoint = function(node) {

  //var startPosition = this.camera.position.clone();
  var targetPosition = node.getTargetPosition();

  var targetBoundingBox = node.targetBoundingBox;

  var camera = new THREE.PerspectiveCamera(this.camera.fov, this.camera.aspect, this.camera.near, this.camera.far);

  var moveToPosition = targetPosition.clone();
  moveToPosition.add(this.offset_);

  camera.position = moveToPosition;
  camera.target = targetPosition;
  camera.lookAt(targetPosition);
  
  camera.lookAtPosition = targetPosition;
  
  this.cameraCraneController_.moveToPosition(camera);

};



lgb.world.view.CameraView.prototype.onLayoutChange_ = function(event) {
  
  
  this.camera.aspect = this.domElement_.width / this.domElement_.height;
  this.camera.updateProjectionMatrix();
  
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.CameraController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.view.CameraView');


/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.CameraController = function(domElement) {
  lgb.core.BaseController.call(this);
  
  this.domElement_ = domElement;
  this.init_();
};
goog.inherits(lgb.world.controller.CameraController, lgb.core.BaseController);


/**
 * @private
 */
lgb.world.controller.CameraController.prototype.init_ = function() {

  this.view = new lgb.world.view.CameraView(this.domElement_);
  this.view.init();
  this.bind_();
};

lgb.world.controller.CameraController.prototype.getCamera = function() {

  return this.view.camera;

};

/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.CameraController.prototype.bind_ = function() {

  this.listen(
    e.RequestGoToViewpointNode,
    this.onRequestGoToViewpointNode_
  );
  
};



lgb.world.controller.CameraController.prototype.onRequestGoToViewpointNode_ =
  function(event) {
  
  this.view.goToViewpointNode(event.payload);

};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.view.UtilityGridView');

goog.require('lgb.world.view.BaseWorldView');

/**
 * @constructor
 * @extends {BaseView3dScene}
 */
lgb.world.view.UtilityGridView = function() {
    
 lgb.world.view.BaseWorldView.call(this);

  this.width_ = 120;
  
};
goog.inherits(lgb.world.view.UtilityGridView,lgb.world.view.BaseWorldView);

/**
 * Initializes the View
 */
lgb.world.view.UtilityGridView.prototype.init = function() {

  var line_material = new THREE.LineBasicMaterial({
    linewidth : 1,
    color : 0xffffff,
    opacity : 0.4,
    transparent : true
  });

  var line_material_red = new THREE.LineBasicMaterial({
    linewidth : 1,
    color : 0xff0000,
    opacity : 1,
    transparent : false
  });
  
  
  var line_material_red_desaturate = new THREE.LineBasicMaterial({
    linewidth : 1,
    color : 0x663333,
    opacity : 1,
    transparent : false
  });
  
  
  var line_material_green = new THREE.LineBasicMaterial({
    linewidth : 1,
    color : 0x00ff00,
    opacity : 1,
    transparent : false
  });
  
  var line_material_green_desaturate = new THREE.LineBasicMaterial({
    linewidth : 1,
    color : 0x336633,
    opacity : 1,
    transparent : false
  });
  
  
  var line_material_blue = new THREE.LineBasicMaterial({
    linewidth : 1,
    color : 0x0000ff,
    opacity : 1,
    transparent : false
  });
  
  
  
  var line_material_blue_desaturate = new THREE.LineBasicMaterial({
    linewidth : 1,
    color : 0x333366,
    opacity : 1,
    transparent : false
  });
  
  
  
  var geometryPlaneXZ = new THREE.Geometry();

  var geometryXpositive = new THREE.Geometry();
  var geometryXnegative = new THREE.Geometry();
  
  var geometryYpositive = new THREE.Geometry();
  var geometryYnegative = new THREE.Geometry();
  
  var geometryZpositive = new THREE.Geometry();
  var geometryZnegative = new THREE.Geometry();
  

  var ORIGIN_X = 0.0;
  var ORIGIN_Y = 0.0;
  var ORIGIN_Z = 0.0;
  
  
  var step = 1;
  var halfWidth = this.width_ / 2;

  var squaresOnEachSide = halfWidth / step * 2;
  var positiveEdge = halfWidth;
  var negativeEdge = -1 * halfWidth;;
  
  var delta = 0;
  
  for (var i = 0; i < squaresOnEachSide + 1; i++) {
    
    delta =  i * step  - halfWidth;
    
    if (i == halfWidth ) {
      
      //draws a line parallel with x axis
      geometryXpositive.vertices.push(new THREE.Vector3(ORIGIN_X, ORIGIN_Y, delta));
      geometryXpositive.vertices.push(new THREE.Vector3(positiveEdge, ORIGIN_Y, delta));
      
      geometryXnegative.vertices.push(new THREE.Vector3(ORIGIN_X, ORIGIN_Y, delta));
      geometryXnegative.vertices.push(new THREE.Vector3(negativeEdge, ORIGIN_Y, delta));
      
      geometryYpositive.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, ORIGIN_Z));
      geometryYpositive.vertices.push(new THREE.Vector3(delta, positiveEdge, ORIGIN_Z));
      
      geometryYnegative.vertices.push(new THREE.Vector3(delta, negativeEdge, ORIGIN_Z));
      geometryYnegative.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, ORIGIN_Z));
      
      
      geometryZpositive.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, ORIGIN_Z));
      geometryZpositive.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, positiveEdge));
      
      geometryZnegative.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, negativeEdge));
      geometryZnegative.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, ORIGIN_Z));
        
      continue;
    }

    //draws a line parallel with x axis
    geometryPlaneXZ.vertices.push(new THREE.Vector3(negativeEdge, ORIGIN_Y, delta));
    geometryPlaneXZ.vertices.push(new THREE.Vector3(positiveEdge, ORIGIN_Y, delta));
    
    //draws a line parallel with z axis
    geometryPlaneXZ.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, negativeEdge));
    geometryPlaneXZ.vertices.push(new THREE.Vector3(delta, ORIGIN_Y, positiveEdge));
    
  }
  
    var planeXY = new THREE.Line(geometryPlaneXZ, line_material, THREE.LinePieces);
    var lineXpositive = new THREE.Line(geometryXpositive, line_material_red, THREE.LinePieces);
    var lineXnegative = new THREE.Line(geometryXnegative, line_material_red_desaturate, THREE.LinePieces);
    var lineYpositive = new THREE.Line(geometryYpositive, line_material_green, THREE.LinePieces);
    var lineYnegative = new THREE.Line(geometryYnegative, line_material_green_desaturate, THREE.LinePieces);
    var lineZpositive = new THREE.Line(geometryZpositive, line_material_blue, THREE.LinePieces);
    var lineZnegative = new THREE.Line(geometryZnegative, line_material_blue_desaturate, THREE.LinePieces);
    
    lineXpositive.name = 'lineXpositive';
    lineXnegative.name = 'lineXnegative';
    lineYpositive.name = 'lineYpositive';
    lineYnegative.name = 'lineYnegative';
    lineZpositive.name = 'lineZpositive';
    lineZnegative.name = 'lineZnegative';
    planeXY.name = 'planeXY';
    
    this.masterGroup_ = new THREE.Object3D();
    this.masterGroup_.name = 'UtilityGridView';
    
    this.masterGroup_.add(lineXpositive);
    this.masterGroup_.add(lineXnegative);
    this.masterGroup_.add(lineYpositive);
    this.masterGroup_.add(lineYnegative);
    this.masterGroup_.add(lineZpositive);
    this.masterGroup_.add(lineZnegative);
    this.masterGroup_.add(planeXY);
    
    this.requestAddToWorld(this.masterGroup_);

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
goog.provide('lgb.world.view.UtilityAxisView');
goog.require('lgb.world.view.BaseWorldView');


/**
 * @constructor
 * @extends {BaseView3dScene}
 * @param {lgb.world.model.FurnitureModel} dataModel The model to display.
 */
lgb.world.view.UtilityAxisView = function() {
    

  this._ASSETS_FOLDER = 'utility';
 lgb.world.view.BaseWorldView.call(this, null);

  this.filename = 'axis_flipped.json';
};
goog.inherits(lgb.world.view.UtilityAxisView,lgb.world.view.BaseWorldView);



/**
 * Event handler called when the scene file is loaded
 * and all needed assets have been loaded .
 * @private
 */
lgb.world.view.UtilityAxisView.prototype.onSceneLoaded_ = function() {
 
  this.masterGroup_.addChildren(this.scene_);
  
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.controller.UtilityController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.view.UtilityAxisView');
goog.require('lgb.world.view.UtilityGridView');
goog.require('lgb.core.Config');


/**
 * MVC controller for the UtilityController
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.UtilityController = function() {

  lgb.core.BaseController.call(this);
  this.init_();
};
goog.inherits(lgb.world.controller.UtilityController, lgb.core.BaseController);

/**
 * initializes the controller
 * @private
 */
lgb.world.controller.UtilityController.prototype.init_ = function() {

  if (lgb.core.Config.UTILITY_SHOW_GRID) {
    this.gridView = new lgb.world.view.UtilityGridView();
    
    
    this.relay(this.gridView, e.AddToWorldRequest);
    
    this.gridView.init();
  }

  if (lgb.core.Config.UTILITY_SHOW_AXIS) {
    this.axisView = new lgb.world.view.UtilityAxisView();
    
    this.relay(this.axisView, e.AddToWorldRequest);
    
    this.axisView.init();
  }
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.StatsViewHelper');

goog.require('lgb.gui.view.BaseGUI');




/**
 * @constructor
 * @param {Element} containerDiv The DOM element to append to.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.StatsViewHelper = function(containerDiv) {
    
  lgb.gui.view.BaseGUI.call(this);

  this.init_(containerDiv);

};
goog.inherits(lgb.gui.view.StatsViewHelper, lgb.gui.view.BaseGUI);



/**
 * Initializes the View
 * @param {Element} containerDiv The DOM element to append to.
 * @private
 */
lgb.gui.view.StatsViewHelper.prototype.init_ = function(containerDiv) {


 this._mode = 0;
 this._modesCount = 2;

 this._frames = 0;
 this._time = new Date().getTime();
 this._timeLastFrame = this._time;
 this._timeLastSecond = this._time;

 this._fps = 0;
 this._fpsMin = 1000;
 this._fpsMax = 0;

 this._ms = 0;
 this._msMin = 1000;
 this._msMax = 0;

 this._mb = 0;
 this._mbMin = 1000;
 this._mbMax = 0;

 //ok
  this._colors = {
    fps: {
      bg: { r: 16, g: 16, b: 48 },
      fg: { r: 0, g: 255, b: 255 }
    },
    ms: {
      bg: { r: 16, g: 48, b: 16 },
      fg: { r: 0, g: 255, b: 0 }
    },
    mb: {
      bg: { r: 48, g: 16, b: 26 },
      fg: { r: 255, g: 0, b: 128 }
    }
  };

  this._container = document.createElement('div');
  this._container.style.cursor = 'pointer';
  this._container.style.width = '80px';
  this._container.style.opacity = '0.9';
  this._container.style.zIndex = '10001';

  var delegate = this.d(this.swapMode);
  this._container.addEventListener('click', delegate, false);

  this._fpsDiv = document.createElement('div');
  this._fpsDiv.style.backgroundColor =
    'rgb(' + Math.floor(this._colors.fps.bg.r / 2) +
    ',' + Math.floor(this._colors.fps.bg.g / 2) + ',' +
    Math.floor(this._colors.fps.bg.b / 2) + ')';

  this._fpsDiv.style.padding = '2px 0px 3px 0px';
  this._container.appendChild(this._fpsDiv);

  this._fpsText = document.createElement('div');
  this._fpsText.style.fontFamily = 'Helvetica, Arial, sans-serif';
  this._fpsText.style.textAlign = 'left';
  this._fpsText.style.fontSize = '9px';
  this._fpsText.style.color =
    'rgb(' + this._colors.fps.fg.r + ',' +
      this._colors.fps.fg.g + ',' +
      this._colors.fps.fg.b + ')';

  this._fpsText.style.margin = '0px 0px 1px 3px';
  this._fpsText.innerHTML = '<span style="font-weight:bold">FPS</span>';
  this._fpsDiv.appendChild(this._fpsText);

  this._fpsCanvas = document.createElement('canvas');
  this._fpsCanvas.width = 74;
  this._fpsCanvas.height = 30;
  this._fpsCanvas.style.display = 'block';
  this._fpsCanvas.style.marginLeft = '3px';
  this._fpsDiv.appendChild(this._fpsCanvas);

  //OK
  this._fpsContext = this._fpsCanvas.getContext('2d');
  this._fpsContext.fillStyle =
    'rgb(' + this._colors.fps.bg.r +
     ',' + this._colors.fps.bg.g + ',' +
     this._colors.fps.bg.b + ')';

  this._fpsContext.fillRect(
    0, 0, this._fpsCanvas.width, this._fpsCanvas.height);

  this._fpsImageData = this._fpsContext.getImageData(
    0, 0, this._fpsCanvas.width, this._fpsCanvas.height);

  this.performance = false;

  // ms
  this._msDiv = document.createElement('div');
  this._msDiv.style.backgroundColor =
    'rgb(' + Math.floor(this._colors.ms.bg.r / 2) +
    ',' + Math.floor(this._colors.ms.bg.g / 2) + ',' +
    Math.floor(this._colors.ms.bg.b / 2) + ')';

  this._msDiv.style.padding = '2px 0px 3px 0px';
  this._msDiv.style.display = 'none';
  this._container.appendChild(this._msDiv);

  this._msText = document.createElement('div');
  this._msText.style.fontFamily = 'Helvetica, Arial, sans-serif';
  this._msText.style.textAlign = 'left';
  this._msText.style.fontSize = '9px';

  this._msText.style.color =
    'rgb(' + this._colors.ms.fg.r + ',' +
     this._colors.ms.fg.g + ',' +
     this._colors.ms.fg.b + ')';

  this._msText.style.margin = '0px 0px 1px 3px';
  this._msText.innerHTML = '<span style="font-weight:bold">MS</span>';
  this._msDiv.appendChild(this._msText);

  this._msCanvas = document.createElement('canvas');
  this._msCanvas.width = 74;
  this._msCanvas.height = 30;
  this._msCanvas.style.display = 'block';
  this._msCanvas.style.marginLeft = '3px';
  this._msDiv.appendChild(this._msCanvas);

  this._msContext = this._msCanvas.getContext('2d');
  this._msContext.fillStyle =
    'rgb(' + this._colors.ms.bg.r + ',' +
      this._colors.ms.bg.g + ',' + this._colors.ms.bg.b + ')';

  this._msContext.fillRect(0, 0, this._msCanvas.width, this._msCanvas.height);

  this._msImageData = this._msContext.getImageData(
    0, 0, this._msCanvas.width, this._msCanvas.height);

  this._mbDiv = document.createElement('div');
  this._mbDiv.style.backgroundColor =
    'rgb(' + Math.floor(this._colors.mb.bg.r / 2) +
    ',' + Math.floor(this._colors.mb.bg.g / 2) + ',' +
    Math.floor(this._colors.mb.bg.b / 2) + ')';

  this._mbDiv.style.padding = '2px 0px 3px 0px';
  this._mbDiv.style.display = 'none';
  this._container.appendChild(this._mbDiv);

  this._mbText = document.createElement('div');
  this._mbText.style.fontFamily = 'Helvetica, Arial, sans-serif';
  this._mbText.style.textAlign = 'left';
  this._mbText.style.fontSize = '9px';
  this._mbText.style.color = 'rgb(' +
    this._colors.mb.fg.r + ',' +
    this._colors.mb.fg.g + ',' +
    this._colors.mb.fg.b + ')';
    this._mbText.style.margin = '0px 0px 1px 3px';

  this._mbText.innerHTML = '<span style="font-weight:bold">MB</span>';
  this._mbDiv.appendChild(this._mbText);

  this._mbCanvas = document.createElement('canvas');
  this._mbCanvas.width = 74;
  this._mbCanvas.height = 30;
  this._mbCanvas.style.display = 'block';
  this._mbCanvas.style.marginLeft = '3px';
  this._mbDiv.appendChild(this._mbCanvas);

  this._mbContext = this._mbCanvas.getContext('2d');
  this._mbContext.fillStyle = '#301010';
  this._mbContext.fillRect(0, 0, this._mbCanvas.width, this._mbCanvas.height);

  this._mbImageData = this._mbContext.getImageData(
    0, 0, this._mbCanvas.width, this._mbCanvas.height);

  this.domElement = this._container;

};



/**
 * changes from MS to FPS
 */
lgb.gui.view.StatsViewHelper.prototype.swapMode = function() {

  this._mode++;
  this._mode = this._modesCount ? this._mode = 0 : this._mode;

  this._fpsDiv.style.display = 'none';
  this._msDiv.style.display = 'none';
  this._mbDiv.style.display = 'none';

  switch (this._mode) {
    case 0:
      this._fpsDiv.style.display = 'block';
      break;
    case 1:
      this._msDiv.style.display = 'block';
      break;
    case 2:
      this._mbDiv.style.display = 'block';
      break;
  }
};


/**
 * called every animation frame to update the stats.
 */
lgb.gui.view.StatsViewHelper.prototype.update = function() {
    this._frames++;
    this._time = new Date().getTime();

    this._ms = this._time - this._timeLastFrame;
    this._msMin = Math.min(this._msMin, this._ms);
    this._msMax = Math.max(this._msMax, this._ms);

    this.updateGraph(
      this._msImageData.data,
      Math.min(30, 30 - (this._ms / 200) * 30),
      'ms'
    );


    this._msText.innerHTML = '<span style="font-weight:bold">' +
    this._ms + ' MS</span> (' + this._msMin + '-' + this._msMax + ')';

    this._msContext.putImageData(this._msImageData, 0, 0);

    this._timeLastFrame = this._time;

    if (this._time > this._timeLastSecond + 1000) {

      this._fps = Math.round((this._frames * 1000) /
        (this._time - this._timeLastSecond));

      this._fpsMin = Math.min(this._fpsMin, this._fps);
      this._fpsMax = Math.max(this._fpsMax, this._fps);

      this.updateGraph(
        this._fpsImageData.data,
        Math.min(30, 30 - (this._fps / 100) * 30),
        'fps'
      );

      this._fpsText.innerHTML = '<span style="font-weight:bold">' +
        this._fps + ' FPS</span> (' + this._fpsMin + '-' + this._fpsMax + ')';

      this._fpsContext.putImageData(this._fpsImageData, 0, 0);
      this._timeLastSecond = this._time;
      this._frames = 0;
   }
};


/**
 * called every animation frame to update the graph.
 * @param {*} data Th data.
 * @param {number} value Th value.
 * @param {*} color Th color.
 */
lgb.gui.view.StatsViewHelper.prototype.updateGraph = function(data, value, color) {

  var x, y, index;

  for (y = 0; y < 30; y++) {
    for (x = 0; x < 73; x++) {
      index = (x + y * 74) * 4;
      data[index] = data[index + 4];
      data[index + 1] = data[index + 5];
      data[index + 2] = data[index + 6];
    }
  }

  for (y = 0; y < 30; y++) {
    index = (73 + y * 74) * 4;
    if (y < value) {
      data[index] = this._colors[color].bg.r;
      data[index + 1] = this._colors[color].bg.g;
      data[index + 2] = this._colors[color].bg.b;
    } else {
      data[index] = this._colors[color].fg.r;
      data[index + 1] = this._colors[color].fg.g;
      data[index + 2] = this._colors[color].fg.b;
    }
  }
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 	 
 	 /*
 * stats.js r6
 * http://github.com/mrdoob/stats.js
 *
 * Released under MIT license:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * How to use:
 *
 *  var stats = new Stats();
 *  parentElement.appendChild( stats.domElement );
 *
 *  setInterval(function () {
 *
 *    stats.update();
 *
 *  }, 1000/60);
 *
 * modified by Raj Dye 11/12/2011
 */


goog.provide('lgb.gui.view.StatsView');

goog.require('lgb.gui.view.StatsViewHelper');
goog.require('lgb.gui.view.BaseGUI');



/**
 * MVC View
 * @constructor
 * @extends {lgb.gui.view.BaseGUI}
 * @param {Element} containerDiv The DOM element to append to.
 */
lgb.gui.view.StatsView = function(containerDiv) {

  lgb.gui.view.BaseGUI.call(this);
  this.init(containerDiv);

};
goog.inherits(lgb.gui.view.StatsView, lgb.gui.view.BaseGUI);



/**
 * Initializes the View
 * @param {Element} containerDiv The DOM element to append to.
 */
lgb.gui.view.StatsView.prototype.init = function(containerDiv) {

  this.stats_ = new lgb.gui.view.StatsViewHelper(containerDiv);
  containerDiv.appendChild(this.stats_.domElement);

  this.listen(e.RenderNotify, this.d(this.onRender));
};


/**
 * Event handler.
 * @param {e.RenderNotify} event Fired by the Worldcontroller.
 */
lgb.gui.view.StatsView.prototype.onRender = function(event) {
  this.stats_.update();
};











// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional positions.
 */


goog.provide('goog.math.Coordinate');

goog.require('goog.math');



/**
 * Class for representing coordinates and positions.
 * @param {number=} opt_x Left, defaults to 0.
 * @param {number=} opt_y Top, defaults to 0.
 * @constructor
 */
goog.math.Coordinate = function(opt_x, opt_y) {
  /**
   * X-value
   * @type {number}
   */
  this.x = goog.isDef(opt_x) ? opt_x : 0;

  /**
   * Y-value
   * @type {number}
   */
  this.y = goog.isDef(opt_y) ? opt_y : 0;
};


/**
 * Returns a new copy of the coordinate.
 * @return {!goog.math.Coordinate} A clone of this coordinate.
 */
goog.math.Coordinate.prototype.clone = function() {
  return new goog.math.Coordinate(this.x, this.y);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing the coordinate.
   * @return {string} In the form (50, 73).
   * @override
   */
  goog.math.Coordinate.prototype.toString = function() {
    return '(' + this.x + ', ' + this.y + ')';
  };
}


/**
 * Compares coordinates for equality.
 * @param {goog.math.Coordinate} a A Coordinate.
 * @param {goog.math.Coordinate} b A Coordinate.
 * @return {boolean} True iff the coordinates are equal, or if both are null.
 */
goog.math.Coordinate.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.x == b.x && a.y == b.y;
};


/**
 * Returns the distance between two coordinates.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.distance = function(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return Math.sqrt(dx * dx + dy * dy);
};


/**
 * Returns the magnitude of a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The distance between the origin and {@code a}.
 */
goog.math.Coordinate.magnitude = function(a) {
  return Math.sqrt(a.x * a.x + a.y * a.y);
};


/**
 * Returns the angle from the origin to a coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @return {number} The angle, in degrees, clockwise from the positive X
 *     axis to {@code a}.
 */
goog.math.Coordinate.azimuth = function(a) {
  return goog.math.angle(0, 0, a.x, a.y);
};


/**
 * Returns the squared distance between two coordinates. Squared distances can
 * be used for comparisons when the actual value is not required.
 *
 * Performance note: eliminating the square root is an optimization often used
 * in lower-level languages, but the speed difference is not nearly as
 * pronounced in JavaScript (only a few percent.)
 *
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {number} The squared distance between {@code a} and {@code b}.
 */
goog.math.Coordinate.squaredDistance = function(a, b) {
  var dx = a.x - b.x;
  var dy = a.y - b.y;
  return dx * dx + dy * dy;
};


/**
 * Returns the difference between two coordinates as a new
 * goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the difference
 *     between {@code a} and {@code b}.
 */
goog.math.Coordinate.difference = function(a, b) {
  return new goog.math.Coordinate(a.x - b.x, a.y - b.y);
};


/**
 * Returns the sum of two coordinates as a new goog.math.Coordinate.
 * @param {!goog.math.Coordinate} a A Coordinate.
 * @param {!goog.math.Coordinate} b A Coordinate.
 * @return {!goog.math.Coordinate} A Coordinate representing the sum of the two
 *     coordinates.
 */
goog.math.Coordinate.sum = function(a, b) {
  return new goog.math.Coordinate(a.x + b.x, a.y + b.y);
};


/**
 * Rounds the x and y fields to the next larger integer values.
 * @return {!goog.math.Coordinate} This coordinate with ceil'd fields.
 */
goog.math.Coordinate.prototype.ceil = function() {
  this.x = Math.ceil(this.x);
  this.y = Math.ceil(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the next smaller integer values.
 * @return {!goog.math.Coordinate} This coordinate with floored fields.
 */
goog.math.Coordinate.prototype.floor = function() {
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
  return this;
};


/**
 * Rounds the x and y fields to the nearest integer values.
 * @return {!goog.math.Coordinate} This coordinate with rounded fields.
 */
goog.math.Coordinate.prototype.round = function() {
  this.x = Math.round(this.x);
  this.y = Math.round(this.y);
  return this;
};


/**
 * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
 * is given, then the x and y values are translated by the coordinate's x and y.
 * Otherwise, x and y are translated by {@code tx} and {@code opt_ty}
 * respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate x by or the
 *     the coordinate to translate this coordinate by.
 * @param {number=} opt_ty The value to translate y by.
 * @return {!goog.math.Coordinate} This coordinate after translating.
 */
goog.math.Coordinate.prototype.translate = function(tx, opt_ty) {
  if (tx instanceof goog.math.Coordinate) {
    this.x += tx.x;
    this.y += tx.y;
  } else {
    this.x += tx;
    if (goog.isNumber(opt_ty)) {
      this.y += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y values are
 * scaled by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy}
 * is not given, then {@code sx} is used for both x and y.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Coordinate} This coordinate after scaling.
 */
goog.math.Coordinate.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.x *= sx;
  this.y *= sy;
  return this;
};


/**
 * Rotates this coordinate clockwise about the origin (or, optionally, the given
 * center) by the given angle, in radians.
 * @param {number} radians The angle by which to rotate this coordinate
 *     clockwise about the given center, in radians.
 * @param {!goog.math.Coordinate=} opt_center The center of rotation. Defaults
 *     to (0, 0) if not given.
 */
goog.math.Coordinate.prototype.rotateRadians = function(radians, opt_center) {
  var center = opt_center || new goog.math.Coordinate(0, 0);

  var x = this.x;
  var y = this.y;
  var cos = Math.cos(radians);
  var sin = Math.sin(radians);

  this.x = (x - center.x) * cos - (y - center.y) * sin + center.x;
  this.y = (x - center.x) * sin + (y - center.y) * cos + center.y;
};


/**
 * Rotates this coordinate clockwise about the origin (or, optionally, the given
 * center) by the given angle, in degrees.
 * @param {number} degrees The angle by which to rotate this coordinate
 *     clockwise about the given center, in degrees.
 * @param {!goog.math.Coordinate=} opt_center The center of rotation. Defaults
 *     to (0, 0) if not given.
 */
goog.math.Coordinate.prototype.rotateDegrees = function(degrees, opt_center) {
  this.rotateRadians(goog.math.toRadians(degrees), opt_center);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing a numeric box.
 */


goog.provide('goog.math.Box');

goog.require('goog.math.Coordinate');



/**
 * Class for representing a box. A box is specified as a top, right, bottom,
 * and left. A box is useful for representing margins and padding.
 *
 * @param {number} top Top.
 * @param {number} right Right.
 * @param {number} bottom Bottom.
 * @param {number} left Left.
 * @constructor
 */
goog.math.Box = function(top, right, bottom, left) {
  /**
   * Top
   * @type {number}
   */
  this.top = top;

  /**
   * Right
   * @type {number}
   */
  this.right = right;

  /**
   * Bottom
   * @type {number}
   */
  this.bottom = bottom;

  /**
   * Left
   * @type {number}
   */
  this.left = left;
};


/**
 * Creates a Box by bounding a collection of goog.math.Coordinate objects
 * @param {...goog.math.Coordinate} var_args Coordinates to be included inside
 *     the box.
 * @return {!goog.math.Box} A Box containing all the specified Coordinates.
 */
goog.math.Box.boundingBox = function(var_args) {
  var box = new goog.math.Box(arguments[0].y, arguments[0].x,
                              arguments[0].y, arguments[0].x);
  for (var i = 1; i < arguments.length; i++) {
    var coord = arguments[i];
    box.top = Math.min(box.top, coord.y);
    box.right = Math.max(box.right, coord.x);
    box.bottom = Math.max(box.bottom, coord.y);
    box.left = Math.min(box.left, coord.x);
  }
  return box;
};


/**
 * Creates a copy of the box with the same dimensions.
 * @return {!goog.math.Box} A clone of this Box.
 */
goog.math.Box.prototype.clone = function() {
  return new goog.math.Box(this.top, this.right, this.bottom, this.left);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing the box.
   * @return {string} In the form (50t, 73r, 24b, 13l).
   * @override
   */
  goog.math.Box.prototype.toString = function() {
    return '(' + this.top + 't, ' + this.right + 'r, ' + this.bottom + 'b, ' +
           this.left + 'l)';
  };
}


/**
 * Returns whether the box contains a coordinate or another box.
 *
 * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
 * @return {boolean} Whether the box contains the coordinate or other box.
 */
goog.math.Box.prototype.contains = function(other) {
  return goog.math.Box.contains(this, other);
};


/**
 * Expands box with the given margins.
 *
 * @param {number|goog.math.Box} top Top margin or box with all margins.
 * @param {number=} opt_right Right margin.
 * @param {number=} opt_bottom Bottom margin.
 * @param {number=} opt_left Left margin.
 * @return {!goog.math.Box} A reference to this Box.
 */
goog.math.Box.prototype.expand = function(top, opt_right, opt_bottom,
    opt_left) {
  if (goog.isObject(top)) {
    this.top -= top.top;
    this.right += top.right;
    this.bottom += top.bottom;
    this.left -= top.left;
  } else {
    this.top -= top;
    this.right += opt_right;
    this.bottom += opt_bottom;
    this.left -= opt_left;
  }

  return this;
};


/**
 * Expand this box to include another box.
 * NOTE(user): This is used in code that needs to be very fast, please don't
 * add functionality to this function at the expense of speed (variable
 * arguments, accepting multiple argument types, etc).
 * @param {goog.math.Box} box The box to include in this one.
 */
goog.math.Box.prototype.expandToInclude = function(box) {
  this.left = Math.min(this.left, box.left);
  this.top = Math.min(this.top, box.top);
  this.right = Math.max(this.right, box.right);
  this.bottom = Math.max(this.bottom, box.bottom);
};


/**
 * Compares boxes for equality.
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A Box.
 * @return {boolean} True iff the boxes are equal, or if both are null.
 */
goog.math.Box.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.top == b.top && a.right == b.right &&
         a.bottom == b.bottom && a.left == b.left;
};


/**
 * Returns whether a box contains a coordinate or another box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate|goog.math.Box} other A Coordinate or a Box.
 * @return {boolean} Whether the box contains the coordinate or other box.
 */
goog.math.Box.contains = function(box, other) {
  if (!box || !other) {
    return false;
  }

  if (other instanceof goog.math.Box) {
    return other.left >= box.left && other.right <= box.right &&
        other.top >= box.top && other.bottom <= box.bottom;
  }

  // other is a Coordinate.
  return other.x >= box.left && other.x <= box.right &&
         other.y >= box.top && other.y <= box.bottom;
};


/**
 * Returns the relative x position of a coordinate compared to a box.  Returns
 * zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The x position of {@code coord} relative to the nearest
 *     side of {@code box}, or zero if {@code coord} is inside {@code box}.
 */
goog.math.Box.relativePositionX = function(box, coord) {
  if (coord.x < box.left) {
    return coord.x - box.left;
  } else if (coord.x > box.right) {
    return coord.x - box.right;
  }
  return 0;
};


/**
 * Returns the relative y position of a coordinate compared to a box.  Returns
 * zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The y position of {@code coord} relative to the nearest
 *     side of {@code box}, or zero if {@code coord} is inside {@code box}.
 */
goog.math.Box.relativePositionY = function(box, coord) {
  if (coord.y < box.top) {
    return coord.y - box.top;
  } else if (coord.y > box.bottom) {
    return coord.y - box.bottom;
  }
  return 0;
};


/**
 * Returns the distance between a coordinate and the nearest corner/side of a
 * box. Returns zero if the coordinate is inside the box.
 *
 * @param {goog.math.Box} box A Box.
 * @param {goog.math.Coordinate} coord A Coordinate.
 * @return {number} The distance between {@code coord} and the nearest
 *     corner/side of {@code box}, or zero if {@code coord} is inside
 *     {@code box}.
 */
goog.math.Box.distance = function(box, coord) {
  var x = goog.math.Box.relativePositionX(box, coord);
  var y = goog.math.Box.relativePositionY(box, coord);
  return Math.sqrt(x * x + y * y);
};


/**
 * Returns whether two boxes intersect.
 *
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A second Box.
 * @return {boolean} Whether the boxes intersect.
 */
goog.math.Box.intersects = function(a, b) {
  return (a.left <= b.right && b.left <= a.right &&
          a.top <= b.bottom && b.top <= a.bottom);
};


/**
 * Returns whether two boxes would intersect with additional padding.
 *
 * @param {goog.math.Box} a A Box.
 * @param {goog.math.Box} b A second Box.
 * @param {number} padding The additional padding.
 * @return {boolean} Whether the boxes intersect.
 */
goog.math.Box.intersectsWithPadding = function(a, b, padding) {
  return (a.left <= b.right + padding && b.left <= a.right + padding &&
          a.top <= b.bottom + padding && b.top <= a.bottom + padding);
};


/**
 * Rounds the fields to the next larger integer values.
 *
 * @return {!goog.math.Box} This box with ceil'd fields.
 */
goog.math.Box.prototype.ceil = function() {
  this.top = Math.ceil(this.top);
  this.right = Math.ceil(this.right);
  this.bottom = Math.ceil(this.bottom);
  this.left = Math.ceil(this.left);
  return this;
};


/**
 * Rounds the fields to the next smaller integer values.
 *
 * @return {!goog.math.Box} This box with floored fields.
 */
goog.math.Box.prototype.floor = function() {
  this.top = Math.floor(this.top);
  this.right = Math.floor(this.right);
  this.bottom = Math.floor(this.bottom);
  this.left = Math.floor(this.left);
  return this;
};


/**
 * Rounds the fields to nearest integer values.
 *
 * @return {!goog.math.Box} This box with rounded fields.
 */
goog.math.Box.prototype.round = function() {
  this.top = Math.round(this.top);
  this.right = Math.round(this.right);
  this.bottom = Math.round(this.bottom);
  this.left = Math.round(this.left);
  return this;
};


/**
 * Translates this box by the given offsets. If a {@code goog.math.Coordinate}
 * is given, then the left and right values are translated by the coordinate's
 * x value and the top and bottom values are translated by the coordinate's y
 * value.  Otherwise, {@code tx} and {@code opt_ty} are used to translate the x
 * and y dimension values.
 *
 * @param {number|goog.math.Coordinate} tx The value to translate the x
 *     dimension values by or the the coordinate to translate this box by.
 * @param {number=} opt_ty The value to translate y dimension values by.
 * @return {!goog.math.Box} This box after translating.
 */
goog.math.Box.prototype.translate = function(tx, opt_ty) {
  if (tx instanceof goog.math.Coordinate) {
    this.left += tx.x;
    this.right += tx.x;
    this.top += tx.y;
    this.bottom += tx.y;
  } else {
    this.left += tx;
    this.right += tx;
    if (goog.isNumber(opt_ty)) {
      this.top += opt_ty;
      this.bottom += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this coordinate by the given scale factors. The x and y dimension
 * values are scaled by {@code sx} and {@code opt_sy} respectively.
 * If {@code opt_sy} is not given, then {@code sx} is used for both x and y.
 *
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Box} This box after scaling.
 */
goog.math.Box.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.left *= sx;
  this.right *= sx;
  this.top *= sy;
  this.bottom *= sy;
  return this;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing two-dimensional sizes.
 */


goog.provide('goog.math.Size');



/**
 * Class for representing sizes consisting of a width and height. Undefined
 * width and height support is deprecated and results in compiler warning.
 * @param {number} width Width.
 * @param {number} height Height.
 * @constructor
 */
goog.math.Size = function(width, height) {
  /**
   * Width
   * @type {number}
   */
  this.width = width;

  /**
   * Height
   * @type {number}
   */
  this.height = height;
};


/**
 * Compares sizes for equality.
 * @param {goog.math.Size} a A Size.
 * @param {goog.math.Size} b A Size.
 * @return {boolean} True iff the sizes have equal widths and equal
 *     heights, or if both are null.
 */
goog.math.Size.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.width == b.width && a.height == b.height;
};


/**
 * @return {!goog.math.Size} A new copy of the Size.
 */
goog.math.Size.prototype.clone = function() {
  return new goog.math.Size(this.width, this.height);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size.
   * @return {string} In the form (50 x 73).
   * @override
   */
  goog.math.Size.prototype.toString = function() {
    return '(' + this.width + ' x ' + this.height + ')';
  };
}


/**
 * @return {number} The longer of the two dimensions in the size.
 */
goog.math.Size.prototype.getLongest = function() {
  return Math.max(this.width, this.height);
};


/**
 * @return {number} The shorter of the two dimensions in the size.
 */
goog.math.Size.prototype.getShortest = function() {
  return Math.min(this.width, this.height);
};


/**
 * @return {number} The area of the size (width * height).
 */
goog.math.Size.prototype.area = function() {
  return this.width * this.height;
};


/**
 * @return {number} The perimeter of the size (width + height) * 2.
 */
goog.math.Size.prototype.perimeter = function() {
  return (this.width + this.height) * 2;
};


/**
 * @return {number} The ratio of the size's width to its height.
 */
goog.math.Size.prototype.aspectRatio = function() {
  return this.width / this.height;
};


/**
 * @return {boolean} True if the size has zero area, false if both dimensions
 *     are non-zero numbers.
 */
goog.math.Size.prototype.isEmpty = function() {
  return !this.area();
};


/**
 * Clamps the width and height parameters upward to integer values.
 * @return {!goog.math.Size} This size with ceil'd components.
 */
goog.math.Size.prototype.ceil = function() {
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * @param {!goog.math.Size} target The target size.
 * @return {boolean} True if this Size is the same size or smaller than the
 *     target size in both dimensions.
 */
goog.math.Size.prototype.fitsInside = function(target) {
  return this.width <= target.width && this.height <= target.height;
};


/**
 * Clamps the width and height parameters downward to integer values.
 * @return {!goog.math.Size} This size with floored components.
 */
goog.math.Size.prototype.floor = function() {
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the width and height parameters to integer values.
 * @return {!goog.math.Size} This size with rounded components.
 */
goog.math.Size.prototype.round = function() {
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Scales this size by the given scale factors. The width and height are scaled
 * by {@code sx} and {@code opt_sy} respectively.  If {@code opt_sy} is not
 * given, then {@code sx} is used for both the width and height.
 * @param {number} sx The scale factor to use for the width.
 * @param {number=} opt_sy The scale factor to use for the height.
 * @return {!goog.math.Size} This Size object after scaling.
 */
goog.math.Size.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.width *= sx;
  this.height *= sy;
  return this;
};


/**
 * Uniformly scales the size to fit inside the dimensions of a given size. The
 * original aspect ratio will be preserved.
 *
 * This function assumes that both Sizes contain strictly positive dimensions.
 * @param {!goog.math.Size} target The target size.
 * @return {!goog.math.Size} This Size object, after optional scaling.
 */
goog.math.Size.prototype.scaleToFit = function(target) {
  var s = this.aspectRatio() > target.aspectRatio() ?
      target.width / this.width :
      target.height / this.height;

  return this.scale(s);
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview A utility class for representing rectangles.
 */

goog.provide('goog.math.Rect');

goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');



/**
 * Class for representing rectangular regions.
 * @param {number} x Left.
 * @param {number} y Top.
 * @param {number} w Width.
 * @param {number} h Height.
 * @constructor
 */
goog.math.Rect = function(x, y, w, h) {
  /** @type {number} */
  this.left = x;

  /** @type {number} */
  this.top = y;

  /** @type {number} */
  this.width = w;

  /** @type {number} */
  this.height = h;
};


/**
 * @return {!goog.math.Rect} A new copy of this Rectangle.
 */
goog.math.Rect.prototype.clone = function() {
  return new goog.math.Rect(this.left, this.top, this.width, this.height);
};


/**
 * Returns a new Box object with the same position and dimensions as this
 * rectangle.
 * @return {!goog.math.Box} A new Box representation of this Rectangle.
 */
goog.math.Rect.prototype.toBox = function() {
  var right = this.left + this.width;
  var bottom = this.top + this.height;
  return new goog.math.Box(this.top,
                           right,
                           bottom,
                           this.left);
};


/**
 * Creates a new Rect object with the same position and dimensions as a given
 * Box.  Note that this is only the inverse of toBox if left/top are defined.
 * @param {goog.math.Box} box A box.
 * @return {!goog.math.Rect} A new Rect initialized with the box's position
 *     and size.
 */
goog.math.Rect.createFromBox = function(box) {
  return new goog.math.Rect(box.left, box.top,
      box.right - box.left, box.bottom - box.top);
};


if (goog.DEBUG) {
  /**
   * Returns a nice string representing size and dimensions of rectangle.
   * @return {string} In the form (50, 73 - 75w x 25h).
   * @override
   */
  goog.math.Rect.prototype.toString = function() {
    return '(' + this.left + ', ' + this.top + ' - ' + this.width + 'w x ' +
           this.height + 'h)';
  };
}


/**
 * Compares rectangles for equality.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {boolean} True iff the rectangles have the same left, top, width,
 *     and height, or if both are null.
 */
goog.math.Rect.equals = function(a, b) {
  if (a == b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.left == b.left && a.width == b.width &&
         a.top == b.top && a.height == b.height;
};


/**
 * Computes the intersection of this rectangle and the rectangle parameter.  If
 * there is no intersection, returns false and leaves this rectangle as is.
 * @param {goog.math.Rect} rect A Rectangle.
 * @return {boolean} True iff this rectangle intersects with the parameter.
 */
goog.math.Rect.prototype.intersection = function(rect) {
  var x0 = Math.max(this.left, rect.left);
  var x1 = Math.min(this.left + this.width, rect.left + rect.width);

  if (x0 <= x1) {
    var y0 = Math.max(this.top, rect.top);
    var y1 = Math.min(this.top + this.height, rect.top + rect.height);

    if (y0 <= y1) {
      this.left = x0;
      this.top = y0;
      this.width = x1 - x0;
      this.height = y1 - y0;

      return true;
    }
  }
  return false;
};


/**
 * Returns the intersection of two rectangles. Two rectangles intersect if they
 * touch at all, for example, two zero width and height rectangles would
 * intersect if they had the same top and left.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {goog.math.Rect} A new intersection rect (even if width and height
 *     are 0), or null if there is no intersection.
 */
goog.math.Rect.intersection = function(a, b) {
  // There is no nice way to do intersection via a clone, because any such
  // clone might be unnecessary if this function returns null.  So, we duplicate
  // code from above.

  var x0 = Math.max(a.left, b.left);
  var x1 = Math.min(a.left + a.width, b.left + b.width);

  if (x0 <= x1) {
    var y0 = Math.max(a.top, b.top);
    var y1 = Math.min(a.top + a.height, b.top + b.height);

    if (y0 <= y1) {
      return new goog.math.Rect(x0, y0, x1 - x0, y1 - y0);
    }
  }
  return null;
};


/**
 * Returns whether two rectangles intersect. Two rectangles intersect if they
 * touch at all, for example, two zero width and height rectangles would
 * intersect if they had the same top and left.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {boolean} Whether a and b intersect.
 */
goog.math.Rect.intersects = function(a, b) {
  return (a.left <= b.left + b.width && b.left <= a.left + a.width &&
      a.top <= b.top + b.height && b.top <= a.top + a.height);
};


/**
 * Returns whether a rectangle intersects this rectangle.
 * @param {goog.math.Rect} rect A rectangle.
 * @return {boolean} Whether rect intersects this rectangle.
 */
goog.math.Rect.prototype.intersects = function(rect) {
  return goog.math.Rect.intersects(this, rect);
};


/**
 * Computes the difference regions between two rectangles. The return value is
 * an array of 0 to 4 rectangles defining the remaining regions of the first
 * rectangle after the second has been subtracted.
 * @param {goog.math.Rect} a A Rectangle.
 * @param {goog.math.Rect} b A Rectangle.
 * @return {!Array.<!goog.math.Rect>} An array with 0 to 4 rectangles which
 *     together define the difference area of rectangle a minus rectangle b.
 */
goog.math.Rect.difference = function(a, b) {
  var intersection = goog.math.Rect.intersection(a, b);
  if (!intersection || !intersection.height || !intersection.width) {
    return [a.clone()];
  }

  var result = [];

  var top = a.top;
  var height = a.height;

  var ar = a.left + a.width;
  var ab = a.top + a.height;

  var br = b.left + b.width;
  var bb = b.top + b.height;

  // Subtract off any area on top where A extends past B
  if (b.top > a.top) {
    result.push(new goog.math.Rect(a.left, a.top, a.width, b.top - a.top));
    top = b.top;
    // If we're moving the top down, we also need to subtract the height diff.
    height -= b.top - a.top;
  }
  // Subtract off any area on bottom where A extends past B
  if (bb < ab) {
    result.push(new goog.math.Rect(a.left, bb, a.width, ab - bb));
    height = bb - top;
  }
  // Subtract any area on left where A extends past B
  if (b.left > a.left) {
    result.push(new goog.math.Rect(a.left, top, b.left - a.left, height));
  }
  // Subtract any area on right where A extends past B
  if (br < ar) {
    result.push(new goog.math.Rect(br, top, ar - br, height));
  }

  return result;
};


/**
 * Computes the difference regions between this rectangle and {@code rect}. The
 * return value is an array of 0 to 4 rectangles defining the remaining regions
 * of this rectangle after the other has been subtracted.
 * @param {goog.math.Rect} rect A Rectangle.
 * @return {!Array.<!goog.math.Rect>} An array with 0 to 4 rectangles which
 *     together define the difference area of rectangle a minus rectangle b.
 */
goog.math.Rect.prototype.difference = function(rect) {
  return goog.math.Rect.difference(this, rect);
};


/**
 * Expand this rectangle to also include the area of the given rectangle.
 * @param {goog.math.Rect} rect The other rectangle.
 */
goog.math.Rect.prototype.boundingRect = function(rect) {
  // We compute right and bottom before we change left and top below.
  var right = Math.max(this.left + this.width, rect.left + rect.width);
  var bottom = Math.max(this.top + this.height, rect.top + rect.height);

  this.left = Math.min(this.left, rect.left);
  this.top = Math.min(this.top, rect.top);

  this.width = right - this.left;
  this.height = bottom - this.top;
};


/**
 * Returns a new rectangle which completely contains both input rectangles.
 * @param {goog.math.Rect} a A rectangle.
 * @param {goog.math.Rect} b A rectangle.
 * @return {goog.math.Rect} A new bounding rect, or null if either rect is
 *     null.
 */
goog.math.Rect.boundingRect = function(a, b) {
  if (!a || !b) {
    return null;
  }

  var clone = a.clone();
  clone.boundingRect(b);

  return clone;
};


/**
 * Tests whether this rectangle entirely contains another rectangle or
 * coordinate.
 *
 * @param {goog.math.Rect|goog.math.Coordinate} another The rectangle or
 *     coordinate to test for containment.
 * @return {boolean} Whether this rectangle contains given rectangle or
 *     coordinate.
 */
goog.math.Rect.prototype.contains = function(another) {
  if (another instanceof goog.math.Rect) {
    return this.left <= another.left &&
           this.left + this.width >= another.left + another.width &&
           this.top <= another.top &&
           this.top + this.height >= another.top + another.height;
  } else { // (another instanceof goog.math.Coordinate)
    return another.x >= this.left &&
           another.x <= this.left + this.width &&
           another.y >= this.top &&
           another.y <= this.top + this.height;
  }
};


/**
 * @param {!goog.math.Coordinate} point A coordinate.
 * @return {number} The squared distance between the point and the closest
 *     point inside the rectangle. Returns 0 if the point is inside the
 *     rectangle.
 */
goog.math.Rect.prototype.squaredDistance = function(point) {
  var dx = point.x < this.left ?
      this.left - point.x : Math.max(point.x - (this.left + this.width), 0);
  var dy = point.y < this.top ?
      this.top - point.y : Math.max(point.y - (this.top + this.height), 0);
  return dx * dx + dy * dy;
};


/**
 * @param {!goog.math.Coordinate} point A coordinate.
 * @return {number} The distance between the point and the closest point
 *     inside the rectangle. Returns 0 if the point is inside the rectangle.
 */
goog.math.Rect.prototype.distance = function(point) {
  return Math.sqrt(this.squaredDistance(point));
};


/**
 * @return {!goog.math.Size} The size of this rectangle.
 */
goog.math.Rect.prototype.getSize = function() {
  return new goog.math.Size(this.width, this.height);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the top-left corner of
 *     the rectangle.
 */
goog.math.Rect.prototype.getTopLeft = function() {
  return new goog.math.Coordinate(this.left, this.top);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the center of the
 *     rectangle.
 */
goog.math.Rect.prototype.getCenter = function() {
  return new goog.math.Coordinate(
      this.left + this.width / 2, this.top + this.height / 2);
};


/**
 * @return {!goog.math.Coordinate} A new coordinate for the bottom-right corner
 *     of the rectangle.
 */
goog.math.Rect.prototype.getBottomRight = function() {
  return new goog.math.Coordinate(
      this.left + this.width, this.top + this.height);
};


/**
 * Rounds the fields to the next larger integer values.
 * @return {!goog.math.Rect} This rectangle with ceil'd fields.
 */
goog.math.Rect.prototype.ceil = function() {
  this.left = Math.ceil(this.left);
  this.top = Math.ceil(this.top);
  this.width = Math.ceil(this.width);
  this.height = Math.ceil(this.height);
  return this;
};


/**
 * Rounds the fields to the next smaller integer values.
 * @return {!goog.math.Rect} This rectangle with floored fields.
 */
goog.math.Rect.prototype.floor = function() {
  this.left = Math.floor(this.left);
  this.top = Math.floor(this.top);
  this.width = Math.floor(this.width);
  this.height = Math.floor(this.height);
  return this;
};


/**
 * Rounds the fields to nearest integer values.
 * @return {!goog.math.Rect} This rectangle with rounded fields.
 */
goog.math.Rect.prototype.round = function() {
  this.left = Math.round(this.left);
  this.top = Math.round(this.top);
  this.width = Math.round(this.width);
  this.height = Math.round(this.height);
  return this;
};


/**
 * Translates this rectangle by the given offsets. If a
 * {@code goog.math.Coordinate} is given, then the left and top values are
 * translated by the coordinate's x and y values. Otherwise, top and left are
 * translated by {@code tx} and {@code opt_ty} respectively.
 * @param {number|goog.math.Coordinate} tx The value to translate left by or the
 *     the coordinate to translate this rect by.
 * @param {number=} opt_ty The value to translate top by.
 * @return {!goog.math.Rect} This rectangle after translating.
 */
goog.math.Rect.prototype.translate = function(tx, opt_ty) {
  if (tx instanceof goog.math.Coordinate) {
    this.left += tx.x;
    this.top += tx.y;
  } else {
    this.left += tx;
    if (goog.isNumber(opt_ty)) {
      this.top += opt_ty;
    }
  }
  return this;
};


/**
 * Scales this rectangle by the given scale factors. The left and width values
 * are scaled by {@code sx} and the top and height values are scaled by
 * {@code opt_sy}.  If {@code opt_sy} is not given, then all fields are scaled
 * by {@code sx}.
 * @param {number} sx The scale factor to use for the x dimension.
 * @param {number=} opt_sy The scale factor to use for the y dimension.
 * @return {!goog.math.Rect} This rectangle after scaling.
 */
goog.math.Rect.prototype.scale = function(sx, opt_sy) {
  var sy = goog.isNumber(opt_sy) ? opt_sy : sx;
  this.left *= sx;
  this.width *= sx;
  this.top *= sy;
  this.height *= sy;
  return this;
};
// Copyright 2012 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Vendor prefix getters.
 */

goog.provide('goog.dom.vendor');

goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * Returns the JS vendor prefix used in CSS properties. Different vendors
 * use different methods of changing the case of the property names.
 *
 * @return {?string} The JS vendor prefix or null if there is none.
 */
goog.dom.vendor.getVendorJsPrefix = function() {
  if (goog.userAgent.WEBKIT) {
    return 'Webkit';
  } else if (goog.userAgent.GECKO) {
    return 'Moz';
  } else if (goog.userAgent.IE) {
    return 'ms';
  } else if (goog.userAgent.OPERA) {
    return 'O';
  }

  return null;
};


/**
 * Returns the vendor prefix used in CSS properties.
 *
 * @return {?string} The vendor prefix or null if there is none.
 */
goog.dom.vendor.getVendorPrefix = function() {
  if (goog.userAgent.WEBKIT) {
    return '-webkit';
  } else if (goog.userAgent.GECKO) {
    return '-moz';
  } else if (goog.userAgent.IE) {
    return '-ms';
  } else if (goog.userAgent.OPERA) {
    return '-o';
  }

  return null;
};


/**
 * @param {string} propertyName A property name.
 * @param {!Object=} opt_object If provided, we verify if the property exists in
 *     the object.
 * @return {?string} A vendor prefixed property name, or null if it does not
 *     exist.
 */
goog.dom.vendor.getPrefixedPropertyName = function(propertyName, opt_object) {
  // We first check for a non-prefixed property, if available.
  if (opt_object && propertyName in opt_object) {
    return propertyName;
  }
  var prefix = goog.dom.vendor.getVendorJsPrefix();
  if (prefix) {
    prefix = prefix.toLowerCase();
    var prefixedPropertyName = prefix + goog.string.toTitleCase(propertyName);
    return (!goog.isDef(opt_object) || prefixedPropertyName in opt_object) ?
        prefixedPropertyName : null;
  }
  return null;
};


/**
 * @param {string} eventType An event type.
 * @return {string} A lower-cased vendor prefixed event type.
 */
goog.dom.vendor.getPrefixedEventType = function(eventType) {
  var prefix = goog.dom.vendor.getVendorJsPrefix() || '';
  return (prefix + eventType).toLowerCase();
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for adding, removing and setting classes.  Prefer
 * {@link goog.dom.classlist} over these utilities since goog.dom.classlist
 * conforms closer to the semantics of Element.classList, is faster (uses
 * native methods rather than parsing strings on every call) and compiles
 * to smaller code as a result.
 *
 * Note: these utilities are meant to operate on HTMLElements and
 * will not work on elements with differing interfaces (such as SVGElements).
 *
 */


goog.provide('goog.dom.classes');

goog.require('goog.array');


/**
 * Sets the entire class name of an element.
 * @param {Node} element DOM node to set class of.
 * @param {string} className Class name(s) to apply to element.
 */
goog.dom.classes.set = function(element, className) {
  element.className = className;
};


/**
 * Gets an array of class names on an element
 * @param {Node} element DOM node to get class of.
 * @return {!Array} Class names on {@code element}. Some browsers add extra
 *     properties to the array. Do not depend on any of these!
 */
goog.dom.classes.get = function(element) {
  var className = element.className;
  // Some types of elements don't have a className in IE (e.g. iframes).
  // Furthermore, in Firefox, className is not a string when the element is
  // an SVG element.
  return goog.isString(className) && className.match(/\S+/g) || [];
};


/**
 * Adds a class or classes to an element. Does not add multiples of class names.
 * @param {Node} element DOM node to add class to.
 * @param {...string} var_args Class names to add.
 * @return {boolean} Whether class was added (or all classes were added).
 */
goog.dom.classes.add = function(element, var_args) {
  var classes = goog.dom.classes.get(element);
  var args = goog.array.slice(arguments, 1);
  var expectedCount = classes.length + args.length;
  goog.dom.classes.add_(classes, args);
  goog.dom.classes.set(element, classes.join(' '));
  return classes.length == expectedCount;
};


/**
 * Removes a class or classes from an element.
 * @param {Node} element DOM node to remove class from.
 * @param {...string} var_args Class name(s) to remove.
 * @return {boolean} Whether all classes in {@code var_args} were found and
 *     removed.
 */
goog.dom.classes.remove = function(element, var_args) {
  var classes = goog.dom.classes.get(element);
  var args = goog.array.slice(arguments, 1);
  var newClasses = goog.dom.classes.getDifference_(classes, args);
  goog.dom.classes.set(element, newClasses.join(' '));
  return newClasses.length == classes.length - args.length;
};


/**
 * Helper method for {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.addRemove}. Adds one or more classes to the supplied
 * classes array.
 * @param {Array.<string>} classes All class names for the element, will be
 *     updated to have the classes supplied in {@code args} added.
 * @param {Array.<string>} args Class names to add.
 * @private
 */
goog.dom.classes.add_ = function(classes, args) {
  for (var i = 0; i < args.length; i++) {
    if (!goog.array.contains(classes, args[i])) {
      classes.push(args[i]);
    }
  }
};


/**
 * Helper method for {@link goog.dom.classes.remove} and
 * {@link goog.dom.classes.addRemove}. Calculates the difference of two arrays.
 * @param {!Array.<string>} arr1 First array.
 * @param {!Array.<string>} arr2 Second array.
 * @return {!Array.<string>} The first array without the elements of the second
 *     array.
 * @private
 */
goog.dom.classes.getDifference_ = function(arr1, arr2) {
  return goog.array.filter(arr1, function(item) {
    return !goog.array.contains(arr2, item);
  });
};


/**
 * Switches a class on an element from one to another without disturbing other
 * classes. If the fromClass isn't removed, the toClass won't be added.
 * @param {Node} element DOM node to swap classes on.
 * @param {string} fromClass Class to remove.
 * @param {string} toClass Class to add.
 * @return {boolean} Whether classes were switched.
 */
goog.dom.classes.swap = function(element, fromClass, toClass) {
  var classes = goog.dom.classes.get(element);

  var removed = false;
  for (var i = 0; i < classes.length; i++) {
    if (classes[i] == fromClass) {
      goog.array.splice(classes, i--, 1);
      removed = true;
    }
  }

  if (removed) {
    classes.push(toClass);
    goog.dom.classes.set(element, classes.join(' '));
  }

  return removed;
};


/**
 * Adds zero or more classes to an element and removes zero or more as a single
 * operation. Unlike calling {@link goog.dom.classes.add} and
 * {@link goog.dom.classes.remove} separately, this is more efficient as it only
 * parses the class property once.
 *
 * If a class is in both the remove and add lists, it will be added. Thus,
 * you can use this instead of {@link goog.dom.classes.swap} when you have
 * more than two class names that you want to swap.
 *
 * @param {Node} element DOM node to swap classes on.
 * @param {?(string|Array.<string>)} classesToRemove Class or classes to
 *     remove, if null no classes are removed.
 * @param {?(string|Array.<string>)} classesToAdd Class or classes to add, if
 *     null no classes are added.
 */
goog.dom.classes.addRemove = function(element, classesToRemove, classesToAdd) {
  var classes = goog.dom.classes.get(element);
  if (goog.isString(classesToRemove)) {
    goog.array.remove(classes, classesToRemove);
  } else if (goog.isArray(classesToRemove)) {
    classes = goog.dom.classes.getDifference_(classes, classesToRemove);
  }

  if (goog.isString(classesToAdd) &&
      !goog.array.contains(classes, classesToAdd)) {
    classes.push(classesToAdd);
  } else if (goog.isArray(classesToAdd)) {
    goog.dom.classes.add_(classes, classesToAdd);
  }

  goog.dom.classes.set(element, classes.join(' '));
};


/**
 * Returns true if an element has a class.
 * @param {Node} element DOM node to test.
 * @param {string} className Class name to test for.
 * @return {boolean} Whether element has the class.
 */
goog.dom.classes.has = function(element, className) {
  return goog.array.contains(goog.dom.classes.get(element), className);
};


/**
 * Adds or removes a class depending on the enabled argument.
 * @param {Node} element DOM node to add or remove the class on.
 * @param {string} className Class name to add or remove.
 * @param {boolean} enabled Whether to add or remove the class (true adds,
 *     false removes).
 */
goog.dom.classes.enable = function(element, className, enabled) {
  if (enabled) {
    goog.dom.classes.add(element, className);
  } else {
    goog.dom.classes.remove(element, className);
  }
};


/**
 * Removes a class if an element has it, and adds it the element doesn't have
 * it.  Won't affect other classes on the node.
 * @param {Node} element DOM node to toggle class on.
 * @param {string} className Class to toggle.
 * @return {boolean} True if class was added, false if it was removed
 *     (in other words, whether element has the class after this function has
 *     been called).
 */
goog.dom.classes.toggle = function(element, className) {
  var add = !goog.dom.classes.has(element, className);
  goog.dom.classes.enable(element, className, add);
  return add;
};
// Copyright 2007 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Defines the goog.dom.TagName enum.  This enumerates
 * all HTML tag names specified in either the the W3C HTML 4.01 index of
 * elements or the HTML5 draft specification.
 *
 * References:
 * http://www.w3.org/TR/html401/index/elements.html
 * http://dev.w3.org/html5/spec/section-index.html
 *
 */
goog.provide('goog.dom.TagName');


/**
 * Enum of all html tag names specified by the W3C HTML4.01 and HTML5
 * specifications.
 * @enum {string}
 */
goog.dom.TagName = {
  A: 'A',
  ABBR: 'ABBR',
  ACRONYM: 'ACRONYM',
  ADDRESS: 'ADDRESS',
  APPLET: 'APPLET',
  AREA: 'AREA',
  ARTICLE: 'ARTICLE',
  ASIDE: 'ASIDE',
  AUDIO: 'AUDIO',
  B: 'B',
  BASE: 'BASE',
  BASEFONT: 'BASEFONT',
  BDI: 'BDI',
  BDO: 'BDO',
  BIG: 'BIG',
  BLOCKQUOTE: 'BLOCKQUOTE',
  BODY: 'BODY',
  BR: 'BR',
  BUTTON: 'BUTTON',
  CANVAS: 'CANVAS',
  CAPTION: 'CAPTION',
  CENTER: 'CENTER',
  CITE: 'CITE',
  CODE: 'CODE',
  COL: 'COL',
  COLGROUP: 'COLGROUP',
  COMMAND: 'COMMAND',
  DATA: 'DATA',
  DATALIST: 'DATALIST',
  DD: 'DD',
  DEL: 'DEL',
  DETAILS: 'DETAILS',
  DFN: 'DFN',
  DIALOG: 'DIALOG',
  DIR: 'DIR',
  DIV: 'DIV',
  DL: 'DL',
  DT: 'DT',
  EM: 'EM',
  EMBED: 'EMBED',
  FIELDSET: 'FIELDSET',
  FIGCAPTION: 'FIGCAPTION',
  FIGURE: 'FIGURE',
  FONT: 'FONT',
  FOOTER: 'FOOTER',
  FORM: 'FORM',
  FRAME: 'FRAME',
  FRAMESET: 'FRAMESET',
  H1: 'H1',
  H2: 'H2',
  H3: 'H3',
  H4: 'H4',
  H5: 'H5',
  H6: 'H6',
  HEAD: 'HEAD',
  HEADER: 'HEADER',
  HGROUP: 'HGROUP',
  HR: 'HR',
  HTML: 'HTML',
  I: 'I',
  IFRAME: 'IFRAME',
  IMG: 'IMG',
  INPUT: 'INPUT',
  INS: 'INS',
  ISINDEX: 'ISINDEX',
  KBD: 'KBD',
  KEYGEN: 'KEYGEN',
  LABEL: 'LABEL',
  LEGEND: 'LEGEND',
  LI: 'LI',
  LINK: 'LINK',
  MAP: 'MAP',
  MARK: 'MARK',
  MATH: 'MATH',
  MENU: 'MENU',
  META: 'META',
  METER: 'METER',
  NAV: 'NAV',
  NOFRAMES: 'NOFRAMES',
  NOSCRIPT: 'NOSCRIPT',
  OBJECT: 'OBJECT',
  OL: 'OL',
  OPTGROUP: 'OPTGROUP',
  OPTION: 'OPTION',
  OUTPUT: 'OUTPUT',
  P: 'P',
  PARAM: 'PARAM',
  PRE: 'PRE',
  PROGRESS: 'PROGRESS',
  Q: 'Q',
  RP: 'RP',
  RT: 'RT',
  RUBY: 'RUBY',
  S: 'S',
  SAMP: 'SAMP',
  SCRIPT: 'SCRIPT',
  SECTION: 'SECTION',
  SELECT: 'SELECT',
  SMALL: 'SMALL',
  SOURCE: 'SOURCE',
  SPAN: 'SPAN',
  STRIKE: 'STRIKE',
  STRONG: 'STRONG',
  STYLE: 'STYLE',
  SUB: 'SUB',
  SUMMARY: 'SUMMARY',
  SUP: 'SUP',
  SVG: 'SVG',
  TABLE: 'TABLE',
  TBODY: 'TBODY',
  TD: 'TD',
  TEXTAREA: 'TEXTAREA',
  TFOOT: 'TFOOT',
  TH: 'TH',
  THEAD: 'THEAD',
  TIME: 'TIME',
  TITLE: 'TITLE',
  TR: 'TR',
  TRACK: 'TRACK',
  TT: 'TT',
  U: 'U',
  UL: 'UL',
  VAR: 'VAR',
  VIDEO: 'VIDEO',
  WBR: 'WBR'
};
// Copyright 2010 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Browser capability checks for the dom package.
 *
 */


goog.provide('goog.dom.BrowserFeature');

goog.require('goog.userAgent');


/**
 * Enum of browser capabilities.
 * @enum {boolean}
 */
goog.dom.BrowserFeature = {
  /**
   * Whether attributes 'name' and 'type' can be added to an element after it's
   * created. False in Internet Explorer prior to version 9.
   */
  CAN_ADD_NAME_OR_TYPE_ATTRIBUTES: !goog.userAgent.IE ||
      goog.userAgent.isDocumentModeOrHigher(9),

  /**
   * Whether we can use element.children to access an element's Element
   * children. Available since Gecko 1.9.1, IE 9. (IE<9 also includes comment
   * nodes in the collection.)
   */
  CAN_USE_CHILDREN_ATTRIBUTE: !goog.userAgent.GECKO && !goog.userAgent.IE ||
      goog.userAgent.IE && goog.userAgent.isDocumentModeOrHigher(9) ||
      goog.userAgent.GECKO && goog.userAgent.isVersionOrHigher('1.9.1'),

  /**
   * Opera, Safari 3, and Internet Explorer 9 all support innerText but they
   * include text nodes in script and style tags. Not document-mode-dependent.
   */
  CAN_USE_INNER_TEXT: (
      goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('9')),

  /**
   * MSIE, Opera, and Safari>=4 support element.parentElement to access an
   * element's parent if it is an Element.
   */
  CAN_USE_PARENT_ELEMENT_PROPERTY: goog.userAgent.IE || goog.userAgent.OPERA ||
      goog.userAgent.WEBKIT,

  /**
   * Whether NoScope elements need a scoped element written before them in
   * innerHTML.
   * MSDN: http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx#1
   */
  INNER_HTML_NEEDS_SCOPED_ELEMENT: goog.userAgent.IE
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for manipulating the browser's Document Object Model
 * Inspiration taken *heavily* from mochikit (http://mochikit.com/).
 *
 * You can use {@link goog.dom.DomHelper} to create new dom helpers that refer
 * to a different document object.  This is useful if you are working with
 * frames or multiple windows.
 *
 */


// TODO(arv): Rename/refactor getTextContent and getRawTextContent. The problem
// is that getTextContent should mimic the DOM3 textContent. We should add a
// getInnerText (or getText) which tries to return the visible text, innerText.


goog.provide('goog.dom');
goog.provide('goog.dom.Appendable');
goog.provide('goog.dom.DomHelper');

goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom.BrowserFeature');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.TagName');
goog.require('goog.dom.classes');
goog.require('goog.functions');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * quirks mode.
 */
goog.define('goog.dom.ASSUME_QUIRKS_MODE', false);


/**
 * @define {boolean} Whether we know at compile time that the browser is in
 * standards compliance mode.
 */
goog.define('goog.dom.ASSUME_STANDARDS_MODE', false);


/**
 * Whether we know the compatibility mode at compile time.
 * @type {boolean}
 * @private
 */
goog.dom.COMPAT_MODE_KNOWN_ =
    goog.dom.ASSUME_QUIRKS_MODE || goog.dom.ASSUME_STANDARDS_MODE;


/**
 * Gets the DomHelper object for the document where the element resides.
 * @param {(Node|Window)=} opt_element If present, gets the DomHelper for this
 *     element.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.getDomHelper = function(opt_element) {
  return opt_element ?
      new goog.dom.DomHelper(goog.dom.getOwnerDocument(opt_element)) :
      (goog.dom.defaultDomHelper_ ||
          (goog.dom.defaultDomHelper_ = new goog.dom.DomHelper()));
};


/**
 * Cached default DOM helper.
 * @type {goog.dom.DomHelper}
 * @private
 */
goog.dom.defaultDomHelper_;


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.getDocument = function() {
  return document;
};


/**
 * Gets an element from the current document by element id.
 *
 * If an Element is passed in, it is returned.
 *
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.getElement = function(element) {
  return goog.dom.getElementHelper_(document, element);
};


/**
 * Gets an element by id from the given document (if present).
 * If an element is given, it is returned.
 * @param {!Document} doc
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The resulting element.
 * @private
 */
goog.dom.getElementHelper_ = function(doc, element) {
  return goog.isString(element) ?
      doc.getElementById(element) :
      element;
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.getRequiredElement = function(id) {
  return goog.dom.getRequiredElementHelper_(document, id);
};


/**
 * Helper function for getRequiredElementHelper functions, both static and
 * on DomHelper.  Asserts the element with the given id exists.
 * @param {!Document} doc
 * @param {string} id
 * @return {!Element} The element with the given ID, if it exists.
 * @private
 */
goog.dom.getRequiredElementHelper_ = function(doc, id) {
  // To prevent users passing in Elements as is permitted in getElement().
  goog.asserts.assertString(id);
  var element = goog.dom.getElementHelper_(doc, id);
  element = goog.asserts.assertElement(element,
      'No element found with id: ' + id);
  return element;
};


/**
 * Alias for getElement.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.getElement} instead.
 */
goog.dom.$ = goog.dom.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. This function
 * is a useful, if limited, way of collecting a list of DOM elements
 * with certain characteristics.  {@code goog.dom.query} offers a
 * more powerful and general solution which allows matching on CSS3
 * selector expressions, but at increased cost in code size. If all you
 * need is particular tags belonging to a single class, this function
 * is fast and sleek.
 *
 * Note that tag names are case sensitive in the SVG namespace, and this
 * function converts opt_tag to uppercase for comparisons. For queries in the
 * SVG namespace you should use querySelector or querySelectorAll instead.
 * https://bugzilla.mozilla.org/show_bug.cgi?id=963870
 * https://bugs.webkit.org/show_bug.cgi?id=83438
 *
 * @see {goog.dom.query}
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.getElementsByTagNameAndClass = function(opt_tag, opt_class, opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(document, opt_tag, opt_class,
                                                opt_el);
};


/**
 * Returns a static, array-like list of the elements with the provided
 * className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.getElementsByClass = function(className, opt_el) {
  var parent = opt_el || document;
  if (goog.dom.canUseQuerySelector_(parent)) {
    return parent.querySelectorAll('.' + className);
  }
  return goog.dom.getElementsByTagNameAndClass_(
      document, '*', className, opt_el);
};


/**
 * Returns the first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return {Element} The first item with the class name provided.
 */
goog.dom.getElementByClass = function(className, opt_el) {
  var parent = opt_el || document;
  var retVal = null;
  if (goog.dom.canUseQuerySelector_(parent)) {
    retVal = parent.querySelector('.' + className);
  } else {
    retVal = goog.dom.getElementsByTagNameAndClass_(
        document, '*', className, opt_el)[0];
  }
  return retVal || null;
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {!Element|!Document=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.getRequiredElementByClass = function(className, opt_root) {
  var retValue = goog.dom.getElementByClass(className, opt_root);
  return goog.asserts.assert(retValue,
      'No element found with className: ' + className);
};


/**
 * Prefer the standardized (http://www.w3.org/TR/selectors-api/), native and
 * fast W3C Selectors API.
 * @param {!(Element|Document)} parent The parent document object.
 * @return {boolean} whether or not we can use parent.querySelector* APIs.
 * @private
 */
goog.dom.canUseQuerySelector_ = function(parent) {
  return !!(parent.querySelectorAll && parent.querySelector);
};


/**
 * Helper for {@code getElementsByTagNameAndClass}.
 * @param {!Document} doc The document to get the elements in.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @private
 */
goog.dom.getElementsByTagNameAndClass_ = function(doc, opt_tag, opt_class,
                                                  opt_el) {
  var parent = opt_el || doc;
  var tagName = (opt_tag && opt_tag != '*') ? opt_tag.toUpperCase() : '';

  if (goog.dom.canUseQuerySelector_(parent) &&
      (tagName || opt_class)) {
    var query = tagName + (opt_class ? '.' + opt_class : '');
    return parent.querySelectorAll(query);
  }

  // Use the native getElementsByClassName if available, under the assumption
  // that even when the tag name is specified, there will be fewer elements to
  // filter through when going by class than by tag name
  if (opt_class && parent.getElementsByClassName) {
    var els = parent.getElementsByClassName(opt_class);

    if (tagName) {
      var arrayLike = {};
      var len = 0;

      // Filter for specific tags if requested.
      for (var i = 0, el; el = els[i]; i++) {
        if (tagName == el.nodeName) {
          arrayLike[len++] = el;
        }
      }
      arrayLike.length = len;

      return arrayLike;
    } else {
      return els;
    }
  }

  var els = parent.getElementsByTagName(tagName || '*');

  if (opt_class) {
    var arrayLike = {};
    var len = 0;
    for (var i = 0, el; el = els[i]; i++) {
      var className = el.className;
      // Check if className has a split function since SVG className does not.
      if (typeof className.split == 'function' &&
          goog.array.contains(className.split(/\s+/), opt_class)) {
        arrayLike[len++] = el;
      }
    }
    arrayLike.length = len;
    return arrayLike;
  } else {
    return els;
  }
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 * @deprecated Use {@link goog.dom.getElementsByTagNameAndClass} instead.
 */
goog.dom.$$ = goog.dom.getElementsByTagNameAndClass;


/**
 * Sets multiple properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.setProperties = function(element, properties) {
  goog.object.forEach(properties, function(val, key) {
    if (key == 'style') {
      element.style.cssText = val;
    } else if (key == 'class') {
      element.className = val;
    } else if (key == 'for') {
      element.htmlFor = val;
    } else if (key in goog.dom.DIRECT_ATTRIBUTE_MAP_) {
      element.setAttribute(goog.dom.DIRECT_ATTRIBUTE_MAP_[key], val);
    } else if (goog.string.startsWith(key, 'aria-') ||
        goog.string.startsWith(key, 'data-')) {
      element.setAttribute(key, val);
    } else {
      element[key] = val;
    }
  });
};


/**
 * Map of attributes that should be set using
 * element.setAttribute(key, val) instead of element[key] = val.  Used
 * by goog.dom.setProperties.
 *
 * @type {Object}
 * @private
 */
goog.dom.DIRECT_ATTRIBUTE_MAP_ = {
  'cellpadding': 'cellPadding',
  'cellspacing': 'cellSpacing',
  'colspan': 'colSpan',
  'frameborder': 'frameBorder',
  'height': 'height',
  'maxlength': 'maxLength',
  'role': 'role',
  'rowspan': 'rowSpan',
  'type': 'type',
  'usemap': 'useMap',
  'valign': 'vAlign',
  'width': 'width'
};


/**
 * Gets the dimensions of the viewport.
 *
 * Gecko Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of document.
 *
 * Gecko Backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * IE6/7 Standards mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of body element.
 *
 * docEl.clientHeight Height of viewport excluding scrollbar.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of document element.
 *
 * IE5 + IE6/7 Backwards compatible mode:
 * docEl.clientWidth  0.
 * win.innerWidth     Undefined.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight 0.
 * win.innerHeight    Undefined.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * Opera 9 Standards and backwards compatible mode:
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * win.innerWidth     Width of viewport including scrollbar.
 * body.clientWidth   Width of viewport excluding scrollbar.
 *
 * docEl.clientHeight Height of document.
 * win.innerHeight    Height of viewport including scrollbar.
 * body.clientHeight  Height of viewport excluding scrollbar.
 *
 * WebKit:
 * Safari 2
 * docEl.clientHeight Same as scrollHeight.
 * docEl.clientWidth  Same as innerWidth.
 * win.innerWidth     Width of viewport excluding scrollbar.
 * win.innerHeight    Height of the viewport including scrollbar.
 * frame.innerHeight  Height of the viewport exluding scrollbar.
 *
 * Safari 3 (tested in 522)
 *
 * docEl.clientWidth  Width of viewport excluding scrollbar.
 * docEl.clientHeight Height of viewport excluding scrollbar in strict mode.
 * body.clientHeight  Height of viewport excluding scrollbar in quirks mode.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.getViewportSize = function(opt_window) {
  // TODO(arv): This should not take an argument
  return goog.dom.getViewportSize_(opt_window || window);
};


/**
 * Helper for {@code getViewportSize}.
 * @param {Window} win The window to get the view port size for.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 * @private
 */
goog.dom.getViewportSize_ = function(win) {
  var doc = win.document;
  var el = goog.dom.isCss1CompatMode_(doc) ? doc.documentElement : doc.body;
  return new goog.math.Size(el.clientWidth, el.clientHeight);
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the current document.
 */
goog.dom.getDocumentHeight = function() {
  return goog.dom.getDocumentHeight_(window);
};


/**
 * Calculates the height of the document of the given window.
 *
 * Function code copied from the opensocial gadget api:
 *   gadgets.window.adjustHeight(opt_height)
 *
 * @private
 * @param {Window} win The window whose document height to retrieve.
 * @return {number} The height of the document of the given window.
 */
goog.dom.getDocumentHeight_ = function(win) {
  // NOTE(eae): This method will return the window size rather than the document
  // size in webkit quirks mode.
  var doc = win.document;
  var height = 0;

  if (doc) {
    // Calculating inner content height is hard and different between
    // browsers rendering in Strict vs. Quirks mode.  We use a combination of
    // three properties within document.body and document.documentElement:
    // - scrollHeight
    // - offsetHeight
    // - clientHeight
    // These values differ significantly between browsers and rendering modes.
    // But there are patterns.  It just takes a lot of time and persistence
    // to figure out.

    // If the window has no contents, it has no height. (In IE10,
    // document.body & document.documentElement are null in an empty iFrame.)
    var body = doc.body;
    var docEl = doc.documentElement;
    if (!body && !docEl) {
      return 0;
    }

    // Get the height of the viewport
    var vh = goog.dom.getViewportSize_(win).height;
    if (goog.dom.isCss1CompatMode_(doc) && docEl.scrollHeight) {
      // In Strict mode:
      // The inner content height is contained in either:
      //    document.documentElement.scrollHeight
      //    document.documentElement.offsetHeight
      // Based on studying the values output by different browsers,
      // use the value that's NOT equal to the viewport height found above.
      height = docEl.scrollHeight != vh ?
          docEl.scrollHeight : docEl.offsetHeight;
    } else {
      // In Quirks mode:
      // documentElement.clientHeight is equal to documentElement.offsetHeight
      // except in IE.  In most browsers, document.documentElement can be used
      // to calculate the inner content height.
      // However, in other browsers (e.g. IE), document.body must be used
      // instead.  How do we know which one to use?
      // If document.documentElement.clientHeight does NOT equal
      // document.documentElement.offsetHeight, then use document.body.
      var sh = docEl.scrollHeight;
      var oh = docEl.offsetHeight;
      if (docEl.clientHeight != oh) {
        sh = body.scrollHeight;
        oh = body.offsetHeight;
      }

      // Detect whether the inner content height is bigger or smaller
      // than the bounding box (viewport).  If bigger, take the larger
      // value.  If smaller, take the smaller value.
      if (sh > vh) {
        // Content is larger
        height = sh > oh ? sh : oh;
      } else {
        // Content is smaller
        height = sh < oh ? sh : oh;
      }
    }
  }

  return height;
};


/**
 * Gets the page scroll distance as a coordinate object.
 *
 * @param {Window=} opt_window Optional window element to test.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @deprecated Use {@link goog.dom.getDocumentScroll} instead.
 */
goog.dom.getPageScroll = function(opt_window) {
  var win = opt_window || goog.global || window;
  return goog.dom.getDomHelper(win.document).getDocumentScroll();
};


/**
 * Gets the document scroll distance as a coordinate object.
 *
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 */
goog.dom.getDocumentScroll = function() {
  return goog.dom.getDocumentScroll_(document);
};


/**
 * Helper for {@code getDocumentScroll}.
 *
 * @param {!Document} doc The document to get the scroll for.
 * @return {!goog.math.Coordinate} Object with values 'x' and 'y'.
 * @private
 */
goog.dom.getDocumentScroll_ = function(doc) {
  var el = goog.dom.getDocumentScrollElement_(doc);
  var win = goog.dom.getWindow_(doc);
  if (goog.userAgent.IE && goog.userAgent.isVersionOrHigher('10') &&
      win.pageYOffset != el.scrollTop) {
    // The keyboard on IE10 touch devices shifts the page using the pageYOffset
    // without modifying scrollTop. For this case, we want the body scroll
    // offsets.
    return new goog.math.Coordinate(el.scrollLeft, el.scrollTop);
  }
  return new goog.math.Coordinate(win.pageXOffset || el.scrollLeft,
      win.pageYOffset || el.scrollTop);
};


/**
 * Gets the document scroll element.
 * @return {!Element} Scrolling element.
 */
goog.dom.getDocumentScrollElement = function() {
  return goog.dom.getDocumentScrollElement_(document);
};


/**
 * Helper for {@code getDocumentScrollElement}.
 * @param {!Document} doc The document to get the scroll element for.
 * @return {!Element} Scrolling element.
 * @private
 */
goog.dom.getDocumentScrollElement_ = function(doc) {
  // WebKit needs body.scrollLeft in both quirks mode and strict mode. We also
  // default to the documentElement if the document does not have a body (e.g.
  // a SVG document).
  if (!goog.userAgent.WEBKIT && goog.dom.isCss1CompatMode_(doc)) {
    return doc.documentElement;
  }
  return doc.body || doc.documentElement;
};


/**
 * Gets the window object associated with the given document.
 *
 * @param {Document=} opt_doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.getWindow = function(opt_doc) {
  // TODO(arv): This should not take an argument.
  return opt_doc ? goog.dom.getWindow_(opt_doc) : window;
};


/**
 * Helper for {@code getWindow}.
 *
 * @param {!Document} doc  Document object to get window for.
 * @return {!Window} The window associated with the given document.
 * @private
 */
goog.dom.getWindow_ = function(doc) {
  return doc.parentWindow || doc.defaultView;
};


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * @param {string} tagName Tag to create.
 * @param {(Object|Array.<string>|string)=} opt_attributes If object, then a map
 *     of name-value pairs for attributes. If a string, then this is the
 *     className of the new element. If an array, the elements will be joined
 *     together as the className of the new element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or NodeList,i
 *     its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.createDom = function(tagName, opt_attributes, var_args) {
  return goog.dom.createDom_(document, arguments);
};


/**
 * Helper for {@code createDom}.
 * @param {!Document} doc The document to create the DOM in.
 * @param {!Arguments} args Argument object passed from the callers. See
 *     {@code goog.dom.createDom} for details.
 * @return {!Element} Reference to a DOM node.
 * @private
 */
goog.dom.createDom_ = function(doc, args) {
  var tagName = args[0];
  var attributes = args[1];

  // Internet Explorer is dumb: http://msdn.microsoft.com/workshop/author/
  //                            dhtml/reference/properties/name_2.asp
  // Also does not allow setting of 'type' attribute on 'input' or 'button'.
  if (!goog.dom.BrowserFeature.CAN_ADD_NAME_OR_TYPE_ATTRIBUTES && attributes &&
      (attributes.name || attributes.type)) {
    var tagNameArr = ['<', tagName];
    if (attributes.name) {
      tagNameArr.push(' name="', goog.string.htmlEscape(attributes.name),
                      '"');
    }
    if (attributes.type) {
      tagNameArr.push(' type="', goog.string.htmlEscape(attributes.type),
                      '"');

      // Clone attributes map to remove 'type' without mutating the input.
      var clone = {};
      goog.object.extend(clone, attributes);

      // JSCompiler can't see how goog.object.extend added this property,
      // because it was essentially added by reflection.
      // So it needs to be quoted.
      delete clone['type'];

      attributes = clone;
    }
    tagNameArr.push('>');
    tagName = tagNameArr.join('');
  }

  var element = doc.createElement(tagName);

  if (attributes) {
    if (goog.isString(attributes)) {
      element.className = attributes;
    } else if (goog.isArray(attributes)) {
      goog.dom.classes.add.apply(null, [element].concat(attributes));
    } else {
      goog.dom.setProperties(element, attributes);
    }
  }

  if (args.length > 2) {
    goog.dom.append_(doc, element, args, 2);
  }

  return element;
};


/**
 * Appends a node with text or other nodes.
 * @param {!Document} doc The document to create new nodes in.
 * @param {!Node} parent The node to append nodes to.
 * @param {!Arguments} args The values to add. See {@code goog.dom.append}.
 * @param {number} startIndex The index of the array to start from.
 * @private
 */
goog.dom.append_ = function(doc, parent, args, startIndex) {
  function childHandler(child) {
    // TODO(user): More coercion, ala MochiKit?
    if (child) {
      parent.appendChild(goog.isString(child) ?
          doc.createTextNode(child) : child);
    }
  }

  for (var i = startIndex; i < args.length; i++) {
    var arg = args[i];
    // TODO(attila): Fix isArrayLike to return false for a text node.
    if (goog.isArrayLike(arg) && !goog.dom.isNodeLike(arg)) {
      // If the argument is a node list, not a real array, use a clone,
      // because forEach can't be used to mutate a NodeList.
      goog.array.forEach(goog.dom.isNodeList(arg) ?
          goog.array.toArray(arg) : arg,
          childHandler);
    } else {
      childHandler(arg);
    }
  }
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(string|Object)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...(Object|string|Array|NodeList)} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array, its
 *     children will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.createDom} instead.
 */
goog.dom.$dom = goog.dom.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.createElement = function(name) {
  return document.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.createTextNode = function(content) {
  return document.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.createTable = function(rows, columns, opt_fillWithNbsp) {
  return goog.dom.createTable_(document, rows, columns, !!opt_fillWithNbsp);
};


/**
 * Create a table.
 * @param {!Document} doc Document object to use to create the table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean} fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 * @private
 */
goog.dom.createTable_ = function(doc, rows, columns, fillWithNbsp) {
  var rowHtml = ['<tr>'];
  for (var i = 0; i < columns; i++) {
    rowHtml.push(fillWithNbsp ? '<td>&nbsp;</td>' : '<td></td>');
  }
  rowHtml.push('</tr>');
  rowHtml = rowHtml.join('');
  var totalHtml = ['<table>'];
  for (i = 0; i < rows; i++) {
    totalHtml.push(rowHtml);
  }
  totalHtml.push('</table>');

  var elem = doc.createElement(goog.dom.TagName.DIV);
  elem.innerHTML = totalHtml.join('');
  return /** @type {!Element} */ (elem.removeChild(elem.firstChild));
};


/**
 * Converts an HTML string into a document fragment. The string must be
 * sanitized in order to avoid cross-site scripting. For example
 * {@code goog.dom.htmlToDocumentFragment('&lt;img src=x onerror=alert(0)&gt;')}
 * triggers an alert in all browsers, even if the returned document fragment
 * is thrown away immediately.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 */
goog.dom.htmlToDocumentFragment = function(htmlString) {
  return goog.dom.htmlToDocumentFragment_(document, htmlString);
};


/**
 * Helper for {@code htmlToDocumentFragment}.
 *
 * @param {!Document} doc The document.
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting document fragment.
 * @private
 */
goog.dom.htmlToDocumentFragment_ = function(doc, htmlString) {
  var tempDiv = doc.createElement('div');
  if (goog.dom.BrowserFeature.INNER_HTML_NEEDS_SCOPED_ELEMENT) {
    tempDiv.innerHTML = '<br>' + htmlString;
    tempDiv.removeChild(tempDiv.firstChild);
  } else {
    tempDiv.innerHTML = htmlString;
  }
  if (tempDiv.childNodes.length == 1) {
    return /** @type {!Node} */ (tempDiv.removeChild(tempDiv.firstChild));
  } else {
    var fragment = doc.createDocumentFragment();
    while (tempDiv.firstChild) {
      fragment.appendChild(tempDiv.firstChild);
    }
    return fragment;
  }
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.isCss1CompatMode = function() {
  return goog.dom.isCss1CompatMode_(document);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @param {Document} doc The document to check.
 * @return {boolean} True if in CSS1-compatible mode.
 * @private
 */
goog.dom.isCss1CompatMode_ = function(doc) {
  if (goog.dom.COMPAT_MODE_KNOWN_) {
    return goog.dom.ASSUME_STANDARDS_MODE;
  }

  return doc.compatMode == 'CSS1Compat';
};


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * IE natively supports node.canHaveChildren but has inconsistent behavior.
 * Prior to IE8 the base tag allows children and in IE9 all nodes return true
 * for canHaveChildren.
 *
 * In practice all non-IE browsers allow you to add children to any node, but
 * the behavior is inconsistent:
 *
 * <pre>
 *   var a = document.createElement('br');
 *   a.appendChild(document.createTextNode('foo'));
 *   a.appendChild(document.createTextNode('bar'));
 *   console.log(a.childNodes.length);  // 2
 *   console.log(a.innerHTML);  // Chrome: "", IE9: "foobar", FF3.5: "foobar"
 * </pre>
 *
 * For more information, see:
 * http://dev.w3.org/html5/markup/syntax.html#syntax-elements
 *
 * TODO(user): Rename shouldAllowChildren() ?
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.canHaveChildren = function(node) {
  if (node.nodeType != goog.dom.NodeType.ELEMENT) {
    return false;
  }
  switch (node.tagName) {
    case goog.dom.TagName.APPLET:
    case goog.dom.TagName.AREA:
    case goog.dom.TagName.BASE:
    case goog.dom.TagName.BR:
    case goog.dom.TagName.COL:
    case goog.dom.TagName.COMMAND:
    case goog.dom.TagName.EMBED:
    case goog.dom.TagName.FRAME:
    case goog.dom.TagName.HR:
    case goog.dom.TagName.IMG:
    case goog.dom.TagName.INPUT:
    case goog.dom.TagName.IFRAME:
    case goog.dom.TagName.ISINDEX:
    case goog.dom.TagName.KEYGEN:
    case goog.dom.TagName.LINK:
    case goog.dom.TagName.NOFRAMES:
    case goog.dom.TagName.NOSCRIPT:
    case goog.dom.TagName.META:
    case goog.dom.TagName.OBJECT:
    case goog.dom.TagName.PARAM:
    case goog.dom.TagName.SCRIPT:
    case goog.dom.TagName.SOURCE:
    case goog.dom.TagName.STYLE:
    case goog.dom.TagName.TRACK:
    case goog.dom.TagName.WBR:
      return false;
  }
  return true;
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.appendChild = function(parent, child) {
  parent.appendChild(child);
};


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.append = function(parent, var_args) {
  goog.dom.append_(goog.dom.getOwnerDocument(parent), parent, arguments, 1);
};


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.removeChildren = function(node) {
  // Note: Iterations over live collections can be slow, this is the fastest
  // we could find. The double parenthesis are used to prevent JsCompiler and
  // strict warnings.
  var child;
  while ((child = node.firstChild)) {
    node.removeChild(child);
  }
};


/**
 * Inserts a new node before an existing reference node (i.e. as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.insertSiblingBefore = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode);
  }
};


/**
 * Inserts a new node after an existing reference node (i.e. as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.insertSiblingAfter = function(newNode, refNode) {
  if (refNode.parentNode) {
    refNode.parentNode.insertBefore(newNode, refNode.nextSibling);
  }
};


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.insertChildAt = function(parent, child, index) {
  // Note that if the second argument is null, insertBefore
  // will append the child at the end of the list of children.
  parent.insertBefore(child, parent.childNodes[index] || null);
};


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.removeNode = function(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.replaceNode = function(newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * Does nothing if the element is not in the document.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children; or undefined, if the element was not in the document
 *     to begin with.
 */
goog.dom.flattenElement = function(element) {
  var child, parent = element.parentNode;
  if (parent && parent.nodeType != goog.dom.NodeType.DOCUMENT_FRAGMENT) {
    // Use IE DOM method (supported by Opera too) if available
    if (element.removeNode) {
      return /** @type {Element} */ (element.removeNode(false));
    } else {
      // Move all children of the original node up one level.
      while ((child = element.firstChild)) {
        parent.insertBefore(child, element);
      }

      // Detach the original element.
      return /** @type {Element} */ (goog.dom.removeNode(element));
    }
  }
};


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.getChildren = function(element) {
  // We check if the children attribute is supported for child elements
  // since IE8 misuses the attribute by also including comments.
  if (goog.dom.BrowserFeature.CAN_USE_CHILDREN_ATTRIBUTE &&
      element.children != undefined) {
    return element.children;
  }
  // Fall back to manually filtering the element's child nodes.
  return goog.array.filter(element.childNodes, function(node) {
    return node.nodeType == goog.dom.NodeType.ELEMENT;
  });
};


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.getFirstElementChild = function(node) {
  if (node.firstElementChild != undefined) {
    return /** @type {Element} */(node).firstElementChild;
  }
  return goog.dom.getNextElementNode_(node.firstChild, true);
};


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.getLastElementChild = function(node) {
  if (node.lastElementChild != undefined) {
    return /** @type {Element} */(node).lastElementChild;
  }
  return goog.dom.getNextElementNode_(node.lastChild, false);
};


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.getNextElementSibling = function(node) {
  if (node.nextElementSibling != undefined) {
    return /** @type {Element} */(node).nextElementSibling;
  }
  return goog.dom.getNextElementNode_(node.nextSibling, true);
};


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.getPreviousElementSibling = function(node) {
  if (node.previousElementSibling != undefined) {
    return /** @type {Element} */(node).previousElementSibling;
  }
  return goog.dom.getNextElementNode_(node.previousSibling, false);
};


/**
 * Returns the first node that is an element in the specified direction,
 * starting with {@code node}.
 * @param {Node} node The node to get the next element from.
 * @param {boolean} forward Whether to look forwards or backwards.
 * @return {Element} The first element.
 * @private
 */
goog.dom.getNextElementNode_ = function(node, forward) {
  while (node && node.nodeType != goog.dom.NodeType.ELEMENT) {
    node = forward ? node.nextSibling : node.previousSibling;
  }

  return /** @type {Element} */ (node);
};


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.getNextNode = function(node) {
  if (!node) {
    return null;
  }

  if (node.firstChild) {
    return node.firstChild;
  }

  while (node && !node.nextSibling) {
    node = node.parentNode;
  }

  return node ? node.nextSibling : null;
};


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.getPreviousNode = function(node) {
  if (!node) {
    return null;
  }

  if (!node.previousSibling) {
    return node.parentNode;
  }

  node = node.previousSibling;
  while (node && node.lastChild) {
    node = node.lastChild;
  }

  return node;
};


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.isNodeLike = function(obj) {
  return goog.isObject(obj) && obj.nodeType > 0;
};


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.isElement = function(obj) {
  return goog.isObject(obj) && obj.nodeType == goog.dom.NodeType.ELEMENT;
};


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.isWindow = function(obj) {
  return goog.isObject(obj) && obj['window'] == obj;
};


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.getParentElement = function(element) {
  var parent;
  if (goog.dom.BrowserFeature.CAN_USE_PARENT_ELEMENT_PROPERTY) {
    var isIe9 = goog.userAgent.IE &&
        goog.userAgent.isVersionOrHigher('9') &&
        !goog.userAgent.isVersionOrHigher('10');
    // SVG elements in IE9 can't use the parentElement property.
    // goog.global['SVGElement'] is not defined in IE9 quirks mode.
    if (!(isIe9 && goog.global['SVGElement'] &&
        element instanceof goog.global['SVGElement'])) {
      parent = element.parentElement;
      if (parent) {
        return parent;
      }
    }
  }
  parent = element.parentNode;
  return goog.dom.isElement(parent) ? /** @type {!Element} */ (parent) : null;
};


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.contains = function(parent, descendant) {
  // We use browser specific methods for this if available since it is faster
  // that way.

  // IE DOM
  if (parent.contains && descendant.nodeType == goog.dom.NodeType.ELEMENT) {
    return parent == descendant || parent.contains(descendant);
  }

  // W3C DOM Level 3
  if (typeof parent.compareDocumentPosition != 'undefined') {
    return parent == descendant ||
        Boolean(parent.compareDocumentPosition(descendant) & 16);
  }

  // W3C DOM Level 1
  while (descendant && parent != descendant) {
    descendant = descendant.parentNode;
  }
  return descendant == parent;
};


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.compareNodeOrder = function(node1, node2) {
  // Fall out quickly for equality.
  if (node1 == node2) {
    return 0;
  }

  // Use compareDocumentPosition where available
  if (node1.compareDocumentPosition) {
    // 4 is the bitmask for FOLLOWS.
    return node1.compareDocumentPosition(node2) & 2 ? 1 : -1;
  }

  // Special case for document nodes on IE 7 and 8.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    if (node1.nodeType == goog.dom.NodeType.DOCUMENT) {
      return -1;
    }
    if (node2.nodeType == goog.dom.NodeType.DOCUMENT) {
      return 1;
    }
  }

  // Process in IE using sourceIndex - we check to see if the first node has
  // a source index or if its parent has one.
  if ('sourceIndex' in node1 ||
      (node1.parentNode && 'sourceIndex' in node1.parentNode)) {
    var isElement1 = node1.nodeType == goog.dom.NodeType.ELEMENT;
    var isElement2 = node2.nodeType == goog.dom.NodeType.ELEMENT;

    if (isElement1 && isElement2) {
      return node1.sourceIndex - node2.sourceIndex;
    } else {
      var parent1 = node1.parentNode;
      var parent2 = node2.parentNode;

      if (parent1 == parent2) {
        return goog.dom.compareSiblingOrder_(node1, node2);
      }

      if (!isElement1 && goog.dom.contains(parent1, node2)) {
        return -1 * goog.dom.compareParentsDescendantNodeIe_(node1, node2);
      }


      if (!isElement2 && goog.dom.contains(parent2, node1)) {
        return goog.dom.compareParentsDescendantNodeIe_(node2, node1);
      }

      return (isElement1 ? node1.sourceIndex : parent1.sourceIndex) -
             (isElement2 ? node2.sourceIndex : parent2.sourceIndex);
    }
  }

  // For Safari, we compare ranges.
  var doc = goog.dom.getOwnerDocument(node1);

  var range1, range2;
  range1 = doc.createRange();
  range1.selectNode(node1);
  range1.collapse(true);

  range2 = doc.createRange();
  range2.selectNode(node2);
  range2.collapse(true);

  return range1.compareBoundaryPoints(goog.global['Range'].START_TO_END,
      range2);
};


/**
 * Utility function to compare the position of two nodes, when
 * {@code textNode}'s parent is an ancestor of {@code node}.  If this entry
 * condition is not met, this function will attempt to reference a null object.
 * @param {Node} textNode The textNode to compare.
 * @param {Node} node The node to compare.
 * @return {number} -1 if node is before textNode, +1 otherwise.
 * @private
 */
goog.dom.compareParentsDescendantNodeIe_ = function(textNode, node) {
  var parent = textNode.parentNode;
  if (parent == node) {
    // If textNode is a child of node, then node comes first.
    return -1;
  }
  var sibling = node;
  while (sibling.parentNode != parent) {
    sibling = sibling.parentNode;
  }
  return goog.dom.compareSiblingOrder_(sibling, textNode);
};


/**
 * Utility function to compare the position of two nodes known to be non-equal
 * siblings.
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} -1 if node1 is before node2, +1 otherwise.
 * @private
 */
goog.dom.compareSiblingOrder_ = function(node1, node2) {
  var s = node2;
  while ((s = s.previousSibling)) {
    if (s == node1) {
      // We just found node1 before node2.
      return -1;
    }
  }

  // Since we didn't find it, node1 must be after node2.
  return 1;
};


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.findCommonAncestor = function(var_args) {
  var i, count = arguments.length;
  if (!count) {
    return null;
  } else if (count == 1) {
    return arguments[0];
  }

  var paths = [];
  var minLength = Infinity;
  for (i = 0; i < count; i++) {
    // Compute the list of ancestors.
    var ancestors = [];
    var node = arguments[i];
    while (node) {
      ancestors.unshift(node);
      node = node.parentNode;
    }

    // Save the list for comparison.
    paths.push(ancestors);
    minLength = Math.min(minLength, ancestors.length);
  }
  var output = null;
  for (i = 0; i < minLength; i++) {
    var first = paths[0][i];
    for (var j = 1; j < count; j++) {
      if (first != paths[j][i]) {
        return output;
      }
    }
    output = first;
  }
  return output;
};


/**
 * Returns the owner document for a node.
 * @param {Node|Window} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.getOwnerDocument = function(node) {
  // TODO(nnaze): Update param signature to be non-nullable.
  goog.asserts.assert(node, 'Node cannot be null or undefined.');
  return /** @type {!Document} */ (
      node.nodeType == goog.dom.NodeType.DOCUMENT ? node :
      node.ownerDocument || node.document);
};


/**
 * Cross-browser function for getting the document element of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {!Document} The frame content document.
 */
goog.dom.getFrameContentDocument = function(frame) {
  var doc = frame.contentDocument || frame.contentWindow.document;
  return doc;
};


/**
 * Cross-browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.getFrameContentWindow = function(frame) {
  return frame.contentWindow ||
      goog.dom.getWindow(goog.dom.getFrameContentDocument(frame));
};


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 */
goog.dom.setTextContent = function(node, text) {
  goog.asserts.assert(node != null,
      'goog.dom.setTextContent expects a non-null value for node');

  if ('textContent' in node) {
    node.textContent = text;
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    node.data = text;
  } else if (node.firstChild &&
             node.firstChild.nodeType == goog.dom.NodeType.TEXT) {
    // If the first child is a text node we just change its data and remove the
    // rest of the children.
    while (node.lastChild != node.firstChild) {
      node.removeChild(node.lastChild);
    }
    node.firstChild.data = text;
  } else {
    goog.dom.removeChildren(node);
    var doc = goog.dom.getOwnerDocument(node);
    node.appendChild(doc.createTextNode(String(text)));
  }
};


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.getOuterHtml = function(element) {
  // IE, Opera and WebKit all have outerHTML.
  if ('outerHTML' in element) {
    return element.outerHTML;
  } else {
    var doc = goog.dom.getOwnerDocument(element);
    var div = doc.createElement('div');
    div.appendChild(element.cloneNode(true));
    return div.innerHTML;
  }
};


/**
 * Finds the first descendant node that matches the filter function, using
 * a depth first search. This function offers the most general purpose way
 * of finding a matching element. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.
 * @see goog.dom.query
 *
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.findNode = function(root, p) {
  var rv = [];
  var found = goog.dom.findNodes_(root, p, rv, true);
  return found ? rv[0] : undefined;
};


/**
 * Finds all the descendant nodes that match the filter function, using a
 * a depth first search. This function offers the most general-purpose way
 * of finding a set of matching elements. You may also wish to consider
 * {@code goog.dom.query} which can express many matching criteria using
 * CSS selector expressions. These expressions often result in a more
 * compact representation of the desired result.

 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {!Array.<!Node>} The found nodes or an empty array if none are found.
 */
goog.dom.findNodes = function(root, p) {
  var rv = [];
  goog.dom.findNodes_(root, p, rv, false);
  return rv;
};


/**
 * Finds the first or all the descendant nodes that match the filter function,
 * using a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @param {!Array.<!Node>} rv The found nodes are added to this array.
 * @param {boolean} findOne If true we exit after the first found node.
 * @return {boolean} Whether the search is complete or not. True in case findOne
 *     is true and the node is found. False otherwise.
 * @private
 */
goog.dom.findNodes_ = function(root, p, rv, findOne) {
  if (root != null) {
    var child = root.firstChild;
    while (child) {
      if (p(child)) {
        rv.push(child);
        if (findOne) {
          return true;
        }
      }
      if (goog.dom.findNodes_(child, p, rv, findOne)) {
        return true;
      }
      child = child.nextSibling;
    }
  }
  return false;
};


/**
 * Map of tags whose content to ignore when calculating text length.
 * @type {Object}
 * @private
 */
goog.dom.TAGS_TO_IGNORE_ = {
  'SCRIPT': 1,
  'STYLE': 1,
  'HEAD': 1,
  'IFRAME': 1,
  'OBJECT': 1
};


/**
 * Map of tags which have predefined values with regard to whitespace.
 * @type {Object}
 * @private
 */
goog.dom.PREDEFINED_TAG_VALUES_ = {'IMG': ' ', 'BR': '\n'};


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 * @see http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
 */
goog.dom.isFocusableTabIndex = function(element) {
  return goog.dom.hasSpecifiedTabIndex_(element) &&
         goog.dom.isTabIndexFocusable_(element);
};


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.setFocusableTabIndex = function(element, enable) {
  if (enable) {
    element.tabIndex = 0;
  } else {
    // Set tabIndex to -1 first, then remove it. This is a workaround for
    // Safari (confirmed in version 4 on Windows). When removing the attribute
    // without setting it to -1 first, the element remains keyboard focusable
    // despite not having a tabIndex attribute anymore.
    element.tabIndex = -1;
    element.removeAttribute('tabIndex'); // Must be camelCase!
  }
};


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.isFocusable = function(element) {
  var focusable;
  // Some elements can have unspecified tab index and still receive focus.
  if (goog.dom.nativelySupportsFocus_(element)) {
    // Make sure the element is not disabled ...
    focusable = !element.disabled &&
        // ... and if a tab index is specified, it allows focus.
        (!goog.dom.hasSpecifiedTabIndex_(element) ||
         goog.dom.isTabIndexFocusable_(element));
  } else {
    focusable = goog.dom.isFocusableTabIndex(element);
  }

  // IE requires elements to be visible in order to focus them.
  return focusable && goog.userAgent.IE ?
             goog.dom.hasNonZeroBoundingRect_(element) : focusable;
};


/**
 * Returns true if the element has a specified tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a specified tab index.
 * @private
 */
goog.dom.hasSpecifiedTabIndex_ = function(element) {
  // IE returns 0 for an unset tabIndex, so we must use getAttributeNode(),
  // which returns an object with a 'specified' property if tabIndex is
  // specified.  This works on other browsers, too.
  var attrNode = element.getAttributeNode('tabindex'); // Must be lowercase!
  return goog.isDefAndNotNull(attrNode) && attrNode.specified;
};


/**
 * Returns true if the element's tab index allows the element to be focused.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element's tab index allows focus.
 * @private
 */
goog.dom.isTabIndexFocusable_ = function(element) {
  var index = element.tabIndex;
  // NOTE: IE9 puts tabIndex in 16-bit int, e.g. -2 is 65534.
  return goog.isNumber(index) && index >= 0 && index < 32768;
};


/**
 * Returns true if the element is focusable even when tabIndex is not set.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element natively supports focus.
 * @private
 */
goog.dom.nativelySupportsFocus_ = function(element) {
  return element.tagName == goog.dom.TagName.A ||
         element.tagName == goog.dom.TagName.INPUT ||
         element.tagName == goog.dom.TagName.TEXTAREA ||
         element.tagName == goog.dom.TagName.SELECT ||
         element.tagName == goog.dom.TagName.BUTTON;
};


/**
 * Returns true if the element has a bounding rectangle that would be visible
 * (i.e. its width and height are greater than zero).
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a non-zero bounding rectangle.
 * @private
 */
goog.dom.hasNonZeroBoundingRect_ = function(element) {
  var rect = goog.isFunction(element['getBoundingClientRect']) ?
      element.getBoundingClientRect() :
      {'height': element.offsetHeight, 'width': element.offsetWidth};
  return goog.isDefAndNotNull(rect) && rect.height > 0 && rect.width > 0;
};


/**
 * Returns the text content of the current node, without markup and invisible
 * symbols. New lines are stripped and whitespace is collapsed,
 * such that each character would be visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.getTextContent = function(node) {
  var textContent;
  // Note(arv): IE9, Opera, and Safari 3 support innerText but they include
  // text nodes in script tags. So we revert to use a user agent test here.
  if (goog.dom.BrowserFeature.CAN_USE_INNER_TEXT && ('innerText' in node)) {
    textContent = goog.string.canonicalizeNewlines(node.innerText);
    // Unfortunately .innerText() returns text with &shy; symbols
    // We need to filter it out and then remove duplicate whitespaces
  } else {
    var buf = [];
    goog.dom.getTextContent_(node, buf, true);
    textContent = buf.join('');
  }

  // Strip &shy; entities. goog.format.insertWordBreaks inserts them in Opera.
  textContent = textContent.replace(/ \xAD /g, ' ').replace(/\xAD/g, '');
  // Strip &#8203; entities. goog.format.insertWordBreaks inserts them in IE8.
  textContent = textContent.replace(/\u200B/g, '');

  // Skip this replacement on old browsers with working innerText, which
  // automatically turns &nbsp; into ' ' and / +/ into ' ' when reading
  // innerText.
  if (!goog.dom.BrowserFeature.CAN_USE_INNER_TEXT) {
    textContent = textContent.replace(/ +/g, ' ');
  }
  if (textContent != ' ') {
    textContent = textContent.replace(/^\s*/, '');
  }

  return textContent;
};


/**
 * Returns the text content of the current node, without markup.
 *
 * Unlike {@code getTextContent} this method does not collapse whitespaces
 * or normalize lines breaks.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The raw text content.
 */
goog.dom.getRawTextContent = function(node) {
  var buf = [];
  goog.dom.getTextContent_(node, buf, false);

  return buf.join('');
};


/**
 * Recursive support function for text content retrieval.
 *
 * @param {Node} node The node from which we are getting content.
 * @param {Array} buf string buffer.
 * @param {boolean} normalizeWhitespace Whether to normalize whitespace.
 * @private
 */
goog.dom.getTextContent_ = function(node, buf, normalizeWhitespace) {
  if (node.nodeName in goog.dom.TAGS_TO_IGNORE_) {
    // ignore certain tags
  } else if (node.nodeType == goog.dom.NodeType.TEXT) {
    if (normalizeWhitespace) {
      buf.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      buf.push(node.nodeValue);
    }
  } else if (node.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
    buf.push(goog.dom.PREDEFINED_TAG_VALUES_[node.nodeName]);
  } else {
    var child = node.firstChild;
    while (child) {
      goog.dom.getTextContent_(child, buf, normalizeWhitespace);
      child = child.nextSibling;
    }
  }
};


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.getNodeTextLength = function(node) {
  return goog.dom.getTextContent(node).length;
};


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by goog.dom.getNodeTextLength.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent The node relative to which the offset will
 *     be calculated. Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.getNodeTextOffset = function(node, opt_offsetParent) {
  var root = opt_offsetParent || goog.dom.getOwnerDocument(node).body;
  var buf = [];
  while (node && node != root) {
    var cur = node;
    while ((cur = cur.previousSibling)) {
      buf.unshift(goog.dom.getTextContent(cur));
    }
    node = node.parentNode;
  }
  // Trim left to deal with FF cases when there might be line breaks and empty
  // nodes at the front of the text
  return goog.string.trimLeft(buf.join('')).replace(/ +/g, ' ').length;
};


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.getNodeAtOffset = function(parent, offset, opt_result) {
  var stack = [parent], pos = 0, cur = null;
  while (stack.length > 0 && pos < offset) {
    cur = stack.pop();
    if (cur.nodeName in goog.dom.TAGS_TO_IGNORE_) {
      // ignore certain tags
    } else if (cur.nodeType == goog.dom.NodeType.TEXT) {
      var text = cur.nodeValue.replace(/(\r\n|\r|\n)/g, '').replace(/ +/g, ' ');
      pos += text.length;
    } else if (cur.nodeName in goog.dom.PREDEFINED_TAG_VALUES_) {
      pos += goog.dom.PREDEFINED_TAG_VALUES_[cur.nodeName].length;
    } else {
      for (var i = cur.childNodes.length - 1; i >= 0; i--) {
        stack.push(cur.childNodes[i]);
      }
    }
  }
  if (goog.isObject(opt_result)) {
    opt_result.remainder = cur ? cur.nodeValue.length + offset - pos - 1 : 0;
    opt_result.node = cur;
  }

  return cur;
};


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.isNodeList = function(val) {
  // TODO(attila): Now the isNodeList is part of goog.dom we can use
  // goog.userAgent to make this simpler.
  // A NodeList must have a length property of type 'number' on all platforms.
  if (val && typeof val.length == 'number') {
    // A NodeList is an object everywhere except Safari, where it's a function.
    if (goog.isObject(val)) {
      // A NodeList must have an item function (on non-IE platforms) or an item
      // property of type 'string' (on IE).
      return typeof val.item == 'function' || typeof val.item == 'string';
    } else if (goog.isFunction(val)) {
      // On Safari, a NodeList is a function with an item property that is also
      // a function.
      return typeof val.item == 'function';
    }
  }

  // Not a NodeList.
  return false;
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.getAncestorByTagNameAndClass = function(element, opt_tag, opt_class) {
  if (!opt_tag && !opt_class) {
    return null;
  }
  var tagName = opt_tag ? opt_tag.toUpperCase() : null;
  return /** @type {Element} */ (goog.dom.getAncestor(element,
      function(node) {
        return (!tagName || node.nodeName == tagName) &&
               (!opt_class || goog.dom.classes.has(node, opt_class));
      }, true));
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} className The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.getAncestorByClass = function(element, className) {
  return goog.dom.getAncestorByTagNameAndClass(element, null, className);
};


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.getAncestor = function(
    element, matcher, opt_includeNode, opt_maxSearchSteps) {
  if (!opt_includeNode) {
    element = element.parentNode;
  }
  var ignoreSearchSteps = opt_maxSearchSteps == null;
  var steps = 0;
  while (element && (ignoreSearchSteps || steps <= opt_maxSearchSteps)) {
    if (matcher(element)) {
      return element;
    }
    element = element.parentNode;
    steps++;
  }
  // Reached the root of the DOM without a match
  return null;
};


/**
 * Determines the active element in the given document.
 * @param {Document} doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.getActiveElement = function(doc) {
  try {
    return doc && doc.activeElement;
  } catch (e) {
    // NOTE(nicksantos): Sometimes, evaluating document.activeElement in IE
    // throws an exception. I'm not 100% sure why, but I suspect it chokes
    // on document.activeElement if the activeElement has been recently
    // removed from the DOM by a JS operation.
    //
    // We assume that an exception here simply means
    // "there is no active element."
  }

  return null;
};


/**
 * @private {number} Cached version of the devicePixelRatio.
 */
goog.dom.devicePixelRatio_;


/**
 * Gives the devicePixelRatio, or attempts to determine if not present.
 *
 * By default, this is the same value given by window.devicePixelRatio. If
 * devicePixelRatio is not defined, the ratio is calculated with
 * window.matchMedia, if present. Otherwise, gives 1.0.
 *
 * This function is cached so that the pixel ratio is calculated only once
 * and only calculated when first requested.
 *
 * @return {number} The number of actual pixels per virtual pixel.
 */
goog.dom.getPixelRatio = goog.functions.cacheReturnValue(function() {
  var win = goog.dom.getWindow();

  // devicePixelRatio does not work on Mobile firefox.
  // TODO(user): Enable this check on a known working mobile Gecko version.
  // Filed a bug: https://bugzilla.mozilla.org/show_bug.cgi?id=896804
  var isFirefoxMobile = goog.userAgent.GECKO && goog.userAgent.MOBILE;

  if (goog.isDef(win.devicePixelRatio) && !isFirefoxMobile) {
    return win.devicePixelRatio;
  } else if (win.matchMedia) {
    return goog.dom.matchesPixelRatio_(.75) ||
           goog.dom.matchesPixelRatio_(1.5) ||
           goog.dom.matchesPixelRatio_(2) ||
           goog.dom.matchesPixelRatio_(3) || 1;
  }
  return 1;
});


/**
 * Calculates a mediaQuery to check if the current device supports the
 * given actual to virtual pixel ratio.
 * @param {number} pixelRatio The ratio of actual pixels to virtual pixels.
 * @return {number} pixelRatio if applicable, otherwise 0.
 * @private
 */
goog.dom.matchesPixelRatio_ = function(pixelRatio) {
  var win = goog.dom.getWindow();
  var query = ('(-webkit-min-device-pixel-ratio: ' + pixelRatio + '),' +
               '(min--moz-device-pixel-ratio: ' + pixelRatio + '),' +
               '(min-resolution: ' + pixelRatio + 'dppx)');
  return win.matchMedia(query).matches ? pixelRatio : 0;
};



/**
 * Create an instance of a DOM helper with a new document object.
 * @param {Document=} opt_document Document object to associate with this
 *     DOM helper.
 * @constructor
 */
goog.dom.DomHelper = function(opt_document) {
  /**
   * Reference to the document object to use
   * @type {!Document}
   * @private
   */
  this.document_ = opt_document || goog.global.document || document;
};


/**
 * Gets the dom helper object for the document where the element resides.
 * @param {Node=} opt_node If present, gets the DomHelper for this node.
 * @return {!goog.dom.DomHelper} The DomHelper.
 */
goog.dom.DomHelper.prototype.getDomHelper = goog.dom.getDomHelper;


/**
 * Sets the document object.
 * @param {!Document} document Document object.
 */
goog.dom.DomHelper.prototype.setDocument = function(document) {
  this.document_ = document;
};


/**
 * Gets the document object being used by the dom library.
 * @return {!Document} Document object.
 */
goog.dom.DomHelper.prototype.getDocument = function() {
  return this.document_;
};


/**
 * Alias for {@code getElementById}. If a DOM node is passed in then we just
 * return that.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 */
goog.dom.DomHelper.prototype.getElement = function(element) {
  return goog.dom.getElementHelper_(this.document_, element);
};


/**
 * Gets an element by id, asserting that the element is found.
 *
 * This is used when an element is expected to exist, and should fail with
 * an assertion error if it does not (if assertions are enabled).
 *
 * @param {string} id Element ID.
 * @return {!Element} The element with the given ID, if it exists.
 */
goog.dom.DomHelper.prototype.getRequiredElement = function(id) {
  return goog.dom.getRequiredElementHelper_(this.document_, id);
};


/**
 * Alias for {@code getElement}.
 * @param {string|Element} element Element ID or a DOM node.
 * @return {Element} The element with the given ID, or the node passed in.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.getElement} instead.
 */
goog.dom.DomHelper.prototype.$ = goog.dom.DomHelper.prototype.getElement;


/**
 * Looks up elements by both tag and class name, using browser native functions
 * ({@code querySelectorAll}, {@code getElementsByTagName} or
 * {@code getElementsByClassName}) where possible. The returned array is a live
 * NodeList or a static list depending on the code path taken.
 *
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name or * for all tags.
 * @param {?string=} opt_class Optional class name.
 * @param {(Document|Element)=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.getElementsByTagNameAndClass = function(opt_tag,
                                                                     opt_class,
                                                                     opt_el) {
  return goog.dom.getElementsByTagNameAndClass_(this.document_, opt_tag,
                                                opt_class, opt_el);
};


/**
 * Returns an array of all the elements with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {Element|Document=} opt_el Optional element to look in.
 * @return { {length: number} } The items found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementsByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementsByClass(className, doc);
};


/**
 * Returns the first element we find matching the provided class name.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(Element|Document)=} opt_el Optional element to look in.
 * @return {Element} The first item found with the class name provided.
 */
goog.dom.DomHelper.prototype.getElementByClass = function(className, opt_el) {
  var doc = opt_el || this.document_;
  return goog.dom.getElementByClass(className, doc);
};


/**
 * Ensures an element with the given className exists, and then returns the
 * first element with the provided className.
 * @see {goog.dom.query}
 * @param {string} className the name of the class to look for.
 * @param {(!Element|!Document)=} opt_root Optional element or document to look
 *     in.
 * @return {!Element} The first item found with the class name provided.
 * @throws {goog.asserts.AssertionError} Thrown if no element is found.
 */
goog.dom.DomHelper.prototype.getRequiredElementByClass = function(className,
                                                                  opt_root) {
  var root = opt_root || this.document_;
  return goog.dom.getRequiredElementByClass(className, root);
};


/**
 * Alias for {@code getElementsByTagNameAndClass}.
 * @deprecated Use DomHelper getElementsByTagNameAndClass.
 * @see goog.dom.query
 *
 * @param {?string=} opt_tag Element tag name.
 * @param {?string=} opt_class Optional class name.
 * @param {Element=} opt_el Optional element to look in.
 * @return { {length: number} } Array-like list of elements (only a length
 *     property and numerical indices are guaranteed to exist).
 */
goog.dom.DomHelper.prototype.$$ =
    goog.dom.DomHelper.prototype.getElementsByTagNameAndClass;


/**
 * Sets a number of properties on a node.
 * @param {Element} element DOM node to set properties on.
 * @param {Object} properties Hash of property:value pairs.
 */
goog.dom.DomHelper.prototype.setProperties = goog.dom.setProperties;


/**
 * Gets the dimensions of the viewport.
 * @param {Window=} opt_window Optional window element to test. Defaults to
 *     the window of the Dom Helper.
 * @return {!goog.math.Size} Object with values 'width' and 'height'.
 */
goog.dom.DomHelper.prototype.getViewportSize = function(opt_window) {
  // TODO(arv): This should not take an argument. That breaks the rule of a
  // a DomHelper representing a single frame/window/document.
  return goog.dom.getViewportSize(opt_window || this.getWindow());
};


/**
 * Calculates the height of the document.
 *
 * @return {number} The height of the document.
 */
goog.dom.DomHelper.prototype.getDocumentHeight = function() {
  return goog.dom.getDocumentHeight_(this.getWindow());
};


/**
 * Typedef for use with goog.dom.createDom and goog.dom.append.
 * @typedef {Object|string|Array|NodeList}
 */
goog.dom.Appendable;


/**
 * Returns a dom node with a set of attributes.  This function accepts varargs
 * for subsequent nodes to be added.  Subsequent nodes will be added to the
 * first node as childNodes.
 *
 * So:
 * <code>createDom('div', null, createDom('p'), createDom('p'));</code>
 * would return a div with two child paragraphs
 *
 * An easy way to move all child nodes of an existing element to a new parent
 * element is:
 * <code>createDom('div', null, oldElement.childNodes);</code>
 * which will remove all child nodes from the old element and add them as
 * child nodes of the new DIV.
 *
 * @param {string} tagName Tag to create.
 * @param {Object|string=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or
 *     strings for text nodes. If one of the var_args is an array or
 *     NodeList, its elements will be added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 */
goog.dom.DomHelper.prototype.createDom = function(tagName,
                                                  opt_attributes,
                                                  var_args) {
  return goog.dom.createDom_(this.document_, arguments);
};


/**
 * Alias for {@code createDom}.
 * @param {string} tagName Tag to create.
 * @param {(Object|string)=} opt_attributes If object, then a map of name-value
 *     pairs for attributes. If a string, then this is the className of the new
 *     element.
 * @param {...goog.dom.Appendable} var_args Further DOM nodes or strings for
 *     text nodes.  If one of the var_args is an array, its children will be
 *     added as childNodes instead.
 * @return {!Element} Reference to a DOM node.
 * @deprecated Use {@link goog.dom.DomHelper.prototype.createDom} instead.
 */
goog.dom.DomHelper.prototype.$dom = goog.dom.DomHelper.prototype.createDom;


/**
 * Creates a new element.
 * @param {string} name Tag name.
 * @return {!Element} The new element.
 */
goog.dom.DomHelper.prototype.createElement = function(name) {
  return this.document_.createElement(name);
};


/**
 * Creates a new text node.
 * @param {number|string} content Content.
 * @return {!Text} The new text node.
 */
goog.dom.DomHelper.prototype.createTextNode = function(content) {
  return this.document_.createTextNode(String(content));
};


/**
 * Create a table.
 * @param {number} rows The number of rows in the table.  Must be >= 1.
 * @param {number} columns The number of columns in the table.  Must be >= 1.
 * @param {boolean=} opt_fillWithNbsp If true, fills table entries with nsbps.
 * @return {!Element} The created table.
 */
goog.dom.DomHelper.prototype.createTable = function(rows, columns,
    opt_fillWithNbsp) {
  return goog.dom.createTable_(this.document_, rows, columns,
      !!opt_fillWithNbsp);
};


/**
 * Converts an HTML string into a node or a document fragment.  A single Node
 * is used if the {@code htmlString} only generates a single node.  If the
 * {@code htmlString} generates multiple nodes then these are put inside a
 * {@code DocumentFragment}.
 *
 * @param {string} htmlString The HTML string to convert.
 * @return {!Node} The resulting node.
 */
goog.dom.DomHelper.prototype.htmlToDocumentFragment = function(htmlString) {
  return goog.dom.htmlToDocumentFragment_(this.document_, htmlString);
};


/**
 * Returns true if the browser is in "CSS1-compatible" (standards-compliant)
 * mode, false otherwise.
 * @return {boolean} True if in CSS1-compatible mode.
 */
goog.dom.DomHelper.prototype.isCss1CompatMode = function() {
  return goog.dom.isCss1CompatMode_(this.document_);
};


/**
 * Gets the window object associated with the document.
 * @return {!Window} The window associated with the given document.
 */
goog.dom.DomHelper.prototype.getWindow = function() {
  return goog.dom.getWindow_(this.document_);
};


/**
 * Gets the document scroll element.
 * @return {!Element} Scrolling element.
 */
goog.dom.DomHelper.prototype.getDocumentScrollElement = function() {
  return goog.dom.getDocumentScrollElement_(this.document_);
};


/**
 * Gets the document scroll distance as a coordinate object.
 * @return {!goog.math.Coordinate} Object with properties 'x' and 'y'.
 */
goog.dom.DomHelper.prototype.getDocumentScroll = function() {
  return goog.dom.getDocumentScroll_(this.document_);
};


/**
 * Determines the active element in the given document.
 * @param {Document=} opt_doc The document to look in.
 * @return {Element} The active element.
 */
goog.dom.DomHelper.prototype.getActiveElement = function(opt_doc) {
  return goog.dom.getActiveElement(opt_doc || this.document_);
};


/**
 * Appends a child to a node.
 * @param {Node} parent Parent.
 * @param {Node} child Child.
 */
goog.dom.DomHelper.prototype.appendChild = goog.dom.appendChild;


/**
 * Appends a node with text or other nodes.
 * @param {!Node} parent The node to append nodes to.
 * @param {...goog.dom.Appendable} var_args The things to append to the node.
 *     If this is a Node it is appended as is.
 *     If this is a string then a text node is appended.
 *     If this is an array like object then fields 0 to length - 1 are appended.
 */
goog.dom.DomHelper.prototype.append = goog.dom.append;


/**
 * Determines if the given node can contain children, intended to be used for
 * HTML generation.
 *
 * @param {Node} node The node to check.
 * @return {boolean} Whether the node can contain children.
 */
goog.dom.DomHelper.prototype.canHaveChildren = goog.dom.canHaveChildren;


/**
 * Removes all the child nodes on a DOM node.
 * @param {Node} node Node to remove children from.
 */
goog.dom.DomHelper.prototype.removeChildren = goog.dom.removeChildren;


/**
 * Inserts a new node before an existing reference node (i.e., as the previous
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert before.
 */
goog.dom.DomHelper.prototype.insertSiblingBefore = goog.dom.insertSiblingBefore;


/**
 * Inserts a new node after an existing reference node (i.e., as the next
 * sibling). If the reference node has no parent, then does nothing.
 * @param {Node} newNode Node to insert.
 * @param {Node} refNode Reference node to insert after.
 */
goog.dom.DomHelper.prototype.insertSiblingAfter = goog.dom.insertSiblingAfter;


/**
 * Insert a child at a given index. If index is larger than the number of child
 * nodes that the parent currently has, the node is inserted as the last child
 * node.
 * @param {Element} parent The element into which to insert the child.
 * @param {Node} child The element to insert.
 * @param {number} index The index at which to insert the new child node. Must
 *     not be negative.
 */
goog.dom.DomHelper.prototype.insertChildAt = goog.dom.insertChildAt;


/**
 * Removes a node from its parent.
 * @param {Node} node The node to remove.
 * @return {Node} The node removed if removed; else, null.
 */
goog.dom.DomHelper.prototype.removeNode = goog.dom.removeNode;


/**
 * Replaces a node in the DOM tree. Will do nothing if {@code oldNode} has no
 * parent.
 * @param {Node} newNode Node to insert.
 * @param {Node} oldNode Node to replace.
 */
goog.dom.DomHelper.prototype.replaceNode = goog.dom.replaceNode;


/**
 * Flattens an element. That is, removes it and replace it with its children.
 * @param {Element} element The element to flatten.
 * @return {Element|undefined} The original element, detached from the document
 *     tree, sans children, or undefined if the element was already not in the
 *     document.
 */
goog.dom.DomHelper.prototype.flattenElement = goog.dom.flattenElement;


/**
 * Returns an array containing just the element children of the given element.
 * @param {Element} element The element whose element children we want.
 * @return {!(Array|NodeList)} An array or array-like list of just the element
 *     children of the given element.
 */
goog.dom.DomHelper.prototype.getChildren = goog.dom.getChildren;


/**
 * Returns the first child node that is an element.
 * @param {Node} node The node to get the first child element of.
 * @return {Element} The first child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getFirstElementChild =
    goog.dom.getFirstElementChild;


/**
 * Returns the last child node that is an element.
 * @param {Node} node The node to get the last child element of.
 * @return {Element} The last child node of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getLastElementChild = goog.dom.getLastElementChild;


/**
 * Returns the first next sibling that is an element.
 * @param {Node} node The node to get the next sibling element of.
 * @return {Element} The next sibling of {@code node} that is an element.
 */
goog.dom.DomHelper.prototype.getNextElementSibling =
    goog.dom.getNextElementSibling;


/**
 * Returns the first previous sibling that is an element.
 * @param {Node} node The node to get the previous sibling element of.
 * @return {Element} The first previous sibling of {@code node} that is
 *     an element.
 */
goog.dom.DomHelper.prototype.getPreviousElementSibling =
    goog.dom.getPreviousElementSibling;


/**
 * Returns the next node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The next node in the DOM tree, or null if this was the last
 *     node.
 */
goog.dom.DomHelper.prototype.getNextNode = goog.dom.getNextNode;


/**
 * Returns the previous node in source order from the given node.
 * @param {Node} node The node.
 * @return {Node} The previous node in the DOM tree, or null if this was the
 *     first node.
 */
goog.dom.DomHelper.prototype.getPreviousNode = goog.dom.getPreviousNode;


/**
 * Whether the object looks like a DOM node.
 * @param {?} obj The object being tested for node likeness.
 * @return {boolean} Whether the object looks like a DOM node.
 */
goog.dom.DomHelper.prototype.isNodeLike = goog.dom.isNodeLike;


/**
 * Whether the object looks like an Element.
 * @param {?} obj The object being tested for Element likeness.
 * @return {boolean} Whether the object looks like an Element.
 */
goog.dom.DomHelper.prototype.isElement = goog.dom.isElement;


/**
 * Returns true if the specified value is a Window object. This includes the
 * global window for HTML pages, and iframe windows.
 * @param {?} obj Variable to test.
 * @return {boolean} Whether the variable is a window.
 */
goog.dom.DomHelper.prototype.isWindow = goog.dom.isWindow;


/**
 * Returns an element's parent, if it's an Element.
 * @param {Element} element The DOM element.
 * @return {Element} The parent, or null if not an Element.
 */
goog.dom.DomHelper.prototype.getParentElement = goog.dom.getParentElement;


/**
 * Whether a node contains another node.
 * @param {Node} parent The node that should contain the other node.
 * @param {Node} descendant The node to test presence of.
 * @return {boolean} Whether the parent node contains the descendent node.
 */
goog.dom.DomHelper.prototype.contains = goog.dom.contains;


/**
 * Compares the document order of two nodes, returning 0 if they are the same
 * node, a negative number if node1 is before node2, and a positive number if
 * node2 is before node1.  Note that we compare the order the tags appear in the
 * document so in the tree <b><i>text</i></b> the B node is considered to be
 * before the I node.
 *
 * @param {Node} node1 The first node to compare.
 * @param {Node} node2 The second node to compare.
 * @return {number} 0 if the nodes are the same node, a negative number if node1
 *     is before node2, and a positive number if node2 is before node1.
 */
goog.dom.DomHelper.prototype.compareNodeOrder = goog.dom.compareNodeOrder;


/**
 * Find the deepest common ancestor of the given nodes.
 * @param {...Node} var_args The nodes to find a common ancestor of.
 * @return {Node} The common ancestor of the nodes, or null if there is none.
 *     null will only be returned if two or more of the nodes are from different
 *     documents.
 */
goog.dom.DomHelper.prototype.findCommonAncestor = goog.dom.findCommonAncestor;


/**
 * Returns the owner document for a node.
 * @param {Node} node The node to get the document for.
 * @return {!Document} The document owning the node.
 */
goog.dom.DomHelper.prototype.getOwnerDocument = goog.dom.getOwnerDocument;


/**
 * Cross browser function for getting the document element of an iframe.
 * @param {Element} iframe Iframe element.
 * @return {!Document} The frame content document.
 */
goog.dom.DomHelper.prototype.getFrameContentDocument =
    goog.dom.getFrameContentDocument;


/**
 * Cross browser function for getting the window of a frame or iframe.
 * @param {Element} frame Frame element.
 * @return {Window} The window associated with the given frame.
 */
goog.dom.DomHelper.prototype.getFrameContentWindow =
    goog.dom.getFrameContentWindow;


/**
 * Sets the text content of a node, with cross-browser support.
 * @param {Node} node The node to change the text content of.
 * @param {string|number} text The value that should replace the node's content.
 */
goog.dom.DomHelper.prototype.setTextContent = goog.dom.setTextContent;


/**
 * Gets the outerHTML of a node, which islike innerHTML, except that it
 * actually contains the HTML of the node itself.
 * @param {Element} element The element to get the HTML of.
 * @return {string} The outerHTML of the given element.
 */
goog.dom.DomHelper.prototype.getOuterHtml = goog.dom.getOuterHtml;


/**
 * Finds the first descendant node that matches the filter function. This does
 * a depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Node|undefined} The found node or undefined if none is found.
 */
goog.dom.DomHelper.prototype.findNode = goog.dom.findNode;


/**
 * Finds all the descendant nodes that matches the filter function. This does a
 * depth first search.
 * @param {Node} root The root of the tree to search.
 * @param {function(Node) : boolean} p The filter function.
 * @return {Array.<Node>} The found nodes or an empty array if none are found.
 */
goog.dom.DomHelper.prototype.findNodes = goog.dom.findNodes;


/**
 * Returns true if the element has a tab index that allows it to receive
 * keyboard focus (tabIndex >= 0), false otherwise.  Note that some elements
 * natively support keyboard focus, even if they have no tab index.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element has a tab index that allows keyboard
 *     focus.
 */
goog.dom.DomHelper.prototype.isFocusableTabIndex = goog.dom.isFocusableTabIndex;


/**
 * Enables or disables keyboard focus support on the element via its tab index.
 * Only elements for which {@link goog.dom.isFocusableTabIndex} returns true
 * (or elements that natively support keyboard focus, like form elements) can
 * receive keyboard focus.  See http://go/tabindex for more info.
 * @param {Element} element Element whose tab index is to be changed.
 * @param {boolean} enable Whether to set or remove a tab index on the element
 *     that supports keyboard focus.
 */
goog.dom.DomHelper.prototype.setFocusableTabIndex =
    goog.dom.setFocusableTabIndex;


/**
 * Returns true if the element can be focused, i.e. it has a tab index that
 * allows it to receive keyboard focus (tabIndex >= 0), or it is an element
 * that natively supports keyboard focus.
 * @param {Element} element Element to check.
 * @return {boolean} Whether the element allows keyboard focus.
 */
goog.dom.DomHelper.prototype.isFocusable = goog.dom.isFocusable;


/**
 * Returns the text contents of the current node, without markup. New lines are
 * stripped and whitespace is collapsed, such that each character would be
 * visible.
 *
 * In browsers that support it, innerText is used.  Other browsers attempt to
 * simulate it via node traversal.  Line breaks are canonicalized in IE.
 *
 * @param {Node} node The node from which we are getting content.
 * @return {string} The text content.
 */
goog.dom.DomHelper.prototype.getTextContent = goog.dom.getTextContent;


/**
 * Returns the text length of the text contained in a node, without markup. This
 * is equivalent to the selection length if the node was selected, or the number
 * of cursor movements to traverse the node. Images & BRs take one space.  New
 * lines are ignored.
 *
 * @param {Node} node The node whose text content length is being calculated.
 * @return {number} The length of {@code node}'s text content.
 */
goog.dom.DomHelper.prototype.getNodeTextLength = goog.dom.getNodeTextLength;


/**
 * Returns the text offset of a node relative to one of its ancestors. The text
 * length is the same as the length calculated by
 * {@code goog.dom.getNodeTextLength}.
 *
 * @param {Node} node The node whose offset is being calculated.
 * @param {Node=} opt_offsetParent Defaults to the node's owner document's body.
 * @return {number} The text offset.
 */
goog.dom.DomHelper.prototype.getNodeTextOffset = goog.dom.getNodeTextOffset;


/**
 * Returns the node at a given offset in a parent node.  If an object is
 * provided for the optional third parameter, the node and the remainder of the
 * offset will stored as properties of this object.
 * @param {Node} parent The parent node.
 * @param {number} offset The offset into the parent node.
 * @param {Object=} opt_result Object to be used to store the return value. The
 *     return value will be stored in the form {node: Node, remainder: number}
 *     if this object is provided.
 * @return {Node} The node at the given offset.
 */
goog.dom.DomHelper.prototype.getNodeAtOffset = goog.dom.getNodeAtOffset;


/**
 * Returns true if the object is a {@code NodeList}.  To qualify as a NodeList,
 * the object must have a numeric length property and an item function (which
 * has type 'string' on IE for some reason).
 * @param {Object} val Object to test.
 * @return {boolean} Whether the object is a NodeList.
 */
goog.dom.DomHelper.prototype.isNodeList = goog.dom.isNodeList;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * tag name and/or class name. If the passed element matches the specified
 * criteria, the element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {?(goog.dom.TagName|string)=} opt_tag The tag name to match (or
 *     null/undefined to match only based on class name).
 * @param {?string=} opt_class The class name to match (or null/undefined to
 *     match only based on tag name).
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if no match is found.
 */
goog.dom.DomHelper.prototype.getAncestorByTagNameAndClass =
    goog.dom.getAncestorByTagNameAndClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that has the passed
 * class name. If the passed element matches the specified criteria, the
 * element itself is returned.
 * @param {Node} element The DOM node to start with.
 * @param {string} class The class name to match.
 * @return {Element} The first ancestor that matches the passed criteria, or
 *     null if none match.
 */
goog.dom.DomHelper.prototype.getAncestorByClass =
    goog.dom.getAncestorByClass;


/**
 * Walks up the DOM hierarchy returning the first ancestor that passes the
 * matcher function.
 * @param {Node} element The DOM node to start with.
 * @param {function(Node) : boolean} matcher A function that returns true if the
 *     passed node matches the desired criteria.
 * @param {boolean=} opt_includeNode If true, the node itself is included in
 *     the search (the first call to the matcher will pass startElement as
 *     the node to test).
 * @param {number=} opt_maxSearchSteps Maximum number of levels to search up the
 *     dom.
 * @return {Node} DOM node that matched the matcher, or null if there was
 *     no match.
 */
goog.dom.DomHelper.prototype.getAncestor = goog.dom.getAncestor;
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview Utilities for element styles.
 *
 * @see ../demos/inline_block_quirks.html
 * @see ../demos/inline_block_standards.html
 * @see ../demos/style_viewport.html
 */

goog.provide('goog.style');


goog.require('goog.array');
goog.require('goog.asserts');
goog.require('goog.dom');
goog.require('goog.dom.NodeType');
goog.require('goog.dom.vendor');
goog.require('goog.math.Box');
goog.require('goog.math.Coordinate');
goog.require('goog.math.Rect');
goog.require('goog.math.Size');
goog.require('goog.object');
goog.require('goog.string');
goog.require('goog.userAgent');


/**
 * @define {boolean} Whether we know at compile time that
 *     getBoundingClientRect() is present and bug-free on the browser.
 */
goog.define('goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS', false);


/**
 * Sets a style value on an element.
 *
 * This function is not indended to patch issues in the browser's style
 * handling, but to allow easy programmatic access to setting dash-separated
 * style properties.  An example is setting a batch of properties from a data
 * object without overwriting old styles.  When possible, use native APIs:
 * elem.style.propertyKey = 'value' or (if obliterating old styles is fine)
 * elem.style.cssText = 'property1: value1; property2: value2'.
 *
 * @param {Element} element The element to change.
 * @param {string|Object} style If a string, a style name. If an object, a hash
 *     of style names to style values.
 * @param {string|number|boolean=} opt_value If style was a string, then this
 *     should be the value.
 */
goog.style.setStyle = function(element, style, opt_value) {
  if (goog.isString(style)) {
    goog.style.setStyle_(element, opt_value, style);
  } else {
    goog.object.forEach(style, goog.partial(goog.style.setStyle_, element));
  }
};


/**
 * Sets a style value on an element, with parameters swapped to work with
 * {@code goog.object.forEach()}. Prepends a vendor-specific prefix when
 * necessary.
 * @param {Element} element The element to change.
 * @param {string|number|boolean|undefined} value Style value.
 * @param {string} style Style name.
 * @private
 */
goog.style.setStyle_ = function(element, value, style) {
  var propertyName = goog.style.getVendorJsStyleName_(element, style);

  if (propertyName) {
    element.style[propertyName] = value;
  }
};


/**
 * Returns the style property name in camel-case. If it does not exist and a
 * vendor-specific version of the property does exist, then return the vendor-
 * specific property name instead.
 * @param {Element} element The element to change.
 * @param {string} style Style name.
 * @return {string} Vendor-specific style.
 * @private
 */
goog.style.getVendorJsStyleName_ = function(element, style) {
  var camelStyle = goog.string.toCamelCase(style);

  if (element.style[camelStyle] === undefined) {
    var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
        goog.string.toTitleCase(camelStyle);

    if (element.style[prefixedStyle] !== undefined) {
      return prefixedStyle;
    }
  }

  return camelStyle;
};


/**
 * Returns the style property name in CSS notation. If it does not exist and a
 * vendor-specific version of the property does exist, then return the vendor-
 * specific property name instead.
 * @param {Element} element The element to change.
 * @param {string} style Style name.
 * @return {string} Vendor-specific style.
 * @private
 */
goog.style.getVendorStyleName_ = function(element, style) {
  var camelStyle = goog.string.toCamelCase(style);

  if (element.style[camelStyle] === undefined) {
    var prefixedStyle = goog.dom.vendor.getVendorJsPrefix() +
        goog.string.toTitleCase(camelStyle);

    if (element.style[prefixedStyle] !== undefined) {
      return goog.dom.vendor.getVendorPrefix() + '-' + style;
    }
  }

  return style;
};


/**
 * Retrieves an explicitly-set style value of a node. This returns '' if there
 * isn't a style attribute on the element or if this style property has not been
 * explicitly set in script.
 *
 * @param {Element} element Element to get style of.
 * @param {string} property Property to get, css-style (if you have a camel-case
 * property, use element.style[style]).
 * @return {string} Style value.
 */
goog.style.getStyle = function(element, property) {
  // element.style is '' for well-known properties which are unset.
  // For for browser specific styles as 'filter' is undefined
  // so we need to return '' explicitly to make it consistent across
  // browsers.
  var styleValue = element.style[goog.string.toCamelCase(property)];

  // Using typeof here because of a bug in Safari 5.1, where this value
  // was undefined, but === undefined returned false.
  if (typeof(styleValue) !== 'undefined') {
    return styleValue;
  }

  return element.style[goog.style.getVendorJsStyleName_(element, property)] ||
      '';
};


/**
 * Retrieves a computed style value of a node. It returns empty string if the
 * value cannot be computed (which will be the case in Internet Explorer) or
 * "none" if the property requested is an SVG one and it has not been
 * explicitly set (firefox and webkit).
 *
 * @param {Element} element Element to get style of.
 * @param {string} property Property to get (camel-case).
 * @return {string} Style value.
 */
goog.style.getComputedStyle = function(element, property) {
  var doc = goog.dom.getOwnerDocument(element);
  if (doc.defaultView && doc.defaultView.getComputedStyle) {
    var styles = doc.defaultView.getComputedStyle(element, null);
    if (styles) {
      // element.style[..] is undefined for browser specific styles
      // as 'filter'.
      return styles[property] || styles.getPropertyValue(property) || '';
    }
  }

  return '';
};


/**
 * Gets the cascaded style value of a node, or null if the value cannot be
 * computed (only Internet Explorer can do this).
 *
 * @param {Element} element Element to get style of.
 * @param {string} style Property to get (camel-case).
 * @return {string} Style value.
 */
goog.style.getCascadedStyle = function(element, style) {
  // TODO(nicksantos): This should be documented to return null. #fixTypes
  return element.currentStyle ? element.currentStyle[style] : null;
};


/**
 * Cross-browser pseudo get computed style. It returns the computed style where
 * available. If not available it tries the cascaded style value (IE
 * currentStyle) and in worst case the inline style value.  It shouldn't be
 * called directly, see http://wiki/Main/ComputedStyleVsCascadedStyle for
 * discussion.
 *
 * @param {Element} element Element to get style of.
 * @param {string} style Property to get (must be camelCase, not css-style.).
 * @return {string} Style value.
 * @private
 */
goog.style.getStyle_ = function(element, style) {
  return goog.style.getComputedStyle(element, style) ||
         goog.style.getCascadedStyle(element, style) ||
         (element.style && element.style[style]);
};


/**
 * Retrieves the computed value of the box-sizing CSS attribute.
 * Browser support: http://caniuse.com/css3-boxsizing.
 * @param {!Element} element The element whose box-sizing to get.
 * @return {?string} 'content-box', 'border-box' or 'padding-box'. null if
 *     box-sizing is not supported (IE7 and below).
 */
goog.style.getComputedBoxSizing = function(element) {
  return goog.style.getStyle_(element, 'boxSizing') ||
      goog.style.getStyle_(element, 'MozBoxSizing') ||
      goog.style.getStyle_(element, 'WebkitBoxSizing') || null;
};


/**
 * Retrieves the computed value of the position CSS attribute.
 * @param {Element} element The element to get the position of.
 * @return {string} Position value.
 */
goog.style.getComputedPosition = function(element) {
  return goog.style.getStyle_(element, 'position');
};


/**
 * Retrieves the computed background color string for a given element. The
 * string returned is suitable for assigning to another element's
 * background-color, but is not guaranteed to be in any particular string
 * format. Accessing the color in a numeric form may not be possible in all
 * browsers or with all input.
 *
 * If the background color for the element is defined as a hexadecimal value,
 * the resulting string can be parsed by goog.color.parse in all supported
 * browsers.
 *
 * Whether named colors like "red" or "lightblue" get translated into a
 * format which can be parsed is browser dependent. Calling this function on
 * transparent elements will return "transparent" in most browsers or
 * "rgba(0, 0, 0, 0)" in WebKit.
 * @param {Element} element The element to get the background color of.
 * @return {string} The computed string value of the background color.
 */
goog.style.getBackgroundColor = function(element) {
  return goog.style.getStyle_(element, 'backgroundColor');
};


/**
 * Retrieves the computed value of the overflow-x CSS attribute.
 * @param {Element} element The element to get the overflow-x of.
 * @return {string} The computed string value of the overflow-x attribute.
 */
goog.style.getComputedOverflowX = function(element) {
  return goog.style.getStyle_(element, 'overflowX');
};


/**
 * Retrieves the computed value of the overflow-y CSS attribute.
 * @param {Element} element The element to get the overflow-y of.
 * @return {string} The computed string value of the overflow-y attribute.
 */
goog.style.getComputedOverflowY = function(element) {
  return goog.style.getStyle_(element, 'overflowY');
};


/**
 * Retrieves the computed value of the z-index CSS attribute.
 * @param {Element} element The element to get the z-index of.
 * @return {string|number} The computed value of the z-index attribute.
 */
goog.style.getComputedZIndex = function(element) {
  return goog.style.getStyle_(element, 'zIndex');
};


/**
 * Retrieves the computed value of the text-align CSS attribute.
 * @param {Element} element The element to get the text-align of.
 * @return {string} The computed string value of the text-align attribute.
 */
goog.style.getComputedTextAlign = function(element) {
  return goog.style.getStyle_(element, 'textAlign');
};


/**
 * Retrieves the computed value of the cursor CSS attribute.
 * @param {Element} element The element to get the cursor of.
 * @return {string} The computed string value of the cursor attribute.
 */
goog.style.getComputedCursor = function(element) {
  return goog.style.getStyle_(element, 'cursor');
};


/**
 * Retrieves the computed value of the CSS transform attribute.
 * @param {Element} element The element to get the transform of.
 * @return {string} The computed string representation of the transform matrix.
 */
goog.style.getComputedTransform = function(element) {
  var property = goog.style.getVendorStyleName_(element, 'transform');
  return goog.style.getStyle_(element, property) ||
      goog.style.getStyle_(element, 'transform');
};


/**
 * Sets the top/left values of an element.  If no unit is specified in the
 * argument then it will add px. The second argument is required if the first
 * argument is a string or number and is ignored if the first argument
 * is a coordinate.
 * @param {Element} el Element to move.
 * @param {string|number|goog.math.Coordinate} arg1 Left position or coordinate.
 * @param {string|number=} opt_arg2 Top position.
 */
goog.style.setPosition = function(el, arg1, opt_arg2) {
  var x, y;
  var buggyGeckoSubPixelPos = goog.userAgent.GECKO &&
      (goog.userAgent.MAC || goog.userAgent.X11) &&
      goog.userAgent.isVersionOrHigher('1.9');

  if (arg1 instanceof goog.math.Coordinate) {
    x = arg1.x;
    y = arg1.y;
  } else {
    x = arg1;
    y = opt_arg2;
  }

  // Round to the nearest pixel for buggy sub-pixel support.
  el.style.left = goog.style.getPixelStyleValue_(
      /** @type {number|string} */ (x), buggyGeckoSubPixelPos);
  el.style.top = goog.style.getPixelStyleValue_(
      /** @type {number|string} */ (y), buggyGeckoSubPixelPos);
};


/**
 * Gets the offsetLeft and offsetTop properties of an element and returns them
 * in a Coordinate object
 * @param {Element} element Element.
 * @return {!goog.math.Coordinate} The position.
 */
goog.style.getPosition = function(element) {
  return new goog.math.Coordinate(element.offsetLeft, element.offsetTop);
};


/**
 * Returns the viewport element for a particular document
 * @param {Node=} opt_node DOM node (Document is OK) to get the viewport element
 *     of.
 * @return {Element} document.documentElement or document.body.
 */
goog.style.getClientViewportElement = function(opt_node) {
  var doc;
  if (opt_node) {
    doc = goog.dom.getOwnerDocument(opt_node);
  } else {
    doc = goog.dom.getDocument();
  }

  // In old IE versions the document.body represented the viewport
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9) &&
      !goog.dom.getDomHelper(doc).isCss1CompatMode()) {
    return doc.body;
  }
  return doc.documentElement;
};


/**
 * Calculates the viewport coordinates relative to the page/document
 * containing the node. The viewport may be the browser viewport for
 * non-iframe document, or the iframe container for iframe'd document.
 * @param {!Document} doc The document to use as the reference point.
 * @return {!goog.math.Coordinate} The page offset of the viewport.
 */
goog.style.getViewportPageOffset = function(doc) {
  var body = doc.body;
  var documentElement = doc.documentElement;
  var scrollLeft = body.scrollLeft || documentElement.scrollLeft;
  var scrollTop = body.scrollTop || documentElement.scrollTop;
  return new goog.math.Coordinate(scrollLeft, scrollTop);
};


/**
 * Gets the client rectangle of the DOM element.
 *
 * getBoundingClientRect is part of a new CSS object model draft (with a
 * long-time presence in IE), replacing the error-prone parent offset
 * computation and the now-deprecated Gecko getBoxObjectFor.
 *
 * This utility patches common browser bugs in getBoundingClientRect. It
 * will fail if getBoundingClientRect is unsupported.
 *
 * If the element is not in the DOM, the result is undefined, and an error may
 * be thrown depending on user agent.
 *
 * @param {!Element} el The element whose bounding rectangle is being queried.
 * @return {Object} A native bounding rectangle with numerical left, top,
 *     right, and bottom.  Reported by Firefox to be of object type ClientRect.
 * @private
 */
goog.style.getBoundingClientRect_ = function(el) {
  var rect;
  try {
    rect = el.getBoundingClientRect();
  } catch (e) {
    // In IE < 9, calling getBoundingClientRect on an orphan element raises an
    // "Unspecified Error". All other browsers return zeros.
    return {'left': 0, 'top': 0, 'right': 0, 'bottom': 0};
  }

  // Patch the result in IE only, so that this function can be inlined if
  // compiled for non-IE.
  if (goog.userAgent.IE && el.ownerDocument.body) {

    // In IE, most of the time, 2 extra pixels are added to the top and left
    // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
    // IE6 standards mode, this border can be overridden by setting the
    // document element's border to zero -- thus, we cannot rely on the
    // offset always being 2 pixels.

    // In quirks mode, the offset can be determined by querying the body's
    // clientLeft/clientTop, but in standards mode, it is found by querying
    // the document element's clientLeft/clientTop.  Since we already called
    // getBoundingClientRect we have already forced a reflow, so it is not
    // too expensive just to query them all.

    // See: http://msdn.microsoft.com/en-us/library/ms536433(VS.85).aspx
    var doc = el.ownerDocument;
    rect.left -= doc.documentElement.clientLeft + doc.body.clientLeft;
    rect.top -= doc.documentElement.clientTop + doc.body.clientTop;
  }
  return /** @type {Object} */ (rect);
};


/**
 * Returns the first parent that could affect the position of a given element.
 * @param {Element} element The element to get the offset parent for.
 * @return {Element} The first offset parent or null if one cannot be found.
 */
goog.style.getOffsetParent = function(element) {
  // element.offsetParent does the right thing in IE7 and below.  In other
  // browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(8)) {
    return element.offsetParent;
  }

  var doc = goog.dom.getOwnerDocument(element);
  var positionStyle = goog.style.getStyle_(element, 'position');
  var skipStatic = positionStyle == 'fixed' || positionStyle == 'absolute';
  for (var parent = element.parentNode; parent && parent != doc;
       parent = parent.parentNode) {
    positionStyle =
        goog.style.getStyle_(/** @type {!Element} */ (parent), 'position');
    skipStatic = skipStatic && positionStyle == 'static' &&
                 parent != doc.documentElement && parent != doc.body;
    if (!skipStatic && (parent.scrollWidth > parent.clientWidth ||
                        parent.scrollHeight > parent.clientHeight ||
                        positionStyle == 'fixed' ||
                        positionStyle == 'absolute' ||
                        positionStyle == 'relative')) {
      return /** @type {!Element} */ (parent);
    }
  }
  return null;
};


/**
 * Calculates and returns the visible rectangle for a given element. Returns a
 * box describing the visible portion of the nearest scrollable offset ancestor.
 * Coordinates are given relative to the document.
 *
 * @param {Element} element Element to get the visible rect for.
 * @return {goog.math.Box} Bounding elementBox describing the visible rect or
 *     null if scrollable ancestor isn't inside the visible viewport.
 */
goog.style.getVisibleRectForElement = function(element) {
  var visibleRect = new goog.math.Box(0, Infinity, Infinity, 0);
  var dom = goog.dom.getDomHelper(element);
  var body = dom.getDocument().body;
  var documentElement = dom.getDocument().documentElement;
  var scrollEl = dom.getDocumentScrollElement();

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  for (var el = element; el = goog.style.getOffsetParent(el); ) {
    // clientWidth is zero for inline block elements in IE.
    // on WEBKIT, body element can have clientHeight = 0 and scrollHeight > 0
    if ((!goog.userAgent.IE || el.clientWidth != 0) &&
        (!goog.userAgent.WEBKIT || el.clientHeight != 0 || el != body) &&
        // body may have overflow set on it, yet we still get the entire
        // viewport. In some browsers, el.offsetParent may be
        // document.documentElement, so check for that too.
        (el != body && el != documentElement &&
            goog.style.getStyle_(el, 'overflow') != 'visible')) {
      var pos = goog.style.getPageOffset(el);
      var client = goog.style.getClientLeftTop(el);
      pos.x += client.x;
      pos.y += client.y;

      visibleRect.top = Math.max(visibleRect.top, pos.y);
      visibleRect.right = Math.min(visibleRect.right,
                                   pos.x + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom,
                                    pos.y + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.x);
    }
  }

  // Clip by window's viewport.
  var scrollX = scrollEl.scrollLeft, scrollY = scrollEl.scrollTop;
  visibleRect.left = Math.max(visibleRect.left, scrollX);
  visibleRect.top = Math.max(visibleRect.top, scrollY);
  var winSize = dom.getViewportSize();
  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
  return visibleRect.top >= 0 && visibleRect.left >= 0 &&
         visibleRect.bottom > visibleRect.top &&
         visibleRect.right > visibleRect.left ?
         visibleRect : null;
};


/**
 * Calculate the scroll position of {@code container} with the minimum amount so
 * that the content and the borders of the given {@code element} become visible.
 * If the element is bigger than the container, its top left corner will be
 * aligned as close to the container's top left corner as possible.
 *
 * @param {Element} element The element to make visible.
 * @param {Element} container The container to scroll.
 * @param {boolean=} opt_center Whether to center the element in the container.
 *     Defaults to false.
 * @return {!goog.math.Coordinate} The new scroll position of the container,
 *     in form of goog.math.Coordinate(scrollLeft, scrollTop).
 */
goog.style.getContainerOffsetToScrollInto =
    function(element, container, opt_center) {
  // Absolute position of the element's border's top left corner.
  var elementPos = goog.style.getPageOffset(element);
  // Absolute position of the container's border's top left corner.
  var containerPos = goog.style.getPageOffset(container);
  var containerBorder = goog.style.getBorderBox(container);
  // Relative pos. of the element's border box to the container's content box.
  var relX = elementPos.x - containerPos.x - containerBorder.left;
  var relY = elementPos.y - containerPos.y - containerBorder.top;
  // How much the element can move in the container, i.e. the difference between
  // the element's bottom-right-most and top-left-most position where it's
  // fully visible.
  var spaceX = container.clientWidth - element.offsetWidth;
  var spaceY = container.clientHeight - element.offsetHeight;

  var scrollLeft = container.scrollLeft;
  var scrollTop = container.scrollTop;
  if (opt_center) {
    // All browsers round non-integer scroll positions down.
    scrollLeft += relX - spaceX / 2;
    scrollTop += relY - spaceY / 2;
  } else {
    // This formula was designed to give the correct scroll values in the
    // following cases:
    // - element is higher than container (spaceY < 0) => scroll down by relY
    // - element is not higher that container (spaceY >= 0):
    //   - it is above container (relY < 0) => scroll up by abs(relY)
    //   - it is below container (relY > spaceY) => scroll down by relY - spaceY
    //   - it is in the container => don't scroll
    scrollLeft += Math.min(relX, Math.max(relX - spaceX, 0));
    scrollTop += Math.min(relY, Math.max(relY - spaceY, 0));
  }
  return new goog.math.Coordinate(scrollLeft, scrollTop);
};


/**
 * Changes the scroll position of {@code container} with the minimum amount so
 * that the content and the borders of the given {@code element} become visible.
 * If the element is bigger than the container, its top left corner will be
 * aligned as close to the container's top left corner as possible.
 *
 * @param {Element} element The element to make visible.
 * @param {Element} container The container to scroll.
 * @param {boolean=} opt_center Whether to center the element in the container.
 *     Defaults to false.
 */
goog.style.scrollIntoContainerView = function(element, container, opt_center) {
  var offset =
      goog.style.getContainerOffsetToScrollInto(element, container, opt_center);
  container.scrollLeft = offset.x;
  container.scrollTop = offset.y;
};


/**
 * Returns clientLeft (width of the left border and, if the directionality is
 * right to left, the vertical scrollbar) and clientTop as a coordinate object.
 *
 * @param {Element} el Element to get clientLeft for.
 * @return {!goog.math.Coordinate} Client left and top.
 */
goog.style.getClientLeftTop = function(el) {
  // NOTE(eae): Gecko prior to 1.9 doesn't support clientTop/Left, see
  // https://bugzilla.mozilla.org/show_bug.cgi?id=111207
  if (goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher('1.9')) {
    var left = parseFloat(goog.style.getComputedStyle(el, 'borderLeftWidth'));
    if (goog.style.isRightToLeft(el)) {
      var scrollbarWidth = el.offsetWidth - el.clientWidth - left -
          parseFloat(goog.style.getComputedStyle(el, 'borderRightWidth'));
      left += scrollbarWidth;
    }
    return new goog.math.Coordinate(left,
        parseFloat(goog.style.getComputedStyle(el, 'borderTopWidth')));
  }

  return new goog.math.Coordinate(el.clientLeft, el.clientTop);
};


/**
 * Returns a Coordinate object relative to the top-left of the HTML document.
 * Implemented as a single function to save having to do two recursive loops in
 * opera and safari just to get both coordinates.  If you just want one value do
 * use goog.style.getPageOffsetLeft() and goog.style.getPageOffsetTop(), but
 * note if you call both those methods the tree will be analysed twice.
 *
 * @param {Element} el Element to get the page offset for.
 * @return {!goog.math.Coordinate} The page offset.
 */
goog.style.getPageOffset = function(el) {
  var box, doc = goog.dom.getOwnerDocument(el);
  var positionStyle = goog.style.getStyle_(el, 'position');
  // TODO(gboyer): Update the jsdoc in a way that doesn't break the universe.
  goog.asserts.assertObject(el, 'Parameter is required');

  // NOTE(eae): Gecko pre 1.9 normally use getBoxObjectFor to calculate the
  // position. When invoked for an element with position absolute and a negative
  // position though it can be off by one. Therefor the recursive implementation
  // is used in those (relatively rare) cases.
  var BUGGY_GECKO_BOX_OBJECT =
      !goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS &&
      goog.userAgent.GECKO && doc.getBoxObjectFor &&
      !el.getBoundingClientRect && positionStyle == 'absolute' &&
      (box = doc.getBoxObjectFor(el)) && (box.screenX < 0 || box.screenY < 0);

  // NOTE(arv): If element is hidden (display none or disconnected or any the
  // ancestors are hidden) we get (0,0) by default but we still do the
  // accumulation of scroll position.

  // TODO(arv): Should we check if the node is disconnected and in that case
  //            return (0,0)?

  var pos = new goog.math.Coordinate(0, 0);
  var viewportElement = goog.style.getClientViewportElement(doc);
  if (el == viewportElement) {
    // viewport is always at 0,0 as that defined the coordinate system for this
    // function - this avoids special case checks in the code below
    return pos;
  }

  // IE, Gecko 1.9+, and most modern WebKit.
  if (goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS ||
      el.getBoundingClientRect) {
    box = goog.style.getBoundingClientRect_(el);
    // Must add the scroll coordinates in to get the absolute page offset
    // of element since getBoundingClientRect returns relative coordinates to
    // the viewport.
    var scrollCoord = goog.dom.getDomHelper(doc).getDocumentScroll();
    pos.x = box.left + scrollCoord.x;
    pos.y = box.top + scrollCoord.y;

  // Gecko prior to 1.9.
  } else if (doc.getBoxObjectFor && !BUGGY_GECKO_BOX_OBJECT) {
    // Gecko ignores the scroll values for ancestors, up to 1.9.  See:
    // https://bugzilla.mozilla.org/show_bug.cgi?id=328881 and
    // https://bugzilla.mozilla.org/show_bug.cgi?id=330619

    box = doc.getBoxObjectFor(el);
    // TODO(user): Fix the off-by-one error when window is scrolled down
    // or right more than 1 pixel. The viewport offset does not move in lock
    // step with the window scroll; it moves in increments of 2px and at
    // somewhat random intervals.
    var vpBox = doc.getBoxObjectFor(viewportElement);
    pos.x = box.screenX - vpBox.screenX;
    pos.y = box.screenY - vpBox.screenY;

  // Safari, Opera and Camino up to 1.0.4.
  } else {
    var parent = el;
    do {
      pos.x += parent.offsetLeft;
      pos.y += parent.offsetTop;
      // For safari/chrome, we need to add parent's clientLeft/Top as well.
      if (parent != el) {
        pos.x += parent.clientLeft || 0;
        pos.y += parent.clientTop || 0;
      }
      // In Safari when hit a position fixed element the rest of the offsets
      // are not correct.
      if (goog.userAgent.WEBKIT &&
          goog.style.getComputedPosition(parent) == 'fixed') {
        pos.x += doc.body.scrollLeft;
        pos.y += doc.body.scrollTop;
        break;
      }
      parent = parent.offsetParent;
    } while (parent && parent != el);

    // Opera & (safari absolute) incorrectly account for body offsetTop.
    if (goog.userAgent.OPERA || (goog.userAgent.WEBKIT &&
        positionStyle == 'absolute')) {
      pos.y -= doc.body.offsetTop;
    }

    for (parent = el; (parent = goog.style.getOffsetParent(parent)) &&
        parent != doc.body && parent != viewportElement; ) {
      pos.x -= parent.scrollLeft;
      // Workaround for a bug in Opera 9.2 (and earlier) where table rows may
      // report an invalid scroll top value. The bug was fixed in Opera 9.5
      // however as that version supports getBoundingClientRect it won't
      // trigger this code path. https://bugs.opera.com/show_bug.cgi?id=249965
      if (!goog.userAgent.OPERA || parent.tagName != 'TR') {
        pos.y -= parent.scrollTop;
      }
    }
  }

  return pos;
};


/**
 * Returns the left coordinate of an element relative to the HTML document
 * @param {Element} el Elements.
 * @return {number} The left coordinate.
 */
goog.style.getPageOffsetLeft = function(el) {
  return goog.style.getPageOffset(el).x;
};


/**
 * Returns the top coordinate of an element relative to the HTML document
 * @param {Element} el Elements.
 * @return {number} The top coordinate.
 */
goog.style.getPageOffsetTop = function(el) {
  return goog.style.getPageOffset(el).y;
};


/**
 * Returns a Coordinate object relative to the top-left of an HTML document
 * in an ancestor frame of this element. Used for measuring the position of
 * an element inside a frame relative to a containing frame.
 *
 * @param {Element} el Element to get the page offset for.
 * @param {Window} relativeWin The window to measure relative to. If relativeWin
 *     is not in the ancestor frame chain of the element, we measure relative to
 *     the top-most window.
 * @return {!goog.math.Coordinate} The page offset.
 */
goog.style.getFramedPageOffset = function(el, relativeWin) {
  var position = new goog.math.Coordinate(0, 0);

  // Iterate up the ancestor frame chain, keeping track of the current window
  // and the current element in that window.
  var currentWin = goog.dom.getWindow(goog.dom.getOwnerDocument(el));
  var currentEl = el;
  do {
    // if we're at the top window, we want to get the page offset.
    // if we're at an inner frame, we only want to get the window position
    // so that we can determine the actual page offset in the context of
    // the outer window.
    var offset = currentWin == relativeWin ?
        goog.style.getPageOffset(currentEl) :
        goog.style.getClientPositionForElement_(
            goog.asserts.assert(currentEl));

    position.x += offset.x;
    position.y += offset.y;
  } while (currentWin && currentWin != relativeWin &&
      (currentEl = currentWin.frameElement) &&
      (currentWin = currentWin.parent));

  return position;
};


/**
 * Translates the specified rect relative to origBase page, for newBase page.
 * If origBase and newBase are the same, this function does nothing.
 *
 * @param {goog.math.Rect} rect The source rectangle relative to origBase page,
 *     and it will have the translated result.
 * @param {goog.dom.DomHelper} origBase The DomHelper for the input rectangle.
 * @param {goog.dom.DomHelper} newBase The DomHelper for the resultant
 *     coordinate.  This must be a DOM for an ancestor frame of origBase
 *     or the same as origBase.
 */
goog.style.translateRectForAnotherFrame = function(rect, origBase, newBase) {
  if (origBase.getDocument() != newBase.getDocument()) {
    var body = origBase.getDocument().body;
    var pos = goog.style.getFramedPageOffset(body, newBase.getWindow());

    // Adjust Body's margin.
    pos = goog.math.Coordinate.difference(pos, goog.style.getPageOffset(body));

    if (goog.userAgent.IE && !origBase.isCss1CompatMode()) {
      pos = goog.math.Coordinate.difference(pos, origBase.getDocumentScroll());
    }

    rect.left += pos.x;
    rect.top += pos.y;
  }
};


/**
 * Returns the position of an element relative to another element in the
 * document.  A relative to B
 * @param {Element|Event|goog.events.Event} a Element or mouse event whose
 *     position we're calculating.
 * @param {Element|Event|goog.events.Event} b Element or mouse event position
 *     is relative to.
 * @return {!goog.math.Coordinate} The relative position.
 */
goog.style.getRelativePosition = function(a, b) {
  var ap = goog.style.getClientPosition(a);
  var bp = goog.style.getClientPosition(b);
  return new goog.math.Coordinate(ap.x - bp.x, ap.y - bp.y);
};


/**
 * Returns the position of the event or the element's border box relative to
 * the client viewport.
 * @param {!Element} el Element whose position to get.
 * @return {!goog.math.Coordinate} The position.
 * @private
 */
goog.style.getClientPositionForElement_ = function(el) {
  var pos;
  if (goog.style.GET_BOUNDING_CLIENT_RECT_ALWAYS_EXISTS ||
      el.getBoundingClientRect) {
    // IE, Gecko 1.9+, and most modern WebKit
    var box = goog.style.getBoundingClientRect_(el);
    pos = new goog.math.Coordinate(box.left, box.top);
  } else {
    var scrollCoord = goog.dom.getDomHelper(el).getDocumentScroll();
    var pageCoord = goog.style.getPageOffset(el);
    pos = new goog.math.Coordinate(
        pageCoord.x - scrollCoord.x,
        pageCoord.y - scrollCoord.y);
  }

  // Gecko below version 12 doesn't add CSS translation to the client position
  // (using either getBoundingClientRect or getBoxOffsetFor) so we need to do
  // so manually.
  if (goog.userAgent.GECKO && !goog.userAgent.isVersionOrHigher(12)) {
    return goog.math.Coordinate.sum(pos, goog.style.getCssTranslation(el));
  } else {
    return pos;
  }
};


/**
 * Returns the position of the event or the element's border box relative to
 * the client viewport.
 * @param {Element|Event|goog.events.Event} el Element or a mouse / touch event.
 * @return {!goog.math.Coordinate} The position.
 */
goog.style.getClientPosition = function(el) {
  goog.asserts.assert(el);
  if (el.nodeType == goog.dom.NodeType.ELEMENT) {
    return goog.style.getClientPositionForElement_(
        /** @type {!Element} */ (el));
  } else {
    var isAbstractedEvent = goog.isFunction(el.getBrowserEvent);
    var be = /** @type {!goog.events.BrowserEvent} */ (el);
    var targetEvent = el;

    if (el.targetTouches) {
      targetEvent = el.targetTouches[0];
    } else if (isAbstractedEvent && be.getBrowserEvent().targetTouches) {
      targetEvent = be.getBrowserEvent().targetTouches[0];
    }

    return new goog.math.Coordinate(
        targetEvent.clientX,
        targetEvent.clientY);
  }
};


/**
 * Moves an element to the given coordinates relative to the client viewport.
 * @param {Element} el Absolutely positioned element to set page offset for.
 *     It must be in the document.
 * @param {number|goog.math.Coordinate} x Left position of the element's margin
 *     box or a coordinate object.
 * @param {number=} opt_y Top position of the element's margin box.
 */
goog.style.setPageOffset = function(el, x, opt_y) {
  // Get current pageoffset
  var cur = goog.style.getPageOffset(el);

  if (x instanceof goog.math.Coordinate) {
    opt_y = x.y;
    x = x.x;
  }

  // NOTE(arv): We cannot allow strings for x and y. We could but that would
  // require us to manually transform between different units

  // Work out deltas
  var dx = x - cur.x;
  var dy = opt_y - cur.y;

  // Set position to current left/top + delta
  goog.style.setPosition(el, el.offsetLeft + dx, el.offsetTop + dy);
};


/**
 * Sets the width/height values of an element.  If an argument is numeric,
 * or a goog.math.Size is passed, it is assumed to be pixels and will add
 * 'px' after converting it to an integer in string form. (This just sets the
 * CSS width and height properties so it might set content-box or border-box
 * size depending on the box model the browser is using.)
 *
 * @param {Element} element Element to set the size of.
 * @param {string|number|goog.math.Size} w Width of the element, or a
 *     size object.
 * @param {string|number=} opt_h Height of the element. Required if w is not a
 *     size object.
 */
goog.style.setSize = function(element, w, opt_h) {
  var h;
  if (w instanceof goog.math.Size) {
    h = w.height;
    w = w.width;
  } else {
    if (opt_h == undefined) {
      throw Error('missing height argument');
    }
    h = opt_h;
  }

  goog.style.setWidth(element, /** @type {string|number} */ (w));
  goog.style.setHeight(element, /** @type {string|number} */ (h));
};


/**
 * Helper function to create a string to be set into a pixel-value style
 * property of an element. Can round to the nearest integer value.
 *
 * @param {string|number} value The style value to be used. If a number,
 *     'px' will be appended, otherwise the value will be applied directly.
 * @param {boolean} round Whether to round the nearest integer (if property
 *     is a number).
 * @return {string} The string value for the property.
 * @private
 */
goog.style.getPixelStyleValue_ = function(value, round) {
  if (typeof value == 'number') {
    value = (round ? Math.round(value) : value) + 'px';
  }

  return value;
};


/**
 * Set the height of an element.  Sets the element's style property.
 * @param {Element} element Element to set the height of.
 * @param {string|number} height The height value to set.  If a number, 'px'
 *     will be appended, otherwise the value will be applied directly.
 */
goog.style.setHeight = function(element, height) {
  element.style.height = goog.style.getPixelStyleValue_(height, true);
};


/**
 * Set the width of an element.  Sets the element's style property.
 * @param {Element} element Element to set the width of.
 * @param {string|number} width The width value to set.  If a number, 'px'
 *     will be appended, otherwise the value will be applied directly.
 */
goog.style.setWidth = function(element, width) {
  element.style.width = goog.style.getPixelStyleValue_(width, true);
};


/**
 * Gets the height and width of an element, even if its display is none.
 *
 * Specifically, this returns the height and width of the border box,
 * irrespective of the box model in effect.
 *
 * Note that this function does not take CSS transforms into account. Please see
 * {@code goog.style.getTransformedSize}.
 * @param {Element} element Element to get size of.
 * @return {!goog.math.Size} Object with width/height properties.
 */
goog.style.getSize = function(element) {
  return goog.style.evaluateWithTemporaryDisplay_(
      goog.style.getSizeWithDisplay_, /** @type {!Element} */ (element));
};


/**
 * Call {@code fn} on {@code element} such that {@code element}'s dimensions are
 * accurate when it's passed to {@code fn}.
 * @param {function(!Element): T} fn Function to call with {@code element} as
 *     an argument after temporarily changing {@code element}'s display such
 *     that its dimensions are accurate.
 * @param {!Element} element Element (which may have display none) to use as
 *     argument to {@code fn}.
 * @return {T} Value returned by calling {@code fn} with {@code element}.
 * @template T
 * @private
 */
goog.style.evaluateWithTemporaryDisplay_ = function(fn, element) {
  if (goog.style.getStyle_(element, 'display') != 'none') {
    return fn(element);
  }

  var style = element.style;
  var originalDisplay = style.display;
  var originalVisibility = style.visibility;
  var originalPosition = style.position;

  style.visibility = 'hidden';
  style.position = 'absolute';
  style.display = 'inline';

  var retVal = fn(element);

  style.display = originalDisplay;
  style.position = originalPosition;
  style.visibility = originalVisibility;

  return retVal;
};


/**
 * Gets the height and width of an element when the display is not none.
 * @param {Element} element Element to get size of.
 * @return {!goog.math.Size} Object with width/height properties.
 * @private
 */
goog.style.getSizeWithDisplay_ = function(element) {
  var offsetWidth = element.offsetWidth;
  var offsetHeight = element.offsetHeight;
  var webkitOffsetsZero =
      goog.userAgent.WEBKIT && !offsetWidth && !offsetHeight;
  if ((!goog.isDef(offsetWidth) || webkitOffsetsZero) &&
      element.getBoundingClientRect) {
    // Fall back to calling getBoundingClientRect when offsetWidth or
    // offsetHeight are not defined, or when they are zero in WebKit browsers.
    // This makes sure that we return for the correct size for SVG elements, but
    // will still return 0 on Webkit prior to 534.8, see
    // http://trac.webkit.org/changeset/67252.
    var clientRect = goog.style.getBoundingClientRect_(element);
    return new goog.math.Size(clientRect.right - clientRect.left,
        clientRect.bottom - clientRect.top);
  }
  return new goog.math.Size(offsetWidth, offsetHeight);
};


/**
 * Gets the height and width of an element, post transform, even if its display
 * is none.
 *
 * This is like {@code goog.style.getSize}, except:
 * <ol>
 * <li>Takes webkitTransforms such as rotate and scale into account.
 * <li>Will return null if {@code element} doesn't respond to
 *     {@code getBoundingClientRect}.
 * <li>Currently doesn't make sense on non-WebKit browsers which don't support
 *    webkitTransforms.
 * </ol>
 * @param {!Element} element Element to get size of.
 * @return {goog.math.Size} Object with width/height properties.
 */
goog.style.getTransformedSize = function(element) {
  if (!element.getBoundingClientRect) {
    return null;
  }

  var clientRect = goog.style.evaluateWithTemporaryDisplay_(
      goog.style.getBoundingClientRect_, element);
  return new goog.math.Size(clientRect.right - clientRect.left,
      clientRect.bottom - clientRect.top);
};


/**
 * Returns a bounding rectangle for a given element in page space.
 * @param {Element} element Element to get bounds of. Must not be display none.
 * @return {!goog.math.Rect} Bounding rectangle for the element.
 */
goog.style.getBounds = function(element) {
  var o = goog.style.getPageOffset(element);
  var s = goog.style.getSize(element);
  return new goog.math.Rect(o.x, o.y, s.width, s.height);
};


/**
 * Converts a CSS selector in the form style-property to styleProperty.
 * @param {*} selector CSS Selector.
 * @return {string} Camel case selector.
 * @deprecated Use goog.string.toCamelCase instead.
 */
goog.style.toCamelCase = function(selector) {
  return goog.string.toCamelCase(String(selector));
};


/**
 * Converts a CSS selector in the form styleProperty to style-property.
 * @param {string} selector Camel case selector.
 * @return {string} Selector cased.
 * @deprecated Use goog.string.toSelectorCase instead.
 */
goog.style.toSelectorCase = function(selector) {
  return goog.string.toSelectorCase(selector);
};


/**
 * Gets the opacity of a node (x-browser). This gets the inline style opacity
 * of the node, and does not take into account the cascaded or the computed
 * style for this node.
 * @param {Element} el Element whose opacity has to be found.
 * @return {number|string} Opacity between 0 and 1 or an empty string {@code ''}
 *     if the opacity is not set.
 */
goog.style.getOpacity = function(el) {
  var style = el.style;
  var result = '';
  if ('opacity' in style) {
    result = style.opacity;
  } else if ('MozOpacity' in style) {
    result = style.MozOpacity;
  } else if ('filter' in style) {
    var match = style.filter.match(/alpha\(opacity=([\d.]+)\)/);
    if (match) {
      result = String(match[1] / 100);
    }
  }
  return result == '' ? result : Number(result);
};


/**
 * Sets the opacity of a node (x-browser).
 * @param {Element} el Elements whose opacity has to be set.
 * @param {number|string} alpha Opacity between 0 and 1 or an empty string
 *     {@code ''} to clear the opacity.
 */
goog.style.setOpacity = function(el, alpha) {
  var style = el.style;
  if ('opacity' in style) {
    style.opacity = alpha;
  } else if ('MozOpacity' in style) {
    style.MozOpacity = alpha;
  } else if ('filter' in style) {
    // TODO(arv): Overwriting the filter might have undesired side effects.
    if (alpha === '') {
      style.filter = '';
    } else {
      style.filter = 'alpha(opacity=' + alpha * 100 + ')';
    }
  }
};


/**
 * Sets the background of an element to a transparent image in a browser-
 * independent manner.
 *
 * This function does not support repeating backgrounds or alternate background
 * positions to match the behavior of Internet Explorer. It also does not
 * support sizingMethods other than crop since they cannot be replicated in
 * browsers other than Internet Explorer.
 *
 * @param {Element} el The element to set background on.
 * @param {string} src The image source URL.
 */
goog.style.setTransparentBackgroundImage = function(el, src) {
  var style = el.style;
  // It is safe to use the style.filter in IE only. In Safari 'filter' is in
  // style object but access to style.filter causes it to throw an exception.
  // Note: IE8 supports images with an alpha channel.
  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
    // See TODO in setOpacity.
    style.filter = 'progid:DXImageTransform.Microsoft.AlphaImageLoader(' +
        'src="' + src + '", sizingMethod="crop")';
  } else {
    // Set style properties individually instead of using background shorthand
    // to prevent overwriting a pre-existing background color.
    style.backgroundImage = 'url(' + src + ')';
    style.backgroundPosition = 'top left';
    style.backgroundRepeat = 'no-repeat';
  }
};


/**
 * Clears the background image of an element in a browser independent manner.
 * @param {Element} el The element to clear background image for.
 */
goog.style.clearTransparentBackgroundImage = function(el) {
  var style = el.style;
  if ('filter' in style) {
    // See TODO in setOpacity.
    style.filter = '';
  } else {
    // Set style properties individually instead of using background shorthand
    // to prevent overwriting a pre-existing background color.
    style.backgroundImage = 'none';
  }
};


/**
 * Shows or hides an element from the page. Hiding the element is done by
 * setting the display property to "none", removing the element from the
 * rendering hierarchy so it takes up no space. To show the element, the default
 * inherited display property is restored (defined either in stylesheets or by
 * the browser's default style rules.)
 *
 * Caveat 1: if the inherited display property for the element is set to "none"
 * by the stylesheets, that is the property that will be restored by a call to
 * showElement(), effectively toggling the display between "none" and "none".
 *
 * Caveat 2: if the element display style is set inline (by setting either
 * element.style.display or a style attribute in the HTML), a call to
 * showElement will clear that setting and defer to the inherited style in the
 * stylesheet.
 * @param {Element} el Element to show or hide.
 * @param {*} display True to render the element in its default style,
 *     false to disable rendering the element.
 * @deprecated Use goog.style.setElementShown instead.
 */
goog.style.showElement = function(el, display) {
  goog.style.setElementShown(el, display);
};


/**
 * Shows or hides an element from the page. Hiding the element is done by
 * setting the display property to "none", removing the element from the
 * rendering hierarchy so it takes up no space. To show the element, the default
 * inherited display property is restored (defined either in stylesheets or by
 * the browser's default style rules).
 *
 * Caveat 1: if the inherited display property for the element is set to "none"
 * by the stylesheets, that is the property that will be restored by a call to
 * setElementShown(), effectively toggling the display between "none" and
 * "none".
 *
 * Caveat 2: if the element display style is set inline (by setting either
 * element.style.display or a style attribute in the HTML), a call to
 * setElementShown will clear that setting and defer to the inherited style in
 * the stylesheet.
 * @param {Element} el Element to show or hide.
 * @param {*} isShown True to render the element in its default style,
 *     false to disable rendering the element.
 */
goog.style.setElementShown = function(el, isShown) {
  el.style.display = isShown ? '' : 'none';
};


/**
 * Test whether the given element has been shown or hidden via a call to
 * {@link #setElementShown}.
 *
 * Note this is strictly a companion method for a call
 * to {@link #setElementShown} and the same caveats apply; in particular, this
 * method does not guarantee that the return value will be consistent with
 * whether or not the element is actually visible.
 *
 * @param {Element} el The element to test.
 * @return {boolean} Whether the element has been shown.
 * @see #setElementShown
 */
goog.style.isElementShown = function(el) {
  return el.style.display != 'none';
};


/**
 * Installs the styles string into the window that contains opt_element.  If
 * opt_element is null, the main window is used.
 * @param {string} stylesString The style string to install.
 * @param {Node=} opt_node Node whose parent document should have the
 *     styles installed.
 * @return {Element|StyleSheet} The style element created.
 */
goog.style.installStyles = function(stylesString, opt_node) {
  var dh = goog.dom.getDomHelper(opt_node);
  var styleSheet = null;

  // IE < 11 requires createStyleSheet. Note that doc.createStyleSheet will be
  // undefined as of IE 11.
  var doc = dh.getDocument();
  if (goog.userAgent.IE && doc.createStyleSheet) {
    styleSheet = doc.createStyleSheet();
    goog.style.setStyles(styleSheet, stylesString);
  } else {
    var head = dh.getElementsByTagNameAndClass('head')[0];

    // In opera documents are not guaranteed to have a head element, thus we
    // have to make sure one exists before using it.
    if (!head) {
      var body = dh.getElementsByTagNameAndClass('body')[0];
      head = dh.createDom('head');
      body.parentNode.insertBefore(head, body);
    }
    styleSheet = dh.createDom('style');
    // NOTE(user): Setting styles after the style element has been appended
    // to the head results in a nasty Webkit bug in certain scenarios. Please
    // refer to https://bugs.webkit.org/show_bug.cgi?id=26307 for additional
    // details.
    goog.style.setStyles(styleSheet, stylesString);
    dh.appendChild(head, styleSheet);
  }
  return styleSheet;
};


/**
 * Removes the styles added by {@link #installStyles}.
 * @param {Element|StyleSheet} styleSheet The value returned by
 *     {@link #installStyles}.
 */
goog.style.uninstallStyles = function(styleSheet) {
  var node = styleSheet.ownerNode || styleSheet.owningElement ||
      /** @type {Element} */ (styleSheet);
  goog.dom.removeNode(node);
};


/**
 * Sets the content of a style element.  The style element can be any valid
 * style element.  This element will have its content completely replaced by
 * the new stylesString.
 * @param {Element|StyleSheet} element A stylesheet element as returned by
 *     installStyles.
 * @param {string} stylesString The new content of the stylesheet.
 */
goog.style.setStyles = function(element, stylesString) {
  if (goog.userAgent.IE && goog.isDef(element.cssText)) {
    // Adding the selectors individually caused the browser to hang if the
    // selector was invalid or there were CSS comments.  Setting the cssText of
    // the style node works fine and ignores CSS that IE doesn't understand.
    // However IE >= 11 doesn't support cssText any more, so we make sure that
    // cssText is a defined property and otherwise fall back to innerHTML.
    element.cssText = stylesString;
  } else {
    element.innerHTML = stylesString;
  }
};


/**
 * Sets 'white-space: pre-wrap' for a node (x-browser).
 *
 * There are as many ways of specifying pre-wrap as there are browsers.
 *
 * CSS3/IE8: white-space: pre-wrap;
 * Mozilla:  white-space: -moz-pre-wrap;
 * Opera:    white-space: -o-pre-wrap;
 * IE6/7:    white-space: pre; word-wrap: break-word;
 *
 * @param {Element} el Element to enable pre-wrap for.
 */
goog.style.setPreWrap = function(el) {
  var style = el.style;
  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
    style.whiteSpace = 'pre';
    style.wordWrap = 'break-word';
  } else if (goog.userAgent.GECKO) {
    style.whiteSpace = '-moz-pre-wrap';
  } else {
    style.whiteSpace = 'pre-wrap';
  }
};


/**
 * Sets 'display: inline-block' for an element (cross-browser).
 * @param {Element} el Element to which the inline-block display style is to be
 *    applied.
 * @see ../demos/inline_block_quirks.html
 * @see ../demos/inline_block_standards.html
 */
goog.style.setInlineBlock = function(el) {
  var style = el.style;
  // Without position:relative, weirdness ensues.  Just accept it and move on.
  style.position = 'relative';

  if (goog.userAgent.IE && !goog.userAgent.isVersionOrHigher('8')) {
    // IE8 supports inline-block so fall through to the else
    // Zoom:1 forces hasLayout, display:inline gives inline behavior.
    style.zoom = '1';
    style.display = 'inline';
  } else if (goog.userAgent.GECKO) {
    // Pre-Firefox 3, Gecko doesn't support inline-block, but -moz-inline-box
    // is close enough.
    style.display = goog.userAgent.isVersionOrHigher('1.9a') ? 'inline-block' :
        '-moz-inline-box';
  } else {
    // Opera, Webkit, and Safari seem to do OK with the standard inline-block
    // style.
    style.display = 'inline-block';
  }
};


/**
 * Returns true if the element is using right to left (rtl) direction.
 * @param {Element} el  The element to test.
 * @return {boolean} True for right to left, false for left to right.
 */
goog.style.isRightToLeft = function(el) {
  return 'rtl' == goog.style.getStyle_(el, 'direction');
};


/**
 * The CSS style property corresponding to an element being
 * unselectable on the current browser platform (null if none).
 * Opera and IE instead use a DOM attribute 'unselectable'.
 * @type {?string}
 * @private
 */
goog.style.unselectableStyle_ =
    goog.userAgent.GECKO ? 'MozUserSelect' :
    goog.userAgent.WEBKIT ? 'WebkitUserSelect' :
    null;


/**
 * Returns true if the element is set to be unselectable, false otherwise.
 * Note that on some platforms (e.g. Mozilla), even if an element isn't set
 * to be unselectable, it will behave as such if any of its ancestors is
 * unselectable.
 * @param {Element} el  Element to check.
 * @return {boolean}  Whether the element is set to be unselectable.
 */
goog.style.isUnselectable = function(el) {
  if (goog.style.unselectableStyle_) {
    return el.style[goog.style.unselectableStyle_].toLowerCase() == 'none';
  } else if (goog.userAgent.IE || goog.userAgent.OPERA) {
    return el.getAttribute('unselectable') == 'on';
  }
  return false;
};


/**
 * Makes the element and its descendants selectable or unselectable.  Note
 * that on some platforms (e.g. Mozilla), even if an element isn't set to
 * be unselectable, it will behave as such if any of its ancestors is
 * unselectable.
 * @param {Element} el  The element to alter.
 * @param {boolean} unselectable  Whether the element and its descendants
 *     should be made unselectable.
 * @param {boolean=} opt_noRecurse  Whether to only alter the element's own
 *     selectable state, and leave its descendants alone; defaults to false.
 */
goog.style.setUnselectable = function(el, unselectable, opt_noRecurse) {
  // TODO(attila): Do we need all of TR_DomUtil.makeUnselectable() in Closure?
  var descendants = !opt_noRecurse ? el.getElementsByTagName('*') : null;
  var name = goog.style.unselectableStyle_;
  if (name) {
    // Add/remove the appropriate CSS style to/from the element and its
    // descendants.
    var value = unselectable ? 'none' : '';
    el.style[name] = value;
    if (descendants) {
      for (var i = 0, descendant; descendant = descendants[i]; i++) {
        descendant.style[name] = value;
      }
    }
  } else if (goog.userAgent.IE || goog.userAgent.OPERA) {
    // Toggle the 'unselectable' attribute on the element and its descendants.
    var value = unselectable ? 'on' : '';
    el.setAttribute('unselectable', value);
    if (descendants) {
      for (var i = 0, descendant; descendant = descendants[i]; i++) {
        descendant.setAttribute('unselectable', value);
      }
    }
  }
};


/**
 * Gets the border box size for an element.
 * @param {Element} element  The element to get the size for.
 * @return {!goog.math.Size} The border box size.
 */
goog.style.getBorderBoxSize = function(element) {
  return new goog.math.Size(element.offsetWidth, element.offsetHeight);
};


/**
 * Sets the border box size of an element. This is potentially expensive in IE
 * if the document is CSS1Compat mode
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size.
 */
goog.style.setBorderBoxSize = function(element, size) {
  var doc = goog.dom.getOwnerDocument(element);
  var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();

  if (goog.userAgent.IE &&
      (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher('8'))) {
    var style = element.style;
    if (isCss1CompatMode) {
      var paddingBox = goog.style.getPaddingBox(element);
      var borderBox = goog.style.getBorderBox(element);
      style.pixelWidth = size.width - borderBox.left - paddingBox.left -
                         paddingBox.right - borderBox.right;
      style.pixelHeight = size.height - borderBox.top - paddingBox.top -
                          paddingBox.bottom - borderBox.bottom;
    } else {
      style.pixelWidth = size.width;
      style.pixelHeight = size.height;
    }
  } else {
    goog.style.setBoxSizingSize_(element, size, 'border-box');
  }
};


/**
 * Gets the content box size for an element.  This is potentially expensive in
 * all browsers.
 * @param {Element} element  The element to get the size for.
 * @return {!goog.math.Size} The content box size.
 */
goog.style.getContentBoxSize = function(element) {
  var doc = goog.dom.getOwnerDocument(element);
  var ieCurrentStyle = goog.userAgent.IE && element.currentStyle;
  if (ieCurrentStyle &&
      goog.dom.getDomHelper(doc).isCss1CompatMode() &&
      ieCurrentStyle.width != 'auto' && ieCurrentStyle.height != 'auto' &&
      !ieCurrentStyle.boxSizing) {
    // If IE in CSS1Compat mode than just use the width and height.
    // If we have a boxSizing then fall back on measuring the borders etc.
    var width = goog.style.getIePixelValue_(element, ieCurrentStyle.width,
                                            'width', 'pixelWidth');
    var height = goog.style.getIePixelValue_(element, ieCurrentStyle.height,
                                             'height', 'pixelHeight');
    return new goog.math.Size(width, height);
  } else {
    var borderBoxSize = goog.style.getBorderBoxSize(element);
    var paddingBox = goog.style.getPaddingBox(element);
    var borderBox = goog.style.getBorderBox(element);
    return new goog.math.Size(borderBoxSize.width -
                              borderBox.left - paddingBox.left -
                              paddingBox.right - borderBox.right,
                              borderBoxSize.height -
                              borderBox.top - paddingBox.top -
                              paddingBox.bottom - borderBox.bottom);
  }
};


/**
 * Sets the content box size of an element. This is potentially expensive in IE
 * if the document is BackCompat mode.
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size.
 */
goog.style.setContentBoxSize = function(element, size) {
  var doc = goog.dom.getOwnerDocument(element);
  var isCss1CompatMode = goog.dom.getDomHelper(doc).isCss1CompatMode();
  if (goog.userAgent.IE &&
      (!isCss1CompatMode || !goog.userAgent.isVersionOrHigher('8'))) {
    var style = element.style;
    if (isCss1CompatMode) {
      style.pixelWidth = size.width;
      style.pixelHeight = size.height;
    } else {
      var paddingBox = goog.style.getPaddingBox(element);
      var borderBox = goog.style.getBorderBox(element);
      style.pixelWidth = size.width + borderBox.left + paddingBox.left +
                         paddingBox.right + borderBox.right;
      style.pixelHeight = size.height + borderBox.top + paddingBox.top +
                          paddingBox.bottom + borderBox.bottom;
    }
  } else {
    goog.style.setBoxSizingSize_(element, size, 'content-box');
  }
};


/**
 * Helper function that sets the box sizing as well as the width and height
 * @param {Element} element  The element to set the size on.
 * @param {goog.math.Size} size  The new size to set.
 * @param {string} boxSizing  The box-sizing value.
 * @private
 */
goog.style.setBoxSizingSize_ = function(element, size, boxSizing) {
  var style = element.style;
  if (goog.userAgent.GECKO) {
    style.MozBoxSizing = boxSizing;
  } else if (goog.userAgent.WEBKIT) {
    style.WebkitBoxSizing = boxSizing;
  } else {
    // Includes IE8 and Opera 9.50+
    style.boxSizing = boxSizing;
  }

  // Setting this to a negative value will throw an exception on IE
  // (and doesn't do anything different than setting it to 0).
  style.width = Math.max(size.width, 0) + 'px';
  style.height = Math.max(size.height, 0) + 'px';
};


/**
 * IE specific function that converts a non pixel unit to pixels.
 * @param {Element} element  The element to convert the value for.
 * @param {string} value  The current value as a string. The value must not be
 *     ''.
 * @param {string} name  The CSS property name to use for the converstion. This
 *     should be 'left', 'top', 'width' or 'height'.
 * @param {string} pixelName  The CSS pixel property name to use to get the
 *     value in pixels.
 * @return {number} The value in pixels.
 * @private
 */
goog.style.getIePixelValue_ = function(element, value, name, pixelName) {
  // Try if we already have a pixel value. IE does not do half pixels so we
  // only check if it matches a number followed by 'px'.
  if (/^\d+px?$/.test(value)) {
    return parseInt(value, 10);
  } else {
    var oldStyleValue = element.style[name];
    var oldRuntimeValue = element.runtimeStyle[name];
    // set runtime style to prevent changes
    element.runtimeStyle[name] = element.currentStyle[name];
    element.style[name] = value;
    var pixelValue = element.style[pixelName];
    // restore
    element.style[name] = oldStyleValue;
    element.runtimeStyle[name] = oldRuntimeValue;
    return pixelValue;
  }
};


/**
 * Helper function for getting the pixel padding or margin for IE.
 * @param {Element} element  The element to get the padding for.
 * @param {string} propName  The property name.
 * @return {number} The pixel padding.
 * @private
 */
goog.style.getIePixelDistance_ = function(element, propName) {
  var value = goog.style.getCascadedStyle(element, propName);
  return value ?
      goog.style.getIePixelValue_(element, value, 'left', 'pixelLeft') : 0;
};


/**
 * Gets the computed paddings or margins (on all sides) in pixels.
 * @param {Element} element  The element to get the padding for.
 * @param {string} stylePrefix  Pass 'padding' to retrieve the padding box,
 *     or 'margin' to retrieve the margin box.
 * @return {!goog.math.Box} The computed paddings or margins.
 * @private
 */
goog.style.getBox_ = function(element, stylePrefix) {
  if (goog.userAgent.IE) {
    var left = goog.style.getIePixelDistance_(element, stylePrefix + 'Left');
    var right = goog.style.getIePixelDistance_(element, stylePrefix + 'Right');
    var top = goog.style.getIePixelDistance_(element, stylePrefix + 'Top');
    var bottom = goog.style.getIePixelDistance_(
        element, stylePrefix + 'Bottom');
    return new goog.math.Box(top, right, bottom, left);
  } else {
    // On non-IE browsers, getComputedStyle is always non-null.
    var left = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Left'));
    var right = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Right'));
    var top = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Top'));
    var bottom = /** @type {string} */ (
        goog.style.getComputedStyle(element, stylePrefix + 'Bottom'));

    // NOTE(arv): Gecko can return floating point numbers for the computed
    // style values.
    return new goog.math.Box(parseFloat(top),
                             parseFloat(right),
                             parseFloat(bottom),
                             parseFloat(left));
  }
};


/**
 * Gets the computed paddings (on all sides) in pixels.
 * @param {Element} element  The element to get the padding for.
 * @return {!goog.math.Box} The computed paddings.
 */
goog.style.getPaddingBox = function(element) {
  return goog.style.getBox_(element, 'padding');
};


/**
 * Gets the computed margins (on all sides) in pixels.
 * @param {Element} element  The element to get the margins for.
 * @return {!goog.math.Box} The computed margins.
 */
goog.style.getMarginBox = function(element) {
  return goog.style.getBox_(element, 'margin');
};


/**
 * A map used to map the border width keywords to a pixel width.
 * @type {Object}
 * @private
 */
goog.style.ieBorderWidthKeywords_ = {
  'thin': 2,
  'medium': 4,
  'thick': 6
};


/**
 * Helper function for IE to get the pixel border.
 * @param {Element} element  The element to get the pixel border for.
 * @param {string} prop  The part of the property name.
 * @return {number} The value in pixels.
 * @private
 */
goog.style.getIePixelBorder_ = function(element, prop) {
  if (goog.style.getCascadedStyle(element, prop + 'Style') == 'none') {
    return 0;
  }
  var width = goog.style.getCascadedStyle(element, prop + 'Width');
  if (width in goog.style.ieBorderWidthKeywords_) {
    return goog.style.ieBorderWidthKeywords_[width];
  }
  return goog.style.getIePixelValue_(element, width, 'left', 'pixelLeft');
};


/**
 * Gets the computed border widths (on all sides) in pixels
 * @param {Element} element  The element to get the border widths for.
 * @return {!goog.math.Box} The computed border widths.
 */
goog.style.getBorderBox = function(element) {
  if (goog.userAgent.IE && !goog.userAgent.isDocumentModeOrHigher(9)) {
    var left = goog.style.getIePixelBorder_(element, 'borderLeft');
    var right = goog.style.getIePixelBorder_(element, 'borderRight');
    var top = goog.style.getIePixelBorder_(element, 'borderTop');
    var bottom = goog.style.getIePixelBorder_(element, 'borderBottom');
    return new goog.math.Box(top, right, bottom, left);
  } else {
    // On non-IE browsers, getComputedStyle is always non-null.
    var left = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderLeftWidth'));
    var right = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderRightWidth'));
    var top = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderTopWidth'));
    var bottom = /** @type {string} */ (
        goog.style.getComputedStyle(element, 'borderBottomWidth'));

    return new goog.math.Box(parseFloat(top),
                             parseFloat(right),
                             parseFloat(bottom),
                             parseFloat(left));
  }
};


/**
 * Returns the font face applied to a given node. Opera and IE should return
 * the font actually displayed. Firefox returns the author's most-preferred
 * font (whether the browser is capable of displaying it or not.)
 * @param {Element} el  The element whose font family is returned.
 * @return {string} The font family applied to el.
 */
goog.style.getFontFamily = function(el) {
  var doc = goog.dom.getOwnerDocument(el);
  var font = '';
  // The moveToElementText method from the TextRange only works if the element
  // is attached to the owner document.
  if (doc.body.createTextRange && goog.dom.contains(doc, el)) {
    var range = doc.body.createTextRange();
    range.moveToElementText(el);
    /** @preserveTry */
    try {
      font = range.queryCommandValue('FontName');
    } catch (e) {
      // This is a workaround for a awkward exception.
      // On some IE, there is an exception coming from it.
      // The error description from this exception is:
      // This window has already been registered as a drop target
      // This is bogus description, likely due to a bug in ie.
      font = '';
    }
  }
  if (!font) {
    // Note if for some reason IE can't derive FontName with a TextRange, we
    // fallback to using currentStyle
    font = goog.style.getStyle_(el, 'fontFamily');
  }

  // Firefox returns the applied font-family string (author's list of
  // preferred fonts.) We want to return the most-preferred font, in lieu of
  // the *actually* applied font.
  var fontsArray = font.split(',');
  if (fontsArray.length > 1) font = fontsArray[0];

  // Sanitize for x-browser consistency:
  // Strip quotes because browsers aren't consistent with how they're
  // applied; Opera always encloses, Firefox sometimes, and IE never.
  return goog.string.stripQuotes(font, '"\'');
};


/**
 * Regular expression used for getLengthUnits.
 * @type {RegExp}
 * @private
 */
goog.style.lengthUnitRegex_ = /[^\d]+$/;


/**
 * Returns the units used for a CSS length measurement.
 * @param {string} value  A CSS length quantity.
 * @return {?string} The units of measurement.
 */
goog.style.getLengthUnits = function(value) {
  var units = value.match(goog.style.lengthUnitRegex_);
  return units && units[0] || null;
};


/**
 * Map of absolute CSS length units
 * @type {Object}
 * @private
 */
goog.style.ABSOLUTE_CSS_LENGTH_UNITS_ = {
  'cm' : 1,
  'in' : 1,
  'mm' : 1,
  'pc' : 1,
  'pt' : 1
};


/**
 * Map of relative CSS length units that can be accurately converted to px
 * font-size values using getIePixelValue_. Only units that are defined in
 * relation to a font size are convertible (%, small, etc. are not).
 * @type {Object}
 * @private
 */
goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_ = {
  'em' : 1,
  'ex' : 1
};


/**
 * Returns the font size, in pixels, of text in an element.
 * @param {Element} el  The element whose font size is returned.
 * @return {number} The font size (in pixels).
 */
goog.style.getFontSize = function(el) {
  var fontSize = goog.style.getStyle_(el, 'fontSize');
  var sizeUnits = goog.style.getLengthUnits(fontSize);
  if (fontSize && 'px' == sizeUnits) {
    // NOTE(user): This could be parseFloat instead, but IE doesn't return
    // decimal fractions in getStyle_ and Firefox reports the fractions, but
    // ignores them when rendering. Interestingly enough, when we force the
    // issue and size something to e.g., 50% of 25px, the browsers round in
    // opposite directions with Firefox reporting 12px and IE 13px. I punt.
    return parseInt(fontSize, 10);
  }

  // In IE, we can convert absolute length units to a px value using
  // goog.style.getIePixelValue_. Units defined in relation to a font size
  // (em, ex) are applied relative to the element's parentNode and can also
  // be converted.
  if (goog.userAgent.IE) {
    if (sizeUnits in goog.style.ABSOLUTE_CSS_LENGTH_UNITS_) {
      return goog.style.getIePixelValue_(el,
                                         fontSize,
                                         'left',
                                         'pixelLeft');
    } else if (el.parentNode &&
               el.parentNode.nodeType == goog.dom.NodeType.ELEMENT &&
               sizeUnits in goog.style.CONVERTIBLE_RELATIVE_CSS_UNITS_) {
      // Check the parent size - if it is the same it means the relative size
      // value is inherited and we therefore don't want to count it twice.  If
      // it is different, this element either has explicit style or has a CSS
      // rule applying to it.
      var parentElement = /** @type {Element} */ (el.parentNode);
      var parentSize = goog.style.getStyle_(parentElement, 'fontSize');
      return goog.style.getIePixelValue_(parentElement,
                                         fontSize == parentSize ?
                                             '1em' : fontSize,
                                         'left',
                                         'pixelLeft');
    }
  }

  // Sometimes we can't cleanly find the font size (some units relative to a
  // node's parent's font size are difficult: %, smaller et al), so we create
  // an invisible, absolutely-positioned span sized to be the height of an 'M'
  // rendered in its parent's (i.e., our target element's) font size. This is
  // the definition of CSS's font size attribute.
  var sizeElement = goog.dom.createDom(
      'span',
      {'style': 'visibility:hidden;position:absolute;' +
            'line-height:0;padding:0;margin:0;border:0;height:1em;'});
  goog.dom.appendChild(el, sizeElement);
  fontSize = sizeElement.offsetHeight;
  goog.dom.removeNode(sizeElement);

  return fontSize;
};


/**
 * Parses a style attribute value.  Converts CSS property names to camel case.
 * @param {string} value The style attribute value.
 * @return {!Object} Map of CSS properties to string values.
 */
goog.style.parseStyleAttribute = function(value) {
  var result = {};
  goog.array.forEach(value.split(/\s*;\s*/), function(pair) {
    var keyValue = pair.split(/\s*:\s*/);
    if (keyValue.length == 2) {
      result[goog.string.toCamelCase(keyValue[0].toLowerCase())] = keyValue[1];
    }
  });
  return result;
};


/**
 * Reverse of parseStyleAttribute; that is, takes a style object and returns the
 * corresponding attribute value.  Converts camel case property names to proper
 * CSS selector names.
 * @param {Object} obj Map of CSS properties to values.
 * @return {string} The style attribute value.
 */
goog.style.toStyleAttribute = function(obj) {
  var buffer = [];
  goog.object.forEach(obj, function(value, key) {
    buffer.push(goog.string.toSelectorCase(key), ':', value, ';');
  });
  return buffer.join('');
};


/**
 * Sets CSS float property on an element.
 * @param {Element} el The element to set float property on.
 * @param {string} value The value of float CSS property to set on this element.
 */
goog.style.setFloat = function(el, value) {
  el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] = value;
};


/**
 * Gets value of explicitly-set float CSS property on an element.
 * @param {Element} el The element to get float property of.
 * @return {string} The value of explicitly-set float CSS property on this
 *     element.
 */
goog.style.getFloat = function(el) {
  return el.style[goog.userAgent.IE ? 'styleFloat' : 'cssFloat'] || '';
};


/**
 * Returns the scroll bar width (represents the width of both horizontal
 * and vertical scroll).
 *
 * @param {string=} opt_className An optional class name (or names) to apply
 *     to the invisible div created to measure the scrollbar. This is necessary
 *     if some scrollbars are styled differently than others.
 * @return {number} The scroll bar width in px.
 */
goog.style.getScrollbarWidth = function(opt_className) {
  // Add two hidden divs.  The child div is larger than the parent and
  // forces scrollbars to appear on it.
  // Using overflow:scroll does not work consistently with scrollbars that
  // are styled with ::-webkit-scrollbar.
  var outerDiv = goog.dom.createElement('div');
  if (opt_className) {
    outerDiv.className = opt_className;
  }
  outerDiv.style.cssText = 'overflow:auto;' +
      'position:absolute;top:0;width:100px;height:100px';
  var innerDiv = goog.dom.createElement('div');
  goog.style.setSize(innerDiv, '200px', '200px');
  outerDiv.appendChild(innerDiv);
  goog.dom.appendChild(goog.dom.getDocument().body, outerDiv);
  var width = outerDiv.offsetWidth - outerDiv.clientWidth;
  goog.dom.removeNode(outerDiv);
  return width;
};


/**
 * Regular expression to extract x and y translation components from a CSS
 * transform Matrix representation.
 *
 * @type {!RegExp}
 * @const
 * @private
 */
goog.style.MATRIX_TRANSLATION_REGEX_ =
    new RegExp('matrix\\([0-9\\.\\-]+, [0-9\\.\\-]+, ' +
               '[0-9\\.\\-]+, [0-9\\.\\-]+, ' +
               '([0-9\\.\\-]+)p?x?, ([0-9\\.\\-]+)p?x?\\)');


/**
 * Returns the x,y translation component of any CSS transforms applied to the
 * element, in pixels.
 *
 * @param {!Element} element The element to get the translation of.
 * @return {!goog.math.Coordinate} The CSS translation of the element in px.
 */
goog.style.getCssTranslation = function(element) {
  var transform = goog.style.getComputedTransform(element);
  if (!transform) {
    return new goog.math.Coordinate(0, 0);
  }
  var matches = transform.match(goog.style.MATRIX_TRANSLATION_REGEX_);
  if (!matches) {
    return new goog.math.Coordinate(0, 0);
  }
  return new goog.math.Coordinate(parseFloat(matches[1]),
                                  parseFloat(matches[2]));
};
// Copyright 2006 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @fileoverview This event wrapper will dispatch an event when the user uses
 * the mouse wheel to scroll an element. You can get the direction by checking
 * the deltaX and deltaY properties of the event.
 *
 * This class aims to smooth out inconsistencies between browser platforms with
 * regards to mousewheel events, but we do not cover every possible
 * software/hardware combination out there, some of which occasionally produce
 * very large deltas in mousewheel events. If your application wants to guard
 * against extremely large deltas, use the setMaxDeltaX and setMaxDeltaY APIs
 * to set maximum values that make sense for your application.
 *
 * @author arv@google.com (Erik Arvidsson)
 * @see ../demos/mousewheelhandler.html
 */

goog.provide('goog.events.MouseWheelEvent');
goog.provide('goog.events.MouseWheelHandler');
goog.provide('goog.events.MouseWheelHandler.EventType');

goog.require('goog.dom');
goog.require('goog.events');
goog.require('goog.events.BrowserEvent');
goog.require('goog.events.EventTarget');
goog.require('goog.math');
goog.require('goog.style');
goog.require('goog.userAgent');



/**
 * This event handler allows you to catch mouse wheel events in a consistent
 * manner.
 * @param {Element|Document} element The element to listen to the mouse wheel
 *     event on.
 * @param {boolean=} opt_capture Whether to handle the mouse wheel event in
 *     capture phase.
 * @constructor
 * @extends {goog.events.EventTarget}
 */
goog.events.MouseWheelHandler = function(element, opt_capture) {
  goog.events.EventTarget.call(this);

  /**
   * This is the element that we will listen to the real mouse wheel events on.
   * @type {Element|Document}
   * @private
   */
  this.element_ = element;

  var rtlElement = goog.dom.isElement(this.element_) ?
      /** @type {Element} */ (this.element_) :
      (this.element_ ? /** @type {Document} */ (this.element_).body : null);

  /**
   * True if the element exists and is RTL, false otherwise.
   * @type {boolean}
   * @private
   */
  this.isRtl_ = !!rtlElement && goog.style.isRightToLeft(rtlElement);

  var type = goog.userAgent.GECKO ? 'DOMMouseScroll' : 'mousewheel';

  /**
   * The key returned from the goog.events.listen.
   * @type {goog.events.Key}
   * @private
   */
  this.listenKey_ = goog.events.listen(this.element_, type, this, opt_capture);
};
goog.inherits(goog.events.MouseWheelHandler, goog.events.EventTarget);


/**
 * Enum type for the events fired by the mouse wheel handler.
 * @enum {string}
 */
goog.events.MouseWheelHandler.EventType = {
  MOUSEWHEEL: 'mousewheel'
};


/**
 * Optional maximum magnitude for x delta on each mousewheel event.
 * @type {number|undefined}
 * @private
 */
goog.events.MouseWheelHandler.prototype.maxDeltaX_;


/**
 * Optional maximum magnitude for y delta on each mousewheel event.
 * @type {number|undefined}
 * @private
 */
goog.events.MouseWheelHandler.prototype.maxDeltaY_;


/**
 * @param {number} maxDeltaX Maximum magnitude for x delta on each mousewheel
 *     event. Should be non-negative.
 */
goog.events.MouseWheelHandler.prototype.setMaxDeltaX = function(maxDeltaX) {
  this.maxDeltaX_ = maxDeltaX;
};


/**
 * @param {number} maxDeltaY Maximum magnitude for y delta on each mousewheel
 *     event. Should be non-negative.
 */
goog.events.MouseWheelHandler.prototype.setMaxDeltaY = function(maxDeltaY) {
  this.maxDeltaY_ = maxDeltaY;
};


/**
 * Handles the events on the element.
 * @param {goog.events.BrowserEvent} e The underlying browser event.
 */
goog.events.MouseWheelHandler.prototype.handleEvent = function(e) {
  var deltaX = 0;
  var deltaY = 0;
  var detail = 0;
  var be = e.getBrowserEvent();
  if (be.type == 'mousewheel') {
    var wheelDeltaScaleFactor = 1;
    if (goog.userAgent.IE ||
        goog.userAgent.WEBKIT &&
        (goog.userAgent.WINDOWS || goog.userAgent.isVersionOrHigher('532.0'))) {
      // In IE we get a multiple of 120; we adjust to a multiple of 3 to
      // represent number of lines scrolled (like Gecko).
      // Newer versions of Webkit match IE behavior, and WebKit on
      // Windows also matches IE behavior.
      // See bug https://bugs.webkit.org/show_bug.cgi?id=24368
      wheelDeltaScaleFactor = 40;
    }

    detail = goog.events.MouseWheelHandler.smartScale_(
        -be.wheelDelta, wheelDeltaScaleFactor);
    if (goog.isDef(be.wheelDeltaX)) {
      // Webkit has two properties to indicate directional scroll, and
      // can scroll both directions at once.
      deltaX = goog.events.MouseWheelHandler.smartScale_(
          -be.wheelDeltaX, wheelDeltaScaleFactor);
      deltaY = goog.events.MouseWheelHandler.smartScale_(
          -be.wheelDeltaY, wheelDeltaScaleFactor);
    } else {
      deltaY = detail;
    }

    // Historical note: Opera (pre 9.5) used to negate the detail value.
  } else { // Gecko
    // Gecko returns multiple of 3 (representing the number of lines scrolled)
    detail = be.detail;

    // Gecko sometimes returns really big values if the user changes settings to
    // scroll a whole page per scroll
    if (detail > 100) {
      detail = 3;
    } else if (detail < -100) {
      detail = -3;
    }

    // Firefox 3.1 adds an axis field to the event to indicate direction of
    // scroll.  See https://developer.mozilla.org/en/Gecko-Specific_DOM_Events
    if (goog.isDef(be.axis) && be.axis === be.HORIZONTAL_AXIS) {
      deltaX = detail;
    } else {
      deltaY = detail;
    }
  }

  if (goog.isNumber(this.maxDeltaX_)) {
    deltaX = goog.math.clamp(deltaX, -this.maxDeltaX_, this.maxDeltaX_);
  }
  if (goog.isNumber(this.maxDeltaY_)) {
    deltaY = goog.math.clamp(deltaY, -this.maxDeltaY_, this.maxDeltaY_);
  }
  // Don't clamp 'detail', since it could be ambiguous which axis it refers to
  // and because it's informally deprecated anyways.

  // For horizontal scrolling we need to flip the value for RTL grids.
  if (this.isRtl_) {
    deltaX = -deltaX;
  }
  var newEvent = new goog.events.MouseWheelEvent(detail, be, deltaX, deltaY);
  this.dispatchEvent(newEvent);
};


/**
 * Helper for scaling down a mousewheel delta by a scale factor, if appropriate.
 * @param {number} mouseWheelDelta Delta from a mouse wheel event. Expected to
 *     be an integer.
 * @param {number} scaleFactor Factor to scale the delta down by. Expected to
 *     be an integer.
 * @return {number} Scaled-down delta value, or the original delta if the
 *     scaleFactor does not appear to be applicable.
 * @private
 */
goog.events.MouseWheelHandler.smartScale_ = function(mouseWheelDelta,
    scaleFactor) {
  // The basic problem here is that in Webkit on Mac and Linux, we can get two
  // very different types of mousewheel events: from continuous devices
  // (touchpads, Mighty Mouse) or non-continuous devices (normal wheel mice).
  //
  // Non-continuous devices in Webkit get their wheel deltas scaled up to
  // behave like IE. Continuous devices return much smaller unscaled values
  // (which most of the time will not be cleanly divisible by the IE scale
  // factor), so we should not try to normalize them down.
  //
  // Detailed discussion:
  //   https://bugs.webkit.org/show_bug.cgi?id=29601
  //   http://trac.webkit.org/browser/trunk/WebKit/chromium/src/mac/WebInputEventFactory.mm#L1063
  if (goog.userAgent.WEBKIT &&
      (goog.userAgent.MAC || goog.userAgent.LINUX) &&
      (mouseWheelDelta % scaleFactor) != 0) {
    return mouseWheelDelta;
  } else {
    return mouseWheelDelta / scaleFactor;
  }
};


/** @override */
goog.events.MouseWheelHandler.prototype.disposeInternal = function() {
  goog.events.MouseWheelHandler.superClass_.disposeInternal.call(this);
  goog.events.unlistenByKey(this.listenKey_);
  this.listenKey_ = null;
};



/**
 * A base class for mouse wheel events. This is used with the
 * MouseWheelHandler.
 *
 * @param {number} detail The number of rows the user scrolled.
 * @param {Event} browserEvent Browser event object.
 * @param {number} deltaX The number of rows the user scrolled in the X
 *     direction.
 * @param {number} deltaY The number of rows the user scrolled in the Y
 *     direction.
 * @constructor
 * @extends {goog.events.BrowserEvent}
 * @final
 */
goog.events.MouseWheelEvent = function(detail, browserEvent, deltaX, deltaY) {
  goog.events.BrowserEvent.call(this, browserEvent);

  this.type = goog.events.MouseWheelHandler.EventType.MOUSEWHEEL;

  /**
   * The number of lines the user scrolled
   * @type {number}
   * NOTE: Informally deprecated. Use deltaX and deltaY instead, they provide
   * more information.
   */
  this.detail = detail;

  /**
   * The number of "lines" scrolled in the X direction.
   *
   * Note that not all browsers provide enough information to distinguish
   * horizontal and vertical scroll events, so for these unsupported browsers,
   * we will always have a deltaX of 0, even if the user scrolled their mouse
   * wheel or trackpad sideways.
   *
   * Currently supported browsers are Webkit and Firefox 3.1 or later.
   *
   * @type {number}
   */
  this.deltaX = deltaX;

  /**
   * The number of lines scrolled in the Y direction.
   * @type {number}
   */
  this.deltaY = deltaY;
};
goog.inherits(goog.events.MouseWheelEvent, goog.events.BrowserEvent);
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.TrackBallView');

goog.require('goog.events.MouseWheelEvent');
goog.require('goog.events.MouseWheelHandler');
goog.require('lgb.world.view.BaseV');


/**
 * @constructor
 * @extends lgb.world.view.BaseV
 * @param {Object} camera The object to use usually the camera.
 * @param {Element} domElement The div to use as a touch pad.
 */
lgb.world.view.TrackBallView = function( camera) {
    

  /**@constant **/
  this._SENSITIVITY = -0.4;
  
  lgb.world.view.BaseV.call(this, null, "TrackBallView",  lgb.core.Config.WEBGL_CONTAINER_DIV_ID);

  var p = this.getParentElement();
  this.domElement_ = p.get(0);
  lgb.assert(this.domElement_);
  
  this.camera_ = camera;

  /**@type {THREE.TrackballControlsEx} */
  this.trackballControls = new THREE.TrackballControlsEx(camera, this.domElement_);
  
  this.init_();
};
goog.inherits(lgb.world.view.TrackBallView, lgb.world.view.BaseV);


/**
 * Initializes the TrackballControls
 * @private
 */
lgb.world.view.TrackBallView.prototype.init_ = function() {

  this.trackballControls.rotateSpeed = 1.0;
  this.trackballControls.zoomSpeed = 1.2;
  this.trackballControls.panSpeed = 0.8;

  this.trackballControls.staticMoving = true;
  this.trackballControls.dynamicDampingFactor = 0.3;

  this.orbitRadius = 30;

  this.bind_();
};


/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.view.TrackBallView.prototype.bind_ = function() {

  this.listen(e.RenderNotify, this.d(this.onRender));

  this.mouseWheelHander = new goog.events.MouseWheelHandler(this.domElement_);

  this.listenKey_ = this.listenTo(
    this.mouseWheelHander,
    goog.events.MouseWheelHandler.EventType.MOUSEWHEEL,
    this.d(this.onMouseWheel_)
  );
};


/**
 * @param {THREE.Vector3} target The target to look at.
 */
lgb.world.view.TrackBallView.prototype.setCameraTarget = function(target) {

  if (undefined === target) {
     this.trackballControls.target = new THREE.Vector3(0, 0, 0);
  } else {
    this.trackballControls.target = target;
  }

};


/**
 * //TODO (Raj) Get this dispose to work and test memory footprint.
 * experimental
 */
lgb.world.view.TrackBallView.prototype.disposeInternal = function() {
  
  if (this.listenKey_) {
    this.unlisten(this.listenKey_);
    delete this.listenKey_;
  }
};


/**
 * @private
 * @param {goog.events.MouseWheelEvent} event The event telling how
 * far the wheel has moved.
 */
lgb.world.view.TrackBallView.prototype.onMouseWheel_ = function(event) {

  var delta = event.deltaY * this._SENSITIVITY;

  if (delta) {
    this.trackballControls.zoomNow(delta);
  }
};


/**
 * Event handler for when the scene is rendered.
 * @param {e.RenderNotify} event The event fired by the
 * worldController.
 */
lgb.world.view.TrackBallView.prototype.onRender = function(event) {
  this.trackballControls.update();
};












/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.TrackBallController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.view.TrackBallView');

/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.TrackBallController = function( camera ) {

  lgb.core.BaseController.call(this);
  
  this.bind_();
  this.camera_= camera;
  
  this.view = new lgb.world.view.TrackBallView( camera);
  
};

goog.inherits(lgb.world.controller.TrackBallController, lgb.core.BaseController);

/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.TrackBallController.prototype.bind_ = function() {


  this.listen(
    e.RequestGoToViewpointNode,
    this.onRequestGoToViewpointNode_
  );
  
};


lgb.world.controller.TrackBallController.prototype.onRequestGoToViewpointNode_ =
  function(event) {
  
  var camera = event.payload.generateCamera();
  
  this.view.setCameraTarget(camera.lookAtPosition);

};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.BuildingHeightModel');

goog.require('lgb.world.model.BaseModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.BuildingHeightModel = function(topFloorMaxY,topFloorMinY) {

  /**@const */
  this._TITLE = 'Building';
  lgb.world.model.BaseModel.call(this);
  
  this.topFloorMaxY = topFloorMaxY;
  this.topFloorMinY = topFloorMinY;

  this.floorToCeilingHeight = topFloorMaxY - topFloorMinY;
  
  this.activeFloorMaxY = this.topFloorMaxY - this.floorToCeilingHeight;
  this.activeFloorMinY = this.topFloorMinY - this.floorToCeilingHeight;
  

};
goog.inherits(lgb.world.model.BuildingHeightModel, lgb.world.model.BaseModel);

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.ViewpointView');

;


goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.model.vo.ViewpointNode');



lgb.world.view.ViewpointView = function(dataModel) {
    

  this._ASSETS_FOLDER = 'viewpoints';
  this._TITLE = 'Custom Viewpoints';
  
  lgb.world.view.BaseWorldView.call(this, dataModel);

  
};
goog.inherits(lgb.world.view.ViewpointView,lgb.world.view.BaseWorldView);




/**
 * Event handler called when the the scene is loaded.
 * @param {Object} result From the THREE.js lib.
 * @private
 */
lgb.world.view.ViewpointView.prototype.onSceneLoadedBase_ = function(result) {

  this.scene_ = result.scene;
  this.groups_ = result.groups;
  this.cameras_ = result.cameras;
  this.appData_ = result.appData;
  this.containers_ = result.containers;
  this.geometries_ = result.geometries;
  this.objects_ = result.objects;
  this.meshes_ = {};
  this.object3ds_ = {};
  
  this.masterGroup_.position = this.scene_.position;
  this.masterGroup_.rotation = this.scene_.rotation;
  this.masterGroup_.scale = this.scene_.scale;
  this.masterGroup_.viewpoint = "defaultScene";
  
  this.objectTypeMap_ = {
    Mesh : this.meshes_,
    Object3D : this.object3ds_
  };
  
  if ( !COMPILED  && lgb.core.Config.DEBUG_3D) {
    this.eachProperty(this.geometries_, this.analyzeOneGeometry_);
  }
 
  this.eachPropertyName(this.objects_, this.processOneObject_);
  
  if (this.containers_ != null) {
    this.placeContainers_();
  }
  
  if (this.onSceneLoaded_ !== undefined) {
    this.onSceneLoaded_();
  }
  
  this.requestAddToWorld(this.masterGroup_);
  delete this.loader_;
  
  this.triggerLocal(e.ViewInitialized);

};


/**
 * Event handler called by the base class when the scene is loaded
 * @private
 */
lgb.world.view.ViewpointView.prototype.onSceneLoaded_ = function() {

  
  var camList = [];
  var nodeList = [];
  var nodeListCeiling = [];
  
  for (var camName in this.cameras_) {
    
    if (undefined !== camName) {
      
        var theCamera = this.cameras_[camName];
        
        theCamera.position.add(this.scene_.position);
        theCamera.target.add(this.scene_.position);
        
        theCamera.name = camName;
        camList.push(theCamera);
        
        var node = new lgb.world.model.vo.ViewpointNode.makeFromCamera(theCamera);
        nodeList.push(node);
    }
  }
    var viewpointNode = new lgb.world.model.vo.ViewpointNode.makeFromArray (this._TITLE, nodeList, 1 );
    this.triggerLocal(e.ViewpointNodesLoaded, viewpointNode);
  
    var defaultNode = nodeList[0];
    defaultNode.updateWorldPositions();
    this.triggerLocal(e.RequestGoToViewpointNode, defaultNode);
    
    
};












/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.ViewpointGUI');

goog.require('lgb.world.model.ViewpointModel');
goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.core.Config');
goog.require('lgb.component.TreeDataSourceH');


/**
 * @constructor
 * @param {lgb.world.model.ViewpointModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.ViewpointGUI = function(dataModel) {
  
  this._TITLE = "Viewpoints";
  
  lgb.gui.view.BaseGUI.call(this, dataModel, 'ViewpointGUI');
  
  this.listenForChange_('viewpointNode');
};
goog.inherits(lgb.gui.view.ViewpointGUI, lgb.gui.view.BaseGUI);


/**
 * Initializes the View
 */
lgb.gui.view.ViewpointGUI.prototype.init = function() {
  
  this.treeComponent_ = null;
  this.treeDS_ = null;
  
  this.treeDSlist_ = [];

};

lgb.gui.view.ViewpointGUI.prototype.init2_ = function(viewpointNode) {
  
  this.treeDS_ = new lgb.component.TreeDataSourceH(viewpointNode, null, this.htmlID,  'tree', 'ViewpointTreeDataSourceH');
  
  var options =  (
    {
      events : {mouseOver:true}
    }
  );

  this.treeDS_.setOptions(options);
  this.treeComponent_ = new lgb.component.TreeH(this.treeDS_);
  
  var treeElement = this.treeComponent_.getHtml();
  this.append(treeElement);
  
  this.bind_();
  this.triggerLocal(e.RequestAddToTestingInput, this);
   
};





lgb.gui.view.ViewpointGUI.prototype.bind_ = function() {
  
  this.listenForChangeTargetInit_(this.treeDS_);
  this.listenForChange_('showKNode', this.treeDS_);
  this.listenForChange_('hideKNode', this.treeDS_);
  this.listenForChange_('selectedKNode', this.treeDS_);

};


lgb.gui.view.ViewpointGUI.prototype.onChange_selectedKNode_ = function(kNode) {
  

  var viewpointNode = this.dataModel.getViewpoint(kNode);
  
  if (null == viewpointNode) {
    debugger;
  } else {
    
    viewpointNode.updateWorldPositions();
                  
    if (null != viewpointNode) {
      this.triggerLocal(e.RequestGoToViewpointNode, viewpointNode);
    }
  }
};


lgb.gui.view.ViewpointGUI.prototype.onChange_hideKNode_ = function(kNode) {
  this.triggerRequestShowViewpoint_(kNode, false);
};


lgb.gui.view.ViewpointGUI.prototype.onChange_showKNode_ = function(kNode) {
  this.triggerRequestShowViewpoint_(kNode, true);
};


lgb.gui.view.ViewpointGUI.prototype.onChange_viewpointNode_ = function(viewpointNode) {
  
  if (this.treeDS_ == null) {
    this.init2_(viewpointNode);
  } else {
    this.treeDS_.update(viewpointNode);
  }

};


lgb.gui.view.ViewpointGUI.prototype.triggerRequestShowViewpoint_= function(kNode, isVisible) {

  var viewpointNode = this.dataModel.getViewpoint(kNode);
  if (null == viewpointNode) {
    debugger;
  } 
  
  if (null != viewpointNode && null != viewpointNode.parent) {
    
    if (viewpointNode.parent.title =="Zones") {
      viewpointNode.isVisible = isVisible;
      this.triggerLocal(e.RequestShowViewpoint, viewpointNode);
    }
  }

};





/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.controller.ViewpointController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.view.ViewpointView');
goog.require('lgb.world.model.ViewpointModel');
goog.require('lgb.gui.view.ViewpointGUI');

/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.ViewpointController = function( ) {

  lgb.core.BaseController.call(this);
  
  this.viewpointGroupsLoaded_ = 0;
  this.dataModel = new lgb.world.model.ViewpointModel();
  
};
goog.inherits(lgb.gui.controller.ViewpointController, lgb.core.BaseController);


/**
 * Initialized the controller.
 */
lgb.gui.controller.ViewpointController.prototype.init = function() {
  

  this.view = new lgb.world.view.ViewpointView(this.dataModel);

  this.guiView = new lgb.gui.view.ViewpointGUI (this.dataModel);
  this.guiView._TITLE = "Viewpoints";
  
  this.bind_();
  
  this.guiView.init();
  this.view.init();
  
};



/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.gui.controller.ViewpointController.prototype.bind_ = function() {
  

  this.relay(
    this.guiView,
    [
      e.RequestAddToTestingInput,
      e.RequestShowViewpoint,
      e.RequestGoToViewpointNode
    ]
    );
    
  this.relay(
    this.view,
    [e.ViewpointNodesLoaded, e.RequestGoToViewpointNode]
    );


};


lgb.gui.controller.ViewpointController.prototype.setAnchors =
  function(anchors) {
    
  this.dataModel.setAnchors(anchors);
  
};

lgb.gui.controller.ViewpointController.prototype.loadViewpoint =
  function(viewpointNode) {
    
  this.dataModel.addNode(viewpointNode);
  
};


lgb.gui.controller.ViewpointController.prototype.onViewpointNodesLoaded_ =
  function(event) {
    
  var viewpointNode = event.payload;
  this.dataModel.addNode(viewpointNode);
  
  
};





/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.GridModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.GridModel = function(jsonObject, geometryDimensions) {


  /**@const */
  this._TITLE = 'GridModel';
  
  this.position = new THREE.Vector3(
    jsonObject.position[0],
    jsonObject.position[1],
    jsonObject.position[2]
  );
  
  this.geometryDimensions = geometryDimensions;
  this.columnCount = jsonObject.columnCount;
  this.rowCount = jsonObject.rowCount;
  
  this.width = jsonObject.width;
  this.depth = jsonObject.depth;
   
  this.calculateSpacing_();
  this.calculatePosition_();
  
  
};




lgb.world.model.GridModel.prototype.calculatePosition_ = function() {


  var xPos = this.position.x +
  (-1 * (this.dimensions.x / 2)) + 
  (this.geometryDimensions.x / 2) + 
  (this.rowSpacing / 2);
  
  var zPos = this.position.z +
  (-1 * (this.dimensions.z / 2)) + 
  (this.geometryDimensions.z / 2) +
  (this.columnSpacing/ 2);
  
  var yPos = this.position.y + (1 * this.geometryDimensions.y / 2);

  this.centeredPosition  = new THREE.Vector3(
    xPos,
    yPos,
    zPos
  );
  
};
 
 
lgb.world.model.GridModel.prototype.calculateSpacing_ = function() {

  var totalLightX = this.geometryDimensions.x * this.columnCount;
  var totalLightZ = this.geometryDimensions.z * this.rowCount;
  
  var totalSpaceX = this.width - totalLightX;
  var totalSpaceZ = this.depth - totalLightZ;
  
  this.columnSpacing = totalSpaceX / (this.columnCount);
  this.rowSpacing = totalSpaceZ / (this.rowCount);
  
  this.dimensions = new THREE.Vector3(
    totalLightX + totalSpaceX,
    this.geometryDimensions.y,
    totalLightZ + totalSpaceZ
  );
  
};
 
 
 
/**
 * 
 */
lgb.world.model.GridModel.prototype.getCellPosition = function(rowNumber, columnNumber) {

  var x = (this.columnSpacing * columnNumber) + (this.geometryDimensions.x * columnNumber);
  var z = (this.rowSpacing * rowNumber) +(this.geometryDimensions.z * rowNumber);

  var cellPosition = new THREE.Vector3(
    x,
    0,
    z
  );
  
  
  return cellPosition;
};



/**
 * 
 */
lgb.world.model.GridModel.prototype.getDimensions = function() {

  var xSpan =  this.columnCount * this.columnSpacing;
  var zSpan =  this.rowCount * this.rowSpacing;
  var dimensions = new THREE.Vector2(xSpan, zSpan);

  return dimensions;
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 * These are utilities that are specific to the Three.Js
 * library.
 */

goog.provide('lgb.core.ThreeUtils');

goog.require('goog.structs.Map');

/**@typedef {Object} */
lgb.core.ThreeUtils = {};




/**
 * This will take a group and just merge all the geometries of
 * the group members into one
 * @param {Object} groupHash This is nan object where the
 * property names are the name of groups defined in Blender
 * and the values are an Array of Three.Mesh objects.
 * @return {Object} The returned object has Meshes as properties.
 */
lgb.core.ThreeUtils.convertGroupHashToMeshHash = function(groupHash) {
  var meshHash = {};

  for (var theGroupName in groupHash) {
    var theGroup = groupHash[theGroupName];
    var mesh = lgb.core.ThreeUtils.convertGroupToOneMesh(theGroup, theGroupName);
    meshHash[theGroupName] = mesh;
    mesh.geometry.center();
  }

  return meshHash;
};


/**
 * //TODO (Raj) Convert this to a goog.map
 * @param {Object} theGroup Works like a hash map.
 * @param {string} theGroupName The name.
 * @return {THREE.Mesh} The mesh.
 */
lgb.core.ThreeUtils.convertGroupToOneMesh = function(theGroup, theGroupName) {


  var newMesh = theGroup[0];
  
  //var geom = new THREE.Geometry();

  var l = theGroup.length;
  for (var i = 1; i < l; i++) {
    
    var mesh = theGroup[i];
    
    THREE.GeometryUtils.merge(newMesh.geometry, mesh.geometry);
    
    var marterialsAry = mesh.material.materials;
    var len = marterialsAry.length;
    
    for (var j = 0; j < len; j++) {
      newMesh.material.materials.push(marterialsAry[j]);
    }
  }

 // var newMesh = new THREE.Mesh(geom, new THREE.MeshFaceMaterial());
 // newMesh.name = theGroupName;
 
  newMesh.geometry.mergeVertices();


  return newMesh;
};



/**
 * makes transparent materials opaque in Chrome to fix bug
 * where the material blinks.
 * @param {THREE.Mesh} mesh The mesh to fix.
 */
lgb.core.ThreeUtils.chromeBlinkingFix = function(mesh) {
  if (goog.userAgent.WEBKIT) {

    if (mesh.geometry && mesh.geometry.materials) {
      var l = mesh.geometry.materials.length;

      for (var i = 0; i < l; i++) {
        mesh.geometry.materials[i][0].opacity = 1;
      }


    }
  }

};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
goog.provide('lgb.world.view.FurnitureView');
goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.GridModel');
goog.require('lgb.core.ThreeUtils');

goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.model.vo.VisibilityNode');

/**
 * @constructor
 * @extends {BaseView3dScene}
 * @param {lgb.world.model.FurnitureModel} dataModel The model to display.
 */
lgb.world.view.FurnitureView = function(dataModel) {

  this._ASSETS_FOLDER = 'furniture';
  this._TITLE = 'Furniture';

  lgb.world.view.BaseWorldView.call(this, dataModel);

};
goog.inherits(lgb.world.view.FurnitureView, lgb.world.view.BaseWorldView);

lgb.world.view.FurnitureView.prototype.onSceneLoaded_ = function() {
  this.dispatchViewpointNodes_();
  this.dispatchVisibilityNodes_();
};

lgb.world.view.FurnitureView.prototype.dispatchVisibilityNodes_ = function() {
  var node = new lgb.world.model.vo.VisibilityNode('Funiture', this.masterGroup_, 1);
  this.triggerLocal(e.VisibilityNodesLoaded, node);
};

lgb.world.view.FurnitureView.prototype.dispatchViewpointNodes_ = function() {
  var node = new lgb.world.model.vo.ViewpointNode.makeFromObject3D(this.masterGroup_, 2);
  this.triggerLocal(e.ViewpointNodesLoaded, node);
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.FurnitureModel');


goog.require('lgb.world.model.BaseModel');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.FurnitureModel = function() {



  
  /**@const */
  this._TITLE = 'Furniture';
  lgb.world.model.BaseModel.call(this);

  this.isVisible = true;
  
  
};
goog.inherits(lgb.world.model.FurnitureModel, lgb.world.model.BaseModel);









/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.FurnitureController');

goog.require('lgb.core.BaseController');

goog.require('lgb.world.model.FurnitureModel');
goog.require('lgb.world.view.FurnitureView');


goog.require('lgb.world.model.BuildingHeightModel');


/**
 * MVC controller for the Ductwork
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.FurnitureController = function() {

  lgb.core.BaseController.call(this);

};
goog.inherits(lgb.world.controller.FurnitureController, lgb.core.BaseController);

/**
 * initializes the controller
 * @private
 */
lgb.world.controller.FurnitureController.prototype.init = function() {
 
  
  this.dataModel = new lgb.world.model.FurnitureModel();
  this.view = new lgb.world.view.FurnitureView(this.dataModel);

  this.bind_();
  this.view.init();

};




/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.FurnitureController.prototype.bind_ = function() {

  this.relayLocal(this.view, e.AddToWorldRequest);
  
  this.relay(this.view,e.VisibilityNodesLoaded);
  this.relay(this.view, e.ViewpointNodesLoaded);
    
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.BuildingView');

goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.vo.ViewpointNode');


/**
 * @constructor
 * @extends {lgb.world.view.BaseClass}
 * @param {lgb.world.model.HvacModel} dataModel The model to display.
 */
lgb.world.view.BuildingView = function(dataModel) {
    
  this._TITLE = 'BuildingView';
  
  lgb.world.view.BaseWorldView.call(this, dataModel);
  this.masterGroup_ = new THREE.Object3D();
  this.masterGroup_.name = this._TITLE;
  
  this.floorGroup_ = new THREE.Object3D();
  this.floorGroup_.name = this._TITLE + "_floor";
  
  this.ceilingGroup_ = new THREE.Object3D();
  this.ceilingGroup_.name = this._TITLE + "_ceiling";
  
  this.roofGroup_ = new THREE.Object3D();
  this.roofGroup_.name = this._TITLE + "_roof";
  
  this.groundGroup_ = new THREE.Object3D();
  this.groundGroup_.name = this._TITLE + "_ground";
  
  this.masterGroup_.add(this.floorGroup_);
  this.masterGroup_.add(this.ceilingGroup_);
  this.masterGroup_.add(this.roofGroup_);
  this.masterGroup_.add(this.groundGroup_);
  
  this.anchors = {
    "floor": this.floorGroup_,
    "ceiling": this.ceilingGroup_,
    "roof": this.roofGroup_,
    "ground": this.groundGroup_
  };
  
  lgb.world.model.vo.ViewpointNode.anchors = {
    "floor": this.floorGroup_,
    "ceiling": this.ceilingGroup_,
    "roof": this.roofGroup_,
    "ground": this.groundGroup_
  };
  
};
goog.inherits(lgb.world.view.BuildingView, lgb.world.view.BaseWorldView);


lgb.world.view.BuildingView.prototype.init = function() {

  this.triggerLocal(e.AddToWorldRequest, this.masterGroup_);
};



lgb.world.view.BuildingView.prototype.addToFloor = function(object3D) {

  this.floorGroup_.add(object3D);
};

lgb.world.view.BuildingView.prototype.addToCeiling= function(object3D) {

  this.ceilingGroup_.add(object3D);
};

lgb.world.view.BuildingView.prototype.addToRoof= function(object3D) {

  this.roofGroup_.add(object3D);
};


lgb.world.view.BuildingView.prototype.addToGround_= function(object3D) {

  this.groundGroup_.add(object3D);
};


lgb.world.view.BuildingView.prototype.setBuildingHeight = function(buildingHeightModel) {

  this.floorGroup_.position.y = buildingHeightModel.activeFloorMinY;
  this.ceilingGroup_.position.y = buildingHeightModel.activeFloorMaxY;
  this.roofGroup_.position.y = buildingHeightModel.topFloorMaxY;

};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
 
goog.provide('lgb.component.DropDownDSnode');
 
goog.require('lgb.world.model.BaseModel');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.component.DropDownDSnode = function(name, value) {

  this.name = name;
  this.value = value;
  
  lgb.world.model.BaseModel.call(this);
};
goog.inherits(lgb.component.DropDownDSnode, lgb.world.model.BaseModel);



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
 
goog.provide('lgb.component.DropDownDataSource');
 
goog.require('lgb.component.DropDownDSnode');
goog.require('lgb.world.model.BaseModel');

/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.component.DropDownDataSource = function(name) {

  lgb.world.model.BaseModel.call(this);
  
  this.name = name;
  this.list= [];
  this.selectedIdx_= 0;
  this.selectedOption = null;
  
};
goog.inherits(lgb.component.DropDownDataSource, lgb.world.model.BaseModel);



lgb.component.DropDownDataSource.prototype.add = function(name, value, isDefault) {

  var option = new lgb.component.DropDownDSnode(name, value);
  this.list.push(option);
  
  if (isDefault) {
    this.selectedIdx_ = this.list.length-1;
  }
  
};


lgb.component.DropDownDataSource.prototype.selectByIdx = function(idx) {


  this.selectedIdx_ = idx;
  this.selectedOption = this.list[this.selectedIdx_];
  
  this.changePropertyEx("selectedOption", this.selectedOption);
  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
 
goog.provide('lgb.component.DropDown');


goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.DropDownDataSource');


/**
 * Primarily a container object for Sysvars
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {!lgb.utils.XmlWrapper} xmlParser The parse used
 * to populate the object, contains an xml document.
 */
lgb.component.DropDown = function(dataModel) {

  lgb.gui.view.BaseGUI.call(this, dataModel);
  
};
goog.inherits(lgb.component.DropDown, lgb.gui.view.BaseGUI);



lgb.component.DropDown.prototype.bind_ = function() {
  
  this.kendoComboBox_.bind('select', this.d(this.onSelect_));
  this.kendoComboBox_.bind('open', this.d(this.onOpen_));
  this.kendoComboBox_.bind('close', this.d(this.onClose_));
  
};


lgb.component.DropDown.prototype.onOpen_ = function(event) {
  
    this.triggerLocal(e.OpenDropDown, this.dataModel.selectedOption);
};


lgb.component.DropDown.prototype.onClose_ = function(event) {
  
    this.triggerLocal(e.CloseDropDown, this.dataModel.selectedOption);
};



lgb.component.DropDown.prototype.onSelect_ = function(event) {

  var idx = event.item.index();
  this.dataModel.selectByIdx(idx);

  this.triggerLocal(e.Select, this.dataModel.selectedOption);
  
};


lgb.component.DropDown.prototype.injectInto = function(parentElement) {

  parentElement.append('<br />');
  parentElement.append('<br />');
 
  
  parentElement.append('<p>' + this.dataModel.name + '</p>');
  
  var container = $('<div>');
  parentElement.append(container);
  
  

  
  
  this.kendoComboBox_ = 
      container.kendoDropDownList( 
        {
          dataTextField: "name",
          dataValueField: "value",
          dataSource: this.dataModel.list
        }
      ).data("kendoDropDownList");
      
      this.kendoComboBox_.select(1);
      
   this.bind_();
      
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.CrossSectionGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.component.DropDown');




/**
 * @constructor
 * @param {lgb.world.model.VisibilityModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.CrossSectionGUI = function(dataModel) {

  lgb.gui.view.BaseGUI.call(this, dataModel);

};
goog.inherits(lgb.gui.view.CrossSectionGUI, lgb.gui.view.BaseGUI);




/**
 * Initializes the View
 */
lgb.gui.view.CrossSectionGUI.prototype.init = function() {
  this.triggerLocal(e.RequestAddToTestingInput, this);
};



lgb.gui.view.CrossSectionGUI.prototype.bind_ = function() {
  

  this.listenTo(this.dropDownExternalInsulation_, e.Select, this.onExternalInsulationSelect_);
  this.listenTo(this.dropDownExternalInsulation_, e.OpenDropDown, this.onExternalInsulationOpen_);
  
  this.listenTo(this.dropDownAirBarrier_, e.Select, this.onAirBarrierSelect_);
  this.listenTo(this.dropDownAirBarrier_, e.OpenDropDown, this.onAirBarrierOpen_);
  
  this.listenTo(this.dropDownGap_, e.Select, this.onGapSelect_);
  this.listenTo(this.dropDownGap_, e.OpenDropDown, this.onGapOpen_);
  
  
  this.listenTo(this.dropDownVeneer_, e.Select, this.onVeneerSelect_);
  this.listenTo(this.dropDownVeneer_, e.OpenDropDown, this.onVeneerOpen_);
  
};




lgb.gui.view.CrossSectionGUI.prototype.onGapOpen_ = function(event) {

    this.gotoViewPoint('SideViewPoint');  
};


lgb.gui.view.CrossSectionGUI.prototype.onGapSelect_ = function(event) {
  
  var selectedOption = event.payload;
  this.requestDataModelChange('showGap', selectedOption.value);
  
};


lgb.gui.view.CrossSectionGUI.prototype.onVeneerOpen_ = function(event) {

    this.gotoViewPoint('VeneerViewPoint');
       
};


lgb.gui.view.CrossSectionGUI.prototype.onVeneerSelect_ = function(event) {
  
  var selectedOption = event.payload;
  this.requestDataModelChange('veneerMeshName', selectedOption.value);
  
};



lgb.gui.view.CrossSectionGUI.prototype.onAirBarrierOpen_ = function(event) {

    this.gotoViewPoint('AirViewPoint');
      
};


lgb.gui.view.CrossSectionGUI.prototype.onAirBarrierSelect_ = function(event) {
  
  var selectedOption = event.payload;
  this.requestDataModelChange('showAirBarrier', selectedOption.value);
  
};



lgb.gui.view.CrossSectionGUI.prototype.onExternalInsulationOpen_ = function(event) {
    this.gotoViewPoint('SideViewPoint');
};

lgb.gui.view.CrossSectionGUI.prototype.onExternalInsulationSelect_ = function(event) {
  
  var selectedOption = event.payload;
  this.requestDataModelChange('externalInsulationThickness', selectedOption.value);
  
};


lgb.gui.view.CrossSectionGUI.prototype.gotoViewPoint = function(name) {

      var viewpointNode = this.dataModel.getViewPoint(name);
    
    if (viewpointNode) {
      viewpointNode.updateWorldPositions();
      this.triggerLocal(e.RequestGoToViewpointNode, viewpointNode);
    }
};




lgb.gui.view.CrossSectionGUI.prototype.getViewPoint = function(name) {
  
  
   var viewpointNode = this.dataModel.getViewPoint(name);
   
   if (null == viewpointNode) {
     debugger;
   }
   return viewpointNode;
  
};





lgb.gui.view.CrossSectionGUI.prototype.injectInto = function(parentElement) {
  
  goog.base(this,  'injectInto', parentElement);
  var el = this.getMainElement();
  
  this.dropDownExternalInsulation_ = new lgb.component.DropDown(this.dataModel.externalInsulationOptions);
  this.dropDownAirBarrier_ = new lgb.component.DropDown(this.dataModel.airBarrierOptions);
  this.dropDownVeneer_ = new lgb.component.DropDown(this.dataModel.veneerOptions);
  this.dropDownGap_ = new lgb.component.DropDown(this.dataModel.gapOptions);
  
  
  this.bind_();
  
  this.dropDownExternalInsulation_.injectInto(el);
  this.dropDownAirBarrier_.injectInto(el);
  this.dropDownGap_.injectInto(el);
  this.dropDownVeneer_.injectInto(el);
  
};




goog.provide('lgb.world.model.vo.LayerNode');

goog.require('lgb.world.model.vo.BaseVo');



lgb.world.model.vo.LayerNode = function(name, meshName) {
  
  this.name = name;
  this.meshName = meshName;
  this.thickness = 0;
  this.originalPosition = null;
  this.mesh = null;
  this.show = true;
};
goog.inherits(lgb.world.model.vo.LayerNode, lgb.world.model.vo.BaseVo);




lgb.world.model.vo.LayerNode.prototype.init = function(meshWrapper) {
  
    var mesh = meshWrapper.mesh;
    
    var bb = mesh.geometry.getBoundingBoxObject();
  
    this.thickness = (bb.max.z - bb.min.z);
    
    this.originalPosition = meshWrapper.originalPosition;
    this.mesh = mesh;
  
    return;
};



lgb.world.model.vo.LayerNode.prototype.computeThickness = function() {
  
    var bb = this.mesh.geometry.getBoundingBoxObject();
    this.thickness = (bb.max.z - bb.min.z);
  
    return;
};


lgb.world.model.vo.LayerNode.prototype.getScaledThickness = function() {
  
  
  var t = this.thickness * this.mesh.scale.z;
  
  return t;
};/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.CrossSectionModel');


goog.require('lgb.world.model.BaseModel');
goog.require('lgb.component.DropDownDataSource');
goog.require('lgb.world.model.vo.LayerNode');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.CrossSectionModel = function() {

  /**@const */
  this._TITLE = 'CrossSection';
  lgb.world.model.BaseModel.call(this);

  this.viewPointNode = null;
  this.viewPointNodeMap_ = {};
  
  this.isVisible = true;
  
  this.externalInsulationOptions = new lgb.component.DropDownDataSource("Rigid Exterior Insulation Width");
  
  this.externalInsulationOptions.add("1 inch", 1, true);
  this.externalInsulationOptions.add("2 inch", 2);
  this.externalInsulationOptions.add("3 inch", 3);
  this.externalInsulationOptions.add("4 inch", 4);
  
  this.exInsulationSelected = null;
  
  this.airBarrierOptions = new lgb.component.DropDownDataSource("Air Barrier?");
  this.airBarrierOptions.add("No", false );
  this.airBarrierOptions.add("Yes", true, true);

  this.airBarrierOptionsSelected = null;
  
  
  this.gapOptions = new lgb.component.DropDownDataSource("Gap?");
  this.gapOptions.add("No", false );
  this.gapOptions.add("Yes", true, true);

  this.showGap = true;
  
  
  
  this.veneerOptions = new lgb.component.DropDownDataSource("Veneer Options");
  
  this.veneerOptions.add("Brick", "BrickVeneer" );
  this.veneerOptions.add("Stone", "StoneVeneer" );

  
  this.veneerSelected = null;
  
  this.layerNodes = [];
  this.title2Layer = {};

  this.makeLayer_("InnerLayer", "GypsumBoard" );
  this.makeLayer_("Studs", "SteelStudsLayer1" );
  this.makeLayer_('InteriorInsulation', 'InteriorInsulation');
  this.makeLayer_('AirBarrier', 'Vapor-AirBarrier');
  this.makeLayer_('ExternalInsulation', 'RigidExInsulation1inch');
  this.makeLayer_('Gap', 'Cube');
  this.makeLayer_('Veneer', 'StoneVeneer');

};
goog.inherits(lgb.world.model.CrossSectionModel, lgb.world.model.BaseModel);



lgb.world.model.CrossSectionModel.prototype.makeLayer_ = function(name, meshName) {

  var layerNode = new lgb.world.model.vo.LayerNode(name, meshName);
  
  this.layerNodes.push(layerNode);
  this.title2Layer[name] = layerNode;

  
};



lgb.world.model.CrossSectionModel.prototype.setMeshes = function(meshes) {
  
  this.meshWrappers_ = {};
  this.eachPropertyName(meshes, this.setOneMesh_);
  
};

lgb.world.model.CrossSectionModel.prototype.setOneMesh_ = function(mesh, name) {
  
  this.meshWrappers_[name] = {
    mesh:mesh,
    originalPosition:mesh.position.clone()
  };
  

};


lgb.world.model.CrossSectionModel.prototype.getLayersToShow = function() {
  
  this.visibleLayers = [];
  this.each(this.layerNodes, this.initOneLayer_);
  
  return this.visibleLayers;

};


lgb.world.model.CrossSectionModel.prototype.initOneLayer_ = function(layerNode) {
  
  var meshWrapper = this.meshWrappers_[layerNode.meshName];
  layerNode.init(meshWrapper);
  
  if (layerNode.show) {
    this.visibleLayers.push(layerNode);
  }
  return;
}; 






lgb.world.model.CrossSectionModel.prototype.setViewpointNode = function(node) {
  
    this.viewpointNode_ = node;
    
    // this.viewPointNodeMap_.main = node.getViewpoint("StoneVeneer");
    // this.viewPointNodeMap_.top1 = node.getViewpoint("RigidExInsulation1inch");
    // this.viewPointNodeMap_.air1 = node.getViewpoint("Vapor-AirBarrier");
    // this.viewPointNodeMap_.veneer = node.getViewpoint("BrickVeneer");

};


lgb.world.model.CrossSectionModel.prototype.getViewPoint = function(name) {
  
  var node = this.viewpointNode_.getViewpoint(name);
  
  return node;

};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
goog.provide('lgb.world.view.CrossSectionView');
goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.GridModel');
goog.require('lgb.core.ThreeUtils');

goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.model.vo.VisibilityNode');

/**
 * @constructor
 * @extends {BaseView3dScene}
 * @param {lgb.world.model.CrossSectionModel} dataModel The model to display.
 */
lgb.world.view.CrossSectionView = function(dataModel) {

  this._ASSETS_FOLDER = 'cross-section';
  this._TITLE = 'CrossSection';

  this.name2mesh_ = {};
  this.meshList_ = [];
    
  lgb.world.view.BaseWorldView.call(this, dataModel);

};
goog.inherits(lgb.world.view.CrossSectionView, lgb.world.view.BaseWorldView);



lgb.world.view.CrossSectionView.prototype.onSceneLoaded_ = function() {
  

  this.bind_();
  

  this.dataModel.setMeshes(this.meshes_);
  
  this.makeLayers_();
  

 // mesh.visible = false;
 
  this.masterGroup_.add(this.meshes_["MainViewPoint"]);
  this.masterGroup_.add(this.meshes_["AirViewPoint"]);
  this.masterGroup_.add(this.meshes_["VeneerViewPoint"]);
  this.masterGroup_.add(this.meshes_["TopViewPoint"]);
  this.masterGroup_.add(this.meshes_["SideViewPoint"]);
  
  
  var mesh2 = this.meshes_["Cube"];
  mesh2.visible = false;
  
  this.dispatchViewpointNodes_();
};


lgb.world.view.CrossSectionView.prototype.logBoundingBox_ = function(geometry) {
 
  var boundingBox = geometry.getBoundingBoxObject();
  
  var msgBB = "geometry:{0} - {1}".format(geometry.name, boundingBox.toJSON());
  lgb.logInfo(msgBB, this._TITLE);
  
};


  
  

lgb.world.view.CrossSectionView.prototype.makeLayers_ = function() {
  
  var layers = this.dataModel.getLayersToShow();
  
  this.nextLayerZ_ = 0;
  this.masterGroup_.removeAllChildren();
  
  this.each(layers, this.addOneLayer_);
  

};


lgb.world.view.CrossSectionView.prototype.addOneLayer_ = function(layer) {
 
   var thickness = layer.getScaledThickness();
    
   this.nextLayerZ_ -= (thickness / 2);
   this.nextLayerZ_ += layer.originalPosition.z;
   
   layer.mesh.position.z = this.nextLayerZ_;
   
   this.masterGroup_.add(layer.mesh);
   this.nextLayerZ_ -= (thickness / 2);
 
};


lgb.world.view.CrossSectionView.prototype.bind_ = function() {
  
  this.listenForChange_('externalInsulationThickness');
  this.listenForChange_('showAirBarrier');
  this.listenForChange_('veneerMeshName');
  this.listenForChange_('showGap');
  
};


lgb.world.view.CrossSectionView.prototype.onChange_externalInsulationThickness_ = function(externalInsulationThickness) {
  
  var layerNode = this.dataModel.title2Layer['ExternalInsulation'];
  
  layerNode.mesh.scale.z = externalInsulationThickness;
  
  layerNode.computeThickness();
  
  this.makeLayers_();
  
};


lgb.world.view.CrossSectionView.prototype.onChange_showAirBarrier_ = function(showAirBarrier) {
  var layerNode = this.dataModel.title2Layer['AirBarrier'];
  layerNode.show = showAirBarrier;
  this.makeLayers_();
};


lgb.world.view.CrossSectionView.prototype.onChange_veneerMeshName_ = function(veneerMeshName) {
  
  var layerNode = this.dataModel.title2Layer['Veneer'];
  layerNode.meshName = veneerMeshName;

  this.makeLayers_( );
};


lgb.world.view.CrossSectionView.prototype.onChange_showGap_ = function(showGap) {
  var layerNode = this.dataModel.title2Layer['Gap'];
  layerNode.show = showGap;
  this.makeLayers_( );
};



lgb.world.view.CrossSectionView.prototype.dispatchVisibilityNodes_ = function() {
  
  var node = new lgb.world.model.vo.VisibilityNode('CrossSection', this.masterGroup_, 1);
  this.triggerLocal(e.VisibilityNodesLoaded, node);
  
};


lgb.world.view.CrossSectionView.prototype.dispatchViewpointNodes_ = function() {
  
  var node = new lgb.world.model.vo.ViewpointNode.makeFromObject3D(this.masterGroup_, 2);
 
  //var ary = lgb.convertMapToArray(this.objects_);
  //var node = new lgb.world.model.vo.ViewpointNode.makeFromArray(this._TITLE, ary, 1);
  
  this.dataModel.setViewpointNode(node);
  this.triggerLocal(e.ViewpointNodesLoaded, node);
  
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.CrossSectionController');

goog.require('lgb.core.BaseController');

goog.require('lgb.world.model.CrossSectionModel');
goog.require('lgb.world.view.CrossSectionView');
goog.require('lgb.gui.view.CrossSectionGUI');

goog.require('lgb.world.model.BuildingHeightModel');


/**
 * MVC controller for the Ductwork
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.CrossSectionController = function() {

  lgb.core.BaseController.call(this);

};
goog.inherits(lgb.world.controller.CrossSectionController, lgb.core.BaseController);

/**
 * initializes the controller
 * @private
 */
lgb.world.controller.CrossSectionController.prototype.init = function() {
 
  
  this.dataModel = new lgb.world.model.CrossSectionModel();
  this.view = new lgb.world.view.CrossSectionView(this.dataModel);
  this.guiView = new lgb.gui.view.CrossSectionGUI (this.dataModel);
  
  this.bind_();
  
  this.view.init();

  
};




/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.CrossSectionController.prototype.bind_ = function() {

  this.relayLocal(this.view, e.AddToWorldRequest);
  
  this.relay(
    this.guiView,
    [e.RequestAddToTestingInput, e.RequestGoToViewpointNode]
    );

  this.relay(
    this.view,
    e.ViewpointNodesLoaded
    );
    
   
  this.listenTo(
    this.guiView,
    e.RequestDataModelChange,
    this.onRequestDataModelChange_
    );
    
    
  this.listenTo(
    this.view,
    e.ViewInitialized,
    this.onViewInitialized_
    );
    
    

};



lgb.world.controller.CrossSectionController.prototype.onViewInitialized_ = function(event) {
  
  this.guiView.init();
  
};




lgb.world.controller.CrossSectionController.prototype.onRequestDataModelChange_ =
  function(event) {
    
  this.dataModel.changePropertyEx(event.payload.property, event.payload.newValue);
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.BuildingModel');

goog.require('lgb.world.model.BaseModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.BuildingModel = function() {

  /**@const */
  this._TITLE = 'Building';

  lgb.world.model.BaseModel.call(this);

};
goog.inherits(lgb.world.model.BuildingModel, lgb.world.model.BaseModel);

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.EnvelopeModel');

goog.require('lgb.world.model.BaseModel');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.EnvelopeModel = function() {

  lgb.world.model.BaseModel.call(this);
  
  this.init();
};
goog.inherits(lgb.world.model.EnvelopeModel, lgb.world.model.BaseModel);


/**
 * Initializes the MVC Model setting default properties.
 * @private
 */
lgb.world.model.EnvelopeModel.prototype.init = function() {

  /**@const */
  this._TITLE = 'Envelope Model';

  lgb.world.model.BaseModel.call(this);

  this.floorCount = 5;
  this.floorHeight = 11;
  this.floorWidth = 125;
  this.floorDepth = 80;
  
  this.floorWidthMeters = 38.032798767089844;
  this.floorDepthMeters = 24.384000778198242;
  this.floorHeightMeters = 4.267199993133545;
  
   
  this.floorHeightOptions = [9,11,13];
  this.floorHeightOptionsMeters = 
  [3.6576159000396728,
  4.267199993133545,
  4.8768000602722168];
  
  this.isVisible = true;


};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.ZoneShapeModel');


/**
 * @constructor
 * @param {number} x The x dimension.
 * @param {number} y The y dimension.
 * @param {number} z The z dimension.
 * @param {number} xx The x position.
 * @param {number} yy The y position.
 * @param {number} zz The z position.
 */
lgb.world.model.ZoneShapeModel = function(x, y, z) {

  this.dimensions = new THREE.Vector3(x, y, z);
  this.position = null;
  this.isVisible = false;
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 	 
 	 /**
 * @author Raj Dye - raj@rajdye.com
*/
goog.provide('lgb.world.view.ZoneView');

goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.model.ZoneShapeModel');
goog.require('lgb.world.model.vo.ViewpointNode');


/**
 * MVC View
 * @constructor
 * @extendslgb.world.view.BaseWorldView
 * @param {lgb.world.model.ZoneModel} dataModel The Data Model.
 */
lgb.world.view.ZoneView = function(dataModel) {
    
  this._TITLE = 'Zones';
  lgb.world.view.BaseWorldView.call(this, dataModel);

  this.zoneVisibleIdx = -1;
  this.buildingHeightModel_ = null;
  this.isInitialized_ = false;
  
  this.listenForChange_('isVisible');
  this.listenForChange_('envelopeModel');
};
goog.inherits(lgb.world.view.ZoneView,lgb.world.view.BaseWorldView);




lgb.world.view.ZoneView.prototype.onChange_isVisible_ = function(statusObject) {
    this.setVisible(statusObject.zoneIdx, statusObject.isVisible);
};

lgb.world.view.ZoneView.prototype.onChange_envelopeModel_ = function(envelopeModel) {
  
  this.masterGroup_.removeAllChildren();
  
  var len = this.dataModel.z.length;
  for (var i = 0; i < len; i++) {
      
    var zoneShapeModel = this.dataModel.z[i];
    
    this.addCube_(i + 1, zoneShapeModel);
  }
  
    if (!this.isInitialized_) {
        var node = new lgb.world.model.vo.ViewpointNode.makeFromObject3D( this.masterGroup_, 2 );
        
        var len = node.children.length;
        for (var i=0; i < len; i++) {
          node.children[i].focusEvent = true;
        };
        this.triggerLocal(e.ViewpointNodesLoaded, node);
    }

    this.isInitialized_ = true;
    
};



/**
 * @param {number} zoneIdx The idx used to locate the zone in the array.
 * @param {boolean} makeVisible If true show the zone.
 */
lgb.world.view.ZoneView.prototype.setVisible = function(zoneIdx, makeVisible) {

  if (null == makeVisible) {
    makeVisible = true;
  }

  var zoneCube = this.masterGroup_.children[zoneIdx-1];

  if (zoneCube.visible != makeVisible) {
    zoneCube.visible = makeVisible;
  }

};



/**
 * Initializes the View
 */
lgb.world.view.ZoneView.prototype.init = function() {

  var parameters = {
    color: 0x6660000
  };

  this.material = new THREE.MeshPhongMaterial(parameters);

  var cubeGeom = new THREE.CubeGeometry(5, 5, 5, 1, 1, 1);
  this.cubeMesh = new THREE.Mesh(cubeGeom, this.material);

  this.masterGroup_.viewpoint = "ZonesScene";
  this.requestAddToWorld(this.masterGroup_);
};


/**
 * @private
 * @param {number} zoneNumber The idx used to locate the zone in the array.
 * @param {THREE.Vector3} geom The dimensions of the cube.
 * @param {THREE.Vector3} position The position of the cube.
 */
lgb.world.view.ZoneView.prototype.addCube_ = function(zoneNumber, zoneShapeModel) {

    var floorWidth = this.dataModel.envelopeModel.floorWidthMeters;
    var floorHeight = this.dataModel.envelopeModel.floorHeightMeters;
    var floorDepth = this.dataModel.envelopeModel.floorDepthMeters;

    var width = zoneShapeModel.dimensions.x;
    var height = floorHeight;
    var depth = zoneShapeModel.dimensions.z;

    var posx = zoneShapeModel.position.x;
    var posz = zoneShapeModel.position.z;


  var cubeGeom = new THREE.CubeGeometry(
    width,
    height,
    depth,
    1, 1, 1);

    var cubeMesh = new THREE.Mesh(cubeGeom, this.material);
    cubeMesh.name = 'Zone ' + zoneNumber.toString();
    cubeMesh.visible = false;
    cubeMesh.viewpoint = "defaultZone";
    
    var x = -1 * floorWidth / 2;
    x += posx + (width / 2);

    var z = -1 * floorDepth / 2;
    z += posz + (depth / 2);

    cubeMesh.position = new THREE.Vector3(
      x,
            (floorHeight / 2) ,
      z);

    this.masterGroup_.add(cubeMesh);
};











/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.ZoneModel');

goog.require('lgb.world.model.BaseModel');
goog.require('lgb.world.model.ZoneShapeModel');

/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.ZoneModel = function() {

  this._TITLE = 'Zones';
  this.init_();
  this.zoneIdxVisible = -1;

};
goog.inherits(lgb.world.model.ZoneModel, lgb.world.model.BaseModel);


/**
 * Sets default properties.
 * @private
 */
lgb.world.model.ZoneModel.prototype.init_ = function() {
  this.z = [];

  this.z[0] = new lgb.world.model.ZoneShapeModel(4.5, 0, 4.5);
  this.z[1] = new lgb.world.model.ZoneShapeModel(28.524599075317383, 0, 4.7540998458862305);
  this.z[2] = new lgb.world.model.ZoneShapeModel(4.7540998458862305, 0, 4.7540998458862305);
  this.z[3] = new lgb.world.model.ZoneShapeModel(4.7540998458862305, 0, 15.24000048637390125);
  this.z[4] = new lgb.world.model.ZoneShapeModel(28.524599075317383, 0, 15.24000048637390125);
  this.z[5] = new lgb.world.model.ZoneShapeModel(4.7540998458862305, 0, 15.24000048637390125);
  this.z[6] = new lgb.world.model.ZoneShapeModel(4.7540998458862305, 0, 4.7540998458862305);
  this.z[7] = new lgb.world.model.ZoneShapeModel(28.524599075317383, 0, 4.7540998458862305);
  this.z[8] = new lgb.world.model.ZoneShapeModel(4.7540998458862305, 0, 4.7540998458862305);
  
  var currentX = 0;
  var currentZ = 0;
  var len = 3;
  
  for (var j = 0; j < 3; j++) {

      for (var i = 0; i < 3; i++) {
          
           var idx = (j * 3) + i;
           this.z[idx].position = new THREE.Vector3(currentX, 0, currentZ);
           
           currentX += this.z[i].dimensions.x;
           
      }
      
      currentX = 0;
      currentZ += this.z[idx].dimensions.z;
  }
  

 

};


/**
 * updates the geometry and location of the zones
 * @param {lgb.world.model.EnvelopeModel} envelopeModel The data model to
 * use in the computation.
 */
lgb.world.model.ZoneModel.prototype.setEnvelopeModel = function(envelopeModel) {

  this.envelopeModel = envelopeModel;
  this.dispatchChangedEx('envelopeModel', envelopeModel);
   
};


/**
 * @param {number} zoneIdx Used to locate the zone in an array.
 * @param {boolean} makeVisible Used to change the visibility.
 */
lgb.world.model.ZoneModel.prototype.setVisible = function(zoneIdx, makeVisible) {

  var theZone = this.z[zoneIdx-1];
  
  if (undefined == theZone) {
    debugger;
  }
  
  if (theZone.isVisible != makeVisible) {

    theZone.isVisible = makeVisible;

     var statusObject = {   
         isVisible: makeVisible,
         zoneIdx: zoneIdx
     };
    
    this.dispatchChangedEx('isVisible', statusObject);
    
  }
  
  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.ZoneController');

goog.require('lgb.core.BaseController');

goog.require('lgb.world.model.EnvelopeModel');
goog.require('lgb.world.model.ZoneModel');
goog.require('lgb.world.view.ZoneView');

goog.require('lgb.world.model.BuildingHeightModel');



/**
 * MVC controller for the Zones
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.ZoneController = function() {
  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.world.controller.ZoneController, lgb.core.BaseController);


/**
 * @private
 */
lgb.world.controller.ZoneController.prototype.init = function() {
    
  this.dataModel = new lgb.world.model.ZoneModel();
  this.view = new lgb.world.view.ZoneView(this.dataModel);
  
  this.bind_();
  this.view.init();
};


/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.ZoneController.prototype.bind_ = function() {


  this.relayLocal(this.view, e.AddToWorldRequest);

  this.listen(
    e.RequestShowViewpoint,
    this.onRequestShowViewpoint_
    );


  this.relay(
    this.view,
    e.ViewpointNodesLoaded
  );
  
  this.listen(
    e.EnvelopeModelChanged,
    this.onEnvelopeModelChanged_
    );

};

/*

lgb.world.controller.ZoneController.prototype.onViewpointNodesLoaded_ =
  function(event) {

  //this.dataModel.setViewpointNode(event.payload);
  this.dispatch(event);

};

*/



lgb.world.controller.ZoneController.prototype.onRequestShowViewpoint_ =
  function(event) {

  var viewpointNode = event.payload;
  var idx = viewpointNode.idx - viewpointNode.parent.idx;

  this.dataModel.setVisible(
    idx,
    event.payload.isVisible
  );
  

  
};



lgb.world.controller.ZoneController.prototype.onEnvelopeModelChanged_ =
  function(event) {

  this.dataModel.setEnvelopeModel(event.payload);
  
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.EnvelopeView');

goog.require('goog.userAgent');
goog.require('lgb.core.ThreeUtils');
goog.require('lgb.world.view.BaseWorldView');

goog.require('lgb.world.model.BuildingHeightModel');


/**
 * @constructor
 * @extends {BaseView3dScene}
 * @param {lgb.world.model.EnvelopeModel} dataModel The model to display.
 */
lgb.world.view.EnvelopeView = function(dataModel) {
    

  this._ASSETS_FOLDER = 'envelope';
  this._TITLE = 'Envelope';
  
  lgb.world.view.BaseWorldView.call(this, dataModel);
  this.floorMeshHash_ = {};
  
  this.floorDimensions_ = null;
  
  this.allFloorsContainer_ = new THREE.Object3D();
  this.allFloorsContainer_.name = this._ASSETS_FOLDER + "-allFloorsContainer";
  

};
goog.inherits(lgb.world.view.EnvelopeView,lgb.world.view.BaseWorldView);


lgb.world.view.EnvelopeView.prototype.bind_ = function() {
  this.listenForChange_('floorHeight');
  this.listenForChange_('floorCount');
};


lgb.world.view.EnvelopeView.prototype.onChange_floorHeight_ = function(floorHeight) {
  this.makeFloors_();
};
lgb.world.view.EnvelopeView.prototype.onChange_floorCount_ = function(floorCount) {
  this.makeFloors_();
};


lgb.world.view.EnvelopeView.prototype.getTopFloorContainer = function() {
  return this.topFloorContainer_;
};



/**
 * Event handler called when the the scene is loaded.
 * @private
 * @param {Object} result From the THREE.js lib.
 */
lgb.world.view.EnvelopeView.prototype.onSceneLoaded_ = function() {


  this.floorMeshHash_ = lgb.core.ThreeUtils.convertGroupHashToMeshHash(this.groups_);
  
  var hashKeyArray = [];
  var optionsAry = this.dataModel.floorHeightOptions;
  var len = optionsAry.length;

  for (var i = 0; i < len; i++) {
    var hashKey = optionsAry[i] + 'ft';
    hashKeyArray.push(hashKey);

    var mesh = this.floorMeshHash_[hashKey];
    
    if (goog.userAgent.WEBKIT) {
      this.chromeBlinkingFix_(mesh);
    }

    var dim = mesh.geometry.getDimensions();
    var y = dim.y / 2;
    
    mesh.position.setY(y);
  }

  this.masterGroup_.add(this.allFloorsContainer_);
  this.requestAddToWorld(this.masterGroup_);
  this.makeFloors_();
  this.dispatchVisibilityNodes_();
  this.bind_(); 

};


lgb.world.view.EnvelopeView.prototype.dispatchVisibilityNodes_ = function() {

  var visibilityNode = new lgb.world.model.vo.VisibilityNode('Envelope', this.masterGroup_, 1 );
  this.triggerLocal(e.VisibilityNodesLoaded, visibilityNode);

};



/**
 * @private
 */
lgb.world.view.EnvelopeView.prototype.makeFloors_ = function() {
  
  var hashKey = this.dataModel.floorHeight + 'ft';
  
  var mesh = this.floorMeshHash_[hashKey];
  this.floorDimensions_ = mesh.geometry.getDimensions();
 
  this.allFloorsContainer_.removeAllChildren();
  var floorCount = this.dataModel.floorCount;

  for (var j = 0; j < floorCount; j++) {
    var newFloor = mesh.clone();
    
    newFloor.name = this._ASSETS_FOLDER + "-floor-" + (j + 1);
    newFloor.position.y += j * this.floorDimensions_.y;
    this.allFloorsContainer_.add(newFloor);
  }

  var topFloorMaxY = this.floorDimensions_.y * floorCount;
  var topFloorMinY = topFloorMaxY - this.floorDimensions_.y;
  
  var payload = new lgb.world.model.BuildingHeightModel(topFloorMaxY, topFloorMinY);
  
  this.triggerLocal(e.BuildingHeightChanged, payload);
  
  
};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.LightingModel');
goog.provide('lgb.world.model.LightingModel.Type');


goog.require('lgb.world.model.BaseModel');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.LightingModel = function() {


  /**@const */
  this._TITLE = 'Lighting';
  lgb.world.model.BaseModel.call(this);

  this.lightingType = lgb.world.model.LightingModel.Type.RECESSED;

};
goog.inherits(lgb.world.model.LightingModel, lgb.world.model.BaseModel);




/**
 * @enum {number}
 */
lgb.world.model.LightingModel.Type = {
  PENDANT: 0,
  RECESSED: 1
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.EnvelopeGUI');

goog.require('lgb.world.model.LightingModel');
goog.require('lgb.gui.view.BaseGUI');


/**
 * @constructor
 * @param {lgb.world.model.VisibilityModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.EnvelopeGUI = function(dataModel) {

  lgb.gui.view.BaseGUI.call(this, dataModel);

};
goog.inherits(lgb.gui.view.EnvelopeGUI, lgb.gui.view.BaseGUI);


/**
 * Initializes the View
 */
lgb.gui.view.EnvelopeGUI.prototype.init = function() {
  this.triggerLocal(e.RequestAddToTestingInput, this);
};

lgb.gui.view.EnvelopeGUI.prototype.bind_ = function() {
  
  this.kendoListBoxFloorHeight_.bind('select', this.d(this.onFloorHeightSelect_));
  this.kendoListFloorCount_.bind('select', this.d(this.onFloorCountSelect_));

};


lgb.gui.view.EnvelopeGUI.prototype.onFloorCountSelect_ = function(event) {
  
  var idx = event.item.index();
  var dataItem = this.kendoListFloorCount_.dataItem(idx);
  
  var v = parseInt(dataItem.value);
  this.requestDataModelChange('floorCount', v);

};


lgb.gui.view.EnvelopeGUI.prototype.onFloorHeightSelect_ = function(event) {
  
  var idx = event.item.index();
  var dataItem = this.kendoListBoxFloorHeight_.dataItem(idx);
  
  var v = parseInt(dataItem.value);
  
  this.requestDataModelChange('floorHeight', v);
    
};



lgb.gui.view.EnvelopeGUI.prototype.injectInto = function(parentElement) {
  
  goog.base(this,  'injectInto', parentElement);
  
  
   var items = [
          {text: "13ft", value:"13"},
          {text: "11ft", value:"11"},
          {text: "9ft", value:"9"}
          ];
          
          
  var el = this.getMainElement();
  
  el.append('<h4>Envelope</h4>');
  el.append('<p>Select Floor-To-ceiling height</p>');
    
  var container1 = $('<div>');
  el.append(container1);
  
  
  this.kendoListBoxFloorHeight_ = 
      container1.kendoDropDownList( 
        {
          dataTextField: "text",
          dataValueField: "value",
          dataSource: items
        }
      ).data("kendoDropDownList");
      
      
      this.kendoListBoxFloorHeight_.select(1);
      
      
  el.append('<div><br /><p>Select Number of Stories</p></div>');
  
  var container2 = $('<div>');
  el.append(container2);
      
   var items2 = [
          {text: "3", value:"3"},
          {text: "5", value:"5"},
          {text: "7", value:"7"}
          ];
      
  this.kendoListFloorCount_ = 
      container2.kendoDropDownList( 
        {
          dataTextField: "text",
          dataValueField: "value",
          dataSource: items2
        }
      ).data("kendoDropDownList");
      
      
      this.kendoListFloorCount_.select(1);
      
      
      this.bind_();
      

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.EnvelopeController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.model.EnvelopeModel');
goog.require('lgb.world.view.EnvelopeView');
goog.require('lgb.gui.view.EnvelopeGUI');


/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.EnvelopeController = function() {
  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.world.controller.EnvelopeController, lgb.core.BaseController);


/**
 * @private
 */
lgb.world.controller.EnvelopeController.prototype.init = function() {

  this.dataModel = new lgb.world.model.EnvelopeModel();
  this.view = new lgb.world.view.EnvelopeView(this.dataModel);
  this.guiView = new lgb.gui.view.EnvelopeGUI(this.dataModel);
  
  this.bind_();
  
  this.view.init();
  this.guiView.init();
  
  this.trigger(e.EnvelopeModelChanged, this.dataModel);
};



/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.EnvelopeController.prototype.bind_ = function() {

  
  this.relayLocal(this.view, e.AddToWorldRequest);
  
  this.listenToOnce(this.view,
    e.ViewInitialized,
    this.onViewInitialized_);

    
  this.relay(
    this.view,
    e.BuildingHeightChanged
  );
    
  this.relay(
    this.guiView,
    e.RequestAddToTestingInput
    );
    
  this.relay(
    this.view,
    e.VisibilityNodesLoaded
    );

};



lgb.world.controller.EnvelopeController.prototype.getTopFloor =
  function(event) {
      
  return this.view.getTopFloor();
  
};


lgb.world.controller.EnvelopeController.prototype.onViewInitialized_ =
  function(event) {

  this.listenTo(
    this.guiView,
    e.RequestDataModelChange,
    this.onRequestDataModelChange_
    );
    
};



lgb.world.controller.EnvelopeController.prototype.onRequestDataModelChange_ =
  function(event) {
    
  this.dataModel.changePropertyEx(event.payload.property, event.payload.newValue);
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.HvacModel');

goog.require('lgb.world.model.BaseModel');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.HvacModel = function() {
  this._TITLE = 'Ductwork';
  lgb.world.model.BaseModel.call(this);

};
goog.inherits(lgb.world.model.HvacModel, lgb.world.model.BaseModel);



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.view.HvacView');

goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.model.vo.VisibilityNode');
goog.require('lgb.world.model.vo.ViewpointNode');

/**
 * @constructor
 * @extends {lgb.world.view.BaseWorldView}
 * @param {lgb.world.model.HvacModel} dataModel The model to display.
 */
lgb.world.view.HvacView = function(dataModel) {

  this._TITLE = 'HVAC';
  this._ASSETS_FOLDER = 'hvac';

  lgb.world.view.BaseWorldView.call(this, dataModel);

};
goog.inherits(lgb.world.view.HvacView, lgb.world.view.BaseWorldView);

/**
 * Event handler called when the scene file is loaded
 * and all needed assets are loaded too.
 * @param {Object} result The result from the THREE.js lib.
 * @private
 */
lgb.world.view.HvacView.prototype.onSceneLoaded_ = function(result) {

  var selectableList = [];
  var len = this.scene_.children.length;
  
  for (var i = 0; i < len; i++) {

    var mesh = this.scene_.children.pop();
    if (mesh != null) {

      //TODO:RAJ target selectable meshes with "groups"
      if (mesh.name != 'DuctWork') {
        
        selectableList.push(mesh);
      }

      this.masterGroup_.add(mesh);
    } else {

      //console.log ("test");
      throw ('Mesh is null');
    }
  }


  this.dispatchSelectableLoaded_(selectableList);
  this.dispatchVisibilityNodes_();
  this.dispatchViewpointNodes_();

};

lgb.world.view.HvacView.prototype.dispatchSelectableLoaded_ = function(selectableList) {
  
  if (selectableList.length > 0) {
     this.triggerLocal(e.SelectableLoaded, selectableList);
  }
  
};


lgb.world.view.HvacView.prototype.dispatchViewpointNodes_ = function() {
  var node = new lgb.world.model.vo.ViewpointNode.makeFromObject3D(this.masterGroup_, 1);
  this.triggerLocal(e.ViewpointNodesLoaded, node);
};

lgb.world.view.HvacView.prototype.dispatchVisibilityNodes_ = function() {
  var node = new lgb.world.model.vo.VisibilityNode('HVAC', this.masterGroup_, 1);
  this.triggerLocal(e.VisibilityNodesLoaded, node);
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.HvacController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.model.HvacModel');
goog.require('lgb.world.view.HvacView');
goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.model.vo.VisibilityNode');


/**
 * MVC controller for the Ductwork
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.HvacController = function() {
  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.world.controller.HvacController, lgb.core.BaseController);

/**
 * initializes the controller
 * @private
 */
lgb.world.controller.HvacController.prototype.init = function() {
  this.dataModel = new lgb.world.model.HvacModel();
  this.view = new lgb.world.view.HvacView(this.dataModel);
  this.bind_();
  this.view.init();
};




/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.HvacController.prototype.bind_ = function() {
  
  
  this.relay(
    this.view, 
      [
        e.ViewpointNodesLoaded,
        e.VisibilityNodesLoaded,
        e.SelectableLoaded
      ]
    );
  
  this.relayLocal(this.view, e.AddToWorldRequest);

};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.view.LightingView');

goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.GridModel');
goog.require('lgb.world.model.BuildingHeightModel');

/**
 * @constructor
 * @extends {BaseView3dScene}
 * @param {lgb.world.model.LightingModel} dataModel The model to display.
 */
lgb.world.view.LightingView = function(dataModel) {

  this._ASSETS_FOLDER = 'lighting';

  lgb.world.view.BaseWorldView.call(this, dataModel);

  this.pendantGeom = null;
  this.recessedGeom = null;
  this.listenForChange_('lightingType');
};
goog.inherits(lgb.world.view.LightingView, lgb.world.view.BaseWorldView);

lgb.world.view.LightingView.prototype.onChange_lightingType_ = function(lightingType) {
  this.buildGrid_();
};

/**
 * Event handler called when the scene file is loaded
 * and all needed assets are loaded too.
 * @param {Object} result The result from the THREE.js lib.
 * @private
 */
lgb.world.view.LightingView.prototype.onSceneLoaded_ = function() {
 


  for (var i = this.scene_.children.length - 1; i >= 0; i--) {
    var mesh = this.scene_.children.pop();

    if (mesh.name == 'recessed') {

      this.recessedGeom = mesh.geometry;
      this.recessedMesh_ = mesh;
      
      this.gridRecessed = new lgb.world.model.GridModel(this.appData_.gridRecessed, mesh.geometry.getDimensions());

    } else if (mesh.name == 'pendant') {

      this.pendantGeom = mesh.geometry;
      this.pendantMesh_ = mesh;
      this.gridPendant = new lgb.world.model.GridModel(this.appData_.gridPendant, mesh.geometry.getDimensions());
    }

    this.masterGroup_.add(mesh);
  }

  this.buildGrid_();
  this.requestAddToWorld(this.masterGroup_);

  this.dispatchVisibilityNodes_();


};

lgb.world.view.LightingView.prototype.dispatchVisibilityNodes_ = function() {
  var node = new lgb.world.model.vo.VisibilityNode('Lighting', this.masterGroup_, 0);
  this.triggerLocal(e.VisibilityNodesLoaded, node);
};


/**
 * Updates this view to reflect the changes in the type of the
 * lighting selected
 * @private
 */
lgb.world.view.LightingView.prototype.buildGrid_ = function() {


  this.masterGroup_.removeAllChildren();
  
  var mesh;
  var gridModel;

  if (this.dataModel.lightingType == lgb.world.model.LightingModel.Type.PENDANT) {

    mesh = this.pendantMesh_;
    
    gridModel = this.gridPendant;

  } else if (this.dataModel.lightingType == lgb.world.model.LightingModel.Type.RECESSED) {

    mesh = this.recessedMesh_;
    gridModel = this.gridRecessed;

  } else {

  }

  this.buildGridHelper_(gridModel, mesh);

};

/**
 * @override
 * @param {Object } event The event.
 * @param {lgb.world.model.GridModel} gridModel.
 * @protected
 */
lgb.world.view.LightingView.prototype.buildGridHelper_ = function(gridModel, mesh) {

  for (var c = 0; c < gridModel.columnCount; c++) {
    for (var r = 0; r < gridModel.rowCount; r++) {

      var light = mesh.clone();
      light.castShadow = true;
      light.receiveShadow = true;

      light.position = gridModel.getCellPosition(r, c);
      this.masterGroup_.add(light);

    }

  };

  this.masterGroup_.position.x = gridModel.centeredPosition.x;
  this.masterGroup_.position.z = gridModel.centeredPosition.z;
  this.masterGroup_.position.y = gridModel.centeredPosition.y;

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.TestLightingGUI');

goog.require('lgb.world.model.LightingModel');
goog.require('lgb.gui.view.BaseGUI');


/**
 * @constructor
 * @param {lgb.world.model.VisibilityModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.TestLightingGUI = function(dataModel) {

  this._TITLE = "Settings";
  lgb.gui.view.BaseGUI.call(this, dataModel);

};
goog.inherits(lgb.gui.view.TestLightingGUI, lgb.gui.view.BaseGUI);




lgb.gui.view.TestLightingGUI.prototype.bind_ = function() {
  
  this.kendoDropDownList_.bind('select', this.d(this.onDropDownSelect_));

};


lgb.gui.view.TestLightingGUI.prototype.onDropDownSelect_ = function(event) {
  
  var idx = event.item.index();
  var dataItem = this.kendoDropDownList_.dataItem(idx);
  
  var value = parseInt(dataItem.value);
  
  this.dataModel.changePropertyEx('lightingType', value);
};



lgb.gui.view.TestLightingGUI.prototype.inject = function(parentElement) {
  
  goog.base(this,  'inject', parentElement);
  
  
   var items = [
          {text: "Recessed", value:"1"},
          {text: "Pendant", value:"0"}
          ];
          
          
  var el = this.getMainElement();
  

  var titleDiv = el.append('<h4>Lighting</h4>');
    
  var cb = $('<div>');
  el.append(cb);
  
  
  this.kendoDropDownList_ = 
      cb.kendoDropDownList( 
        {
          dataTextField: "text",
          dataValueField: "value",
          dataSource: items
        }
      ).data("kendoDropDownList");
      
      
      this.kendoComboBox_.select(0);
      this.bind_();
      

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.controller.TestLightingController');

goog.require('lgb.core.BaseController');

goog.require('lgb.world.model.LightingModel');
goog.require('lgb.world.view.LightingView');
goog.require('lgb.gui.view.TestLightingGUI');
goog.require('lgb.world.model.BuildingHeightModel');

/**
 * MVC controller for the Ductwork
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.gui.controller.TestLightingController = function() {

  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.gui.controller.TestLightingController, lgb.core.BaseController);

/**
 * initializes the controller
 * @private
 */
lgb.gui.controller.TestLightingController.prototype.init = function() {
 
  
  this.dataModel = new lgb.world.model.LightingModel();
  
  this.guiView = new lgb.gui.view.TestLightingGUI(this.dataModel);
  this.view = new lgb.world.view.LightingView(this.dataModel);

  this.bind_();
  
  this.view.init();

  
  this.triggerLocal(e.RequestAddToTestingInput, this.guiView);
};




/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.gui.controller.TestLightingController.prototype.bind_ = function() {


  this.relayLocal(this.view, e.AddToWorldRequest);

  this.relay(
    this.view,
    e.VisibilityNodesLoaded
    );
    

  this.relay(
    this.guiView,
    e.RequestAddToTestingInput
    );
    
};






/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.RoofTopModel');

goog.require('lgb.world.model.BaseModel');



/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.RoofTopModel = function() {

  /**@const */
  this._TITLE = 'Roof-top Unit';

  lgb.world.model.BaseModel.call(this);

  this.init_();

};
goog.inherits(lgb.world.model.RoofTopModel, lgb.world.model.BaseModel);


/**
 * Initializes the object setting default properties.
 * @private
 */
lgb.world.model.RoofTopModel.prototype.init_ = function() {


};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.RoofTopView');


goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.vo.ViewpointNode');


/**
 * MVC View for the RoofTop Unit
 * @constructor
 * @extendslgb.world.view.BaseWorldView
 * @param {lgb.world.model.RoofTopModel} dataModel The data model to display.
 */
lgb.world.view.RoofTopView = function(dataModel) {
    
  this._ASSETS_FOLDER = 'rooftop';
  this._TITLE = 'RoofTop';
 lgb.world.view.BaseWorldView.call(this, dataModel);

};
goog.inherits(lgb.world.view.RoofTopView,lgb.world.view.BaseWorldView);



/**
 * Event handler called by the base class when the scene is loaded
 * @private
 */
lgb.world.view.RoofTopView.prototype.onSceneLoaded_ = function(result) {

   this.masterGroup_.viewpoint = "RoofTopScene";
   var dim = this.masterGroup_.getDimensions();
    
   this.dispatchSelectableLoaded_();
   this.dispatchViewpointNodes_();
   this.dispatchVisibilityNodes_();
};




lgb.world.view.RoofTopView.prototype.dispatchSelectableLoaded_ = function() {
  
  this.selectableMap_ = {
    "Damper - Center" : true,
    "Damper - Left": true,
    "Damper - Top": true,
    "Fan - Right": true,
    "Fan - Left": true,
    "Ducting": false,
    "Cooling Coil": true,
    "Heating Coil": true,
    "Filter": true,
    "Boiler": true,
    "Chiller": true,
    "Cooler": true,
    "Pipeing Connectors": false
  };
  
  var airHandlerCenterList = this.masterGroup_.children[1].children;
  var otherList = this.masterGroup_.children[4].children;
  
  this.selectableList_ = [];
  
  this.each(airHandlerCenterList, this.addSelectable);
  this.each(otherList, this.addSelectable);
  
  if (this.selectableList_.length > 0) {
     this.triggerLocal(e.SelectableLoaded, this.selectableList_);
  }
  
};


lgb.world.view.RoofTopView.prototype.addSelectable = function(mesh) {
    if (true == this.selectableMap_[mesh.name]) {
      this.selectableList_.push(mesh);
    }
};


lgb.world.view.RoofTopView.prototype.dispatchVisibilityNodes_ = function() {
  var node = new lgb.world.model.vo.VisibilityNode(this._TITLE, this.masterGroup_, 2 );
  this.triggerLocal(e.VisibilityNodesLoaded, node);
};


lgb.world.view.RoofTopView.prototype.dispatchViewpointNodes_ = function() {
  var node = new lgb.world.model.vo.ViewpointNode.makeFromObject3D( this.masterGroup_, 2 );
  this.triggerLocal(e.ViewpointNodesLoaded, node);
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.RoofTopController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.model.RoofTopModel');
goog.require('lgb.world.view.RoofTopView');


/**
 * MVC controller for the RoofTopController
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.RoofTopController = function() {

  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.world.controller.RoofTopController, lgb.core.BaseController);

/**
 * @private
 */
lgb.world.controller.RoofTopController.prototype.init = function() {

  this.dataModel = new lgb.world.model.RoofTopModel();
  this.view = new lgb.world.view.RoofTopView(this.dataModel);

  this.view.init();
  this.bind_();
};



lgb.world.controller.RoofTopController.prototype.bind_ = function() {

  this.relay(this.view, 
      [
        e.VisibilityNodesLoaded,
        e.ViewpointNodesLoaded,
        e.SelectableLoaded
      ]
    );

  this.relayLocal(this.view, e.AddToWorldRequest);
  
};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.ParticleSystemModel');


goog.require('lgb.world.model.BaseModel');
goog.require('lgb.utils.XmlWrapper');


/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 * @param {Object} systemConfig The particle system config
 * generated by parsing the XML.
 */
lgb.world.model.ParticleSystemModel = function(systemConfig, idx) {


  this.idx = idx;

  /**@type {string} */
  this.title = systemConfig.title;

  lgb.world.model.BaseModel.call(this);

  this.isRunning = false;
  this.isStarted = false;
  this.showBoxes = false;
  this.showCurves = false;
  this.isEmitting = true;
  this.particleCount = systemConfig.particleCount;
  this.particleSize = systemConfig.particleSize;
  this.meshes = systemConfig.meshes;
  this.rotate = systemConfig.rotate;
  this.translate = systemConfig.translate;
  this.id = systemConfig.id;
  this.launchDelayBetweenParticles = systemConfig.launchDelayBetweenParticles;
  this.lifeSpanInSeconds = systemConfig.lifeSpanInSeconds;
};
goog.inherits(lgb.world.model.ParticleSystemModel, lgb.world.model.BaseModel);





lgb.world.model.ParticleSystemModel.prototype.changeProperty_isStarted = function( newValue) {
  
    this.isStarted = newValue;
    
    if (this.isStarted) {
      if (!this.isRunning) {
        this.isRunning = true;
      }
      if (!this.isEmitting) {
        this.isEmitting = true;
      }
    } else {
      if (this.isEmitting) {
        this.isEmitting = false;
      }
    }
    
   
   this.dispatchChangedEx('isRunning', this.isRunning);
    
};


lgb.world.model.ParticleSystemModel.prototype.changePropertyEx = function(name, newValue) {

    if (this[name] != newValue) {
      if (name == 'isStarted') {
        this.changeProperty_isStarted(newValue);
      } else {
        
        goog.base(this, 'changePropertyEx', name, newValue);

      }
    }
};



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.ParticleSystemMasterView');

goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.BuildingHeightModel');

/**
 * @constructor
 * @extends {BaseView3dScene}
 * @param {lgb.world.model.LightingModel} dataModel The model to display.
 */
lgb.world.view.ParticleSystemMasterView = function(dataModel) {
    
 lgb.world.view.BaseWorldView.call(this, dataModel);
  
};
goog.inherits(lgb.world.view.ParticleSystemMasterView,lgb.world.view.BaseWorldView);



lgb.world.view.ParticleSystemMasterView.prototype.init = function() {

  this.requestAddToWorld(this.masterGroup_);
};



lgb.world.view.ParticleSystemMasterView.prototype.addChild = function(child) {
   
   this.masterGroup_.add(child);

};
    



/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.model.ParticleSystemMasterModel');

goog.require('goog.array');
goog.require('lgb.core.Config');

goog.require('lgb.world.model.BaseModel');
goog.require('lgb.world.model.ParticleSystemModel');
goog.require('lgb.utils.XmlWrapper');

/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.ParticleSystemMasterModel = function() {

  /**@const */
  this._TITLE = 'Mutiple Particle System';

  lgb.world.model.BaseModel.call(this);
  this.init_();

};
goog.inherits(lgb.world.model.ParticleSystemMasterModel, lgb.world.model.BaseModel);




/**
 * @private
 */
lgb.world.model.ParticleSystemMasterModel.prototype.init_ = function() {

  this.xml = null;
  this.xpathResult = null;
  this.currentNode = null;

  this.isSceneLoaded = false;
  this.isXMLloaded = false;
  this.configs = {};
  this.systems = {};
  this.psModelList = [];

};



lgb.world.model.ParticleSystemMasterModel.prototype.getPsModelList = function() {

  return this.psModelList;
};


lgb.world.model.ParticleSystemMasterModel.prototype.changePropertyEx = function(property, newValue) {
  
    var psModel = this.psModelList[property.idx];
    psModel.changePropertyEx(property.name, newValue);
       
};




/**
 * The Particle system data is located in remotes files.
 * this triggers the process of downloading and parsing those files.
 */
lgb.world.model.ParticleSystemMasterModel.prototype.load = function() {

  /**@type {THREE.SceneLoaderEx} */
  this.loader_ = new THREE.SceneLoaderEx();
  this.loader_.load(lgb.core.Config.PARTICLE_SYSTEM_SCENE, this.d(this.onSceneLoadedSync_));

  this.loadXML_();
};

/**
 * Event hander called then the LS file is loaded.
 * @param {Object} result Contains the scene.
 * @private
 */
lgb.world.model.ParticleSystemMasterModel.prototype.onSceneLoadedSync_ = function(result) {

  this.scene_ = result['scene'];
  this.groups_ = result['groups'];
  this.cameras_ = result['cameras'];

  this.objects_ = result.objects;
  this.meshes_ = {};
  this.object3ds_ = {};
  
  
  this.objectTypeMap_ = {
    Mesh : this.meshes_,
    Object3D : this.object3ds_
  };
  
  
  //this.eachPropertyName(this.objects_, this.processOneObject_);
  
   var scene_rotation = new THREE.Euler(this.scene_.rotation.x, this.scene_.rotation.y, this.scene_.rotation.z);
  
  var i = this.scene_.children.length;
  while (i--) {
    var mesh = this.scene_.children.shift();
    if (null != mesh.geometry) {
      
        mesh.bakeTransformsIntoGeometry();
       mesh.position.add(this.scene_.position);
        
       mesh.rotation.fromArray(
         [this.scene_.rotation.x,
         this.scene_.rotation.y,
         this.scene_.rotation.z 
         ]
       );
       
        mesh.scale = this.scene_.scale;
        mesh.bakeTransformsIntoGeometry();
        
        this.processOneObject_(mesh, mesh.name);
    }
  }

  for (var groupName in this.groups_) {
    goog.array.sortObjectsByKey(this.groups_[groupName], 'name');
  }

  this.isSceneLoaded = true;
  this.checkForInitComplete_();

};



lgb.world.model.ParticleSystemMasterModel.prototype.processOneObject_ = function(object, name) {
  

  var fullClassName = object.getFullClassName();
  var ary = fullClassName.split('.');

  var len = ary.length;
  var className = ary[len - 1];

  if ('' == object.name) {
    object.name = name;
  }

  this.objectTypeMap_[className][name] = object;


  if (undefined !== object.groups){
    
    for (var i = 0; i < object.groups.length; i++) {
      var groupID = object.groups[i];
  
      if (this.groups_[groupID] === undefined) {
        this.groups_[groupID] = [];
      }
      
      this.groups_[groupID].push(object);
    }

  }

  
};





/**
 * used to determine if both the XML file and the JS file are
 * loaded.
 * @private
 */
lgb.world.model.ParticleSystemMasterModel.prototype.checkForInitComplete_ = function() {

  if (this.isXMLloaded && this.isSceneLoaded) {

    this.startFactory_();
    this.triggerLocal(e.DataModelInitialized);

  }

};



/**
 * affter all needed data files are loaded, creates the data models.
 * @private
 */
lgb.world.model.ParticleSystemMasterModel.prototype.startFactory_ = function() {

  var items = [];

  for (var key in this.systems) {

    var sys = this.systems[key];
    var l = sys.meshGroupNames.length;

    sys.meshes = [];
    for (var i = 0; i < l; i++) {
      var groupName = sys.meshGroupNames[i];
      sys.meshes = sys.meshes.concat(sys.meshes, this.groups_[groupName]);
    }

    sys.translate = this.translate;
    sys.rotate = this.rotate;

    var psModel = new lgb.world.model.ParticleSystemModel(sys, this.psModelList.length);
    this.psModelList.push(psModel);

    
  }

};



/**
 * uses AJAX to download the remote XML files.
 * @private
 */
lgb.world.model.ParticleSystemMasterModel.prototype.loadXML_ = function() {

  jQuery.ajax({
    type : 'GET',
    url : lgb.core.Config.PARTICLE_SYSTEM_XML,
    dataType : 'xml',
    success : this.d(this.parse_)
  });

};



/**
 * after the XML files is loaded it must be parsed.
 * @param {Document} xml The downloaded XML doc.
 * @private
 */
lgb.world.model.ParticleSystemMasterModel.prototype.parse_ = function(xml) {

  var parser = new lgb.utils.XmlWrapper(xml);

  parser.makeRootNode('/particleSystems/@translate');
  this.translate = parser.getFloatArray();

  parser.makeRootNode('/particleSystems/@rotate');
  this.rotate = parser.getFloatArray();

  parser.makeRootNode('/particleSystems/system');
  while (parser.currentNode) {

    var theID = parser.getId();

    var sys = {
      id : theID,
      particleCount : parser.getContentAsFloat('particleCount'),
      particleSize : parser.getContentAsFloat('particleSize'),
      meshGroupNames : parser.getTextArray('meshGroupNames'),
      title : parser.getContent('title'),
      launchDelayBetweenParticles : parser.getContent('launchDelayBetweenParticles'),
      lifeSpanInSeconds : parser.getContentAsFloat('lifeSpanInSeconds')
    };

    this.systems[theID] = sys;
    parser.next();
  }

  this.isXMLloaded = true;
  this.checkForInitComplete_();

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.ParticlePath');

goog.require('lgb.world.view.BaseV');


/**
 * MVC View
 * @constructor
 * @extends lgb.world.view.BaseV
 * @param {THREE.SplineCurve3} curve The path for a particle to travel.
 * @param {number} frameCount The number of animation frames.
 */
lgb.world.view.ParticlePath = function(curve, frameCount) {
    

  lgb.world.view.BaseV.call(this);

  this.curve = curve;

  this.frameToPositionMap = [];
  this.vertices = [];
  this.currentFrameNumber = 0;
  this.visibleLine = null;
  this.frameCount = frameCount;
  this.calculateAnimationFrames();

};
goog.inherits(lgb.world.view.ParticlePath, lgb.world.view.BaseV);

/**
 * chop the path up into a series of pionts.
 */
lgb.world.view.ParticlePath.prototype.calculateAnimationFrames = function() {
  var i = this.frameCount;
  //quantize the curve based on the number of frames
  //in the entire animation
  while (i--) {
    var percentageComplete = (i) / this.frameCount;
    var pointAlongcurve = this.curve.getPointAt(percentageComplete);
    this.frameToPositionMap[i] = pointAlongcurve;
  }
};


/**
 * turn the path into a 3D line.
 * @return {THREE.Line} The 3D line.
 */
lgb.world.view.ParticlePath.prototype.makeVisibleLine = function() {
  var lineBasicMaterial = new THREE.LineBasicMaterial(
    { color: 0xff0000, opacity: 1, linewidth: 3 }
  );

  var vertices = [];
  var i = this.frameToPositionMap.length;

  while (i--) {
     var vector3 = this.frameToPositionMap[i];
   //  var vertex = new THREE.Vertex(vector3);
     vertices.push(vector3);
  }

  var geometry = new THREE.Geometry();
  geometry.vertices = vertices;

  this.visibleLine = new THREE.Line(geometry, lineBasicMaterial);

  return this.visibleLine;

};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.ParticleElement');

goog.require('lgb.world.view.BaseV');




/**
 * @constructor
 * @extends {lgb.world.view.BaseV}
 * @param {THREE.ParticleSystemMaterial} pMaterial the material to use.
 */
lgb.world.view.ParticleElement = function(pMaterial) {
    

  lgb.world.view.BaseV.call(this);

  this.pMaterial = pMaterial;
  this.threeParticle = new THREE.Particle(pMaterial);

  this.currentFrameNumber = 0;
  this.isFinished = false;

};
goog.inherits(lgb.world.view.ParticleElement, lgb.world.view.BaseV);


/**
 * I made an accessor.
 * @param {lgb.world.view.ParticlePath} path This particle should follwo this path.
 */
lgb.world.view.ParticleElement.prototype.assignPath = function(path) {
  this.path = path;
};


/**
 * I made an accessor for this property.  There
 * is probably a better way to do this.
 * @param {string} id The ID or idx of htis particle.
 */
lgb.world.view.ParticleElement.prototype.assignId = function(id) {
  this.id = id;
};


/**
 * The Particle Element has finished its trip along the path,
 * now it is rest.
 */
lgb.world.view.ParticleElement.prototype.reset = function() {
  this.currentFrameNumber = 0;
  this.isFinished = false;
  this.setVisible(true);
};


/**
 * acessor.
 * @param {boolean} makeVisible If true then show.
 */
lgb.world.view.ParticleElement.prototype.setVisible = function(makeVisible) {
  if (makeVisible) {
    //this.threeParticle.materials.opacity = 1;
  } else {
    this.threeParticle.position.set(1000, 1000, 0);
  }
};


/**
 * called by the controller I think.
 */
lgb.world.view.ParticleElement.prototype.render = function() {


  if (this.isFinished) {
    throw ('should not render particle that is finished');
  }

  //get the postion
  var vector3 = this.path.frameToPositionMap[this.currentFrameNumber];

  //set the position
  this.threeParticle.position.copy(vector3);

  
  this.currentFrameNumber++;

  if (this.currentFrameNumber > this.path.frameToPositionMap.length - 1) {
    this.isFinished = true;
    this.setVisible(false);
  }

};















/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.world.view.ParticleSystemView');

goog.require('lgb.world.view.ParticleElement');
goog.require('lgb.world.view.ParticlePath');
goog.require('lgb.world.view.BaseWorldView');
goog.require('lgb.world.model.BuildingHeightModel');

/**
 * @constructor
 * @extends {lgb.world.view.BaseWorldView}
 * @param {lgb.world.model.ParticleSystemModel} dataModel The data model to display.
 */
lgb.world.view.ParticleSystemView = function(dataModel) {

  lgb.world.view.BaseWorldView.call(this, dataModel);

  this.title = dataModel.title;

  this.topFloorMaxY_ = null;
  this.sceneY_ = null;
  this.listenForChange_('isRunning');
  this.listenForChange_('showBoxes');
  this.listenForChange_('showCurves');

    
};
goog.inherits(lgb.world.view.ParticleSystemView, lgb.world.view.BaseWorldView);


lgb.world.view.ParticleSystemView.prototype.onChange_isRunning_ = function(isRunning) {
    this.updateIsRunning_();
};

lgb.world.view.ParticleSystemView.prototype.onChange_showBoxes_ = function(showBoxes) {
    this.showBoxes(showBoxes);
};

lgb.world.view.ParticleSystemView.prototype.onChange_showCurves_ = function(showCurves) {
    this.showCurves(showCurves);
};




/**
 * Updates the running state from the dataModel.
 * @private
 */
lgb.world.view.ParticleSystemView.prototype.updateIsRunning_ = function() {

  if (this.dataModel.isRunning) {
    this.renderListenerKey_ = this.listen(e.RenderNotify, this.onRender);
  } else {
    if (this.renderListenerKey_) {
      this.unlisten(this.renderListenerKey_);
    }
  }
};

/**
 * Initializes the View.
 */
lgb.world.view.ParticleSystemView.prototype.init = function() {

  /**@type THREE.Object3D */
  this.visibleLineGroup = null;

  /**@type THREE.Object3D */
  this.masterGroup_ = new THREE.Object3D();
  this.masterGroup_.name = 'PsView-masterGroup-' + this.dataModel.title;

  this.parseConfig();

  this.positionVector = new THREE.Vector3(this.dataModel.translate[0], this.dataModel.translate[1], this.dataModel.translate[2]);

  var degreesX = this.dataModel.rotate[0] * Math.PI / 180;
  var degreesY = this.dataModel.rotate[1] * Math.PI / 180;
  var degreesZ = this.dataModel.rotate[2] * Math.PI / 180;

  this.rotationEuler = new THREE.Euler(degreesX, degreesY, degreesZ);

  this.masterGroup_.position = this.positionVector;
  this.masterGroup_.rotation = this.rotationEuler;

  this.generateParticlePaths();
  this.createSystem();

  this.showBoxes(this.dataModel.showBoxes);
  this.showCurves(this.dataModel.showCurves);

  this.updateIsRunning_();
  this.currentFrameNumber = this.launchDelayBetweenParticles + 1;
  this.requestAddToWorld(this.masterGroup_);

};

/**
 * parse the particle system config.
 */
lgb.world.view.ParticleSystemView.prototype.parseConfig = function() {
  this.translate = this.dataModel.translate;
  this.rotate = this.dataModel.rotate;
  this.particlePaths = [];
  this.particleCount = 200;
  this.particlePathCount = 6;
  this.fps = 30;
  this.frameCount = this.dataModel.lifeSpanInSeconds * this.fps;
  this.tension = 0;
  this.currentFrameNumber = 0;
  this.visibleParticleCount = 0;
  this.totalFrames = 0;
  this.launchDelayBetweenParticles = this.dataModel.launchDelayBetweenParticles;

};

/**
 * create the particle system.
 */
lgb.world.view.ParticleSystemView.prototype.createSystem = function() {

  var cicle = THREE.ImageUtils.loadTexture('3d-assets/textures/circle.png');

  this.pMaterial = new THREE.ParticleSystemMaterial({
    color : 0x0000ff,
    size : 0.75,
    map : cicle,
    blending : THREE.AdditiveBlending,
    transparent : true
  });

  this.particlesGeometry = new THREE.Geometry();
  this.particlesGeometry.dynamic = true;
  this.particleElements = [];

  var i = this.particleCount;
  var particlesNeeded = 0;

  this.inActiveParticles = [];

  while (i--) {
    var particleElement = new lgb.world.view.ParticleElement(this.pMaterial);
    particleElement.setVisible(false);

    this.particleElements[i] = particleElement;
    this.inActiveParticles[i] = particleElement;

    // add it to the geometry
    vec = new THREE.Vector3(particleElement.threeParticle);
    this.particlesGeometry.vertices[i] = particleElement.threeParticle.position;

    var idx = i % this.particlePathCount;
    particleElement.assignPath(this.particlePaths[idx]);
    particleElement.assignId(i);
  }

  this.activeParticles = [];
  this.threePS = new THREE.ParticleSystem(this.particlesGeometry, this.pMaterial);
  this.threePS.name = 'PsView-ParticleSystem-' + this.dataModel.title;

  this.threePS.sortParticles = true;
  this.threePS.dynamic = true;
  this.masterGroup_.add(this.threePS);
};

/**
 * creates the THREE.js lines.
 * @private
 */
lgb.world.view.ParticleSystemView.prototype.makeVisibleLines_ = function() {

  this.visibleLineGroup = new THREE.Object3D();
  this.visibleLineGroup.name = 'PsView-visibleLineGroup-' + this.dataModel.title;

  var j = this.particlePaths.length;
  while (j--) {
    var onePath = this.particlePaths[j];
    var line = onePath.makeVisibleLine();
    this.visibleLineGroup.add(line);
  }
};

/**
 * converts the curves to paths.
 */
lgb.world.view.ParticleSystemView.prototype.generateParticlePaths = function() {

  var j = this.particlePathCount;
  while (j--) {

    var curve = this.newCurve();
    var pp = new lgb.world.view.ParticlePath(curve, this.frameCount);

    this.totalFrames += pp.frameToPositionMap.length;
    this.particlePaths.push(pp);
  }
};

/**
 * Generate a new curve running through the system's bounding boxes.
 *
 * @param {number} tension tension parameter for the curve.
 * @return {THREE.SplineCurve3} The randomly generated Curve object.
 */
lgb.world.view.ParticleSystemView.prototype.newCurve = function() {

  var vec3AlongCurve = [];

  var num = this.dataModel.meshes.length;

  for (var i = 0; i < num; i++) {
    var boxMesh = this.dataModel.meshes[i];
    lgb.assert(boxMesh);
    
    var vex3 = THREE.GeometryUtils.randomPointsInGeometry( boxMesh.geometry, 1 )[0];
    vec3AlongCurve.push(vex3);
  }

  var splineCurve3 = new THREE.SplineCurve3(vec3AlongCurve);

  return splineCurve3;
};

/**
 * @param {boolean} isVisible whether to show the curves or hide them.
 */
lgb.world.view.ParticleSystemView.prototype.showCurves = function(isVisible) {

  if (isVisible) {
    if (this.visibleLineGroup == null) {
      this.makeVisibleLines_();
    }
    this.masterGroup_.add(this.visibleLineGroup);

  } else {

    if (undefined !== this.visibleLineGroup && this.visibleLineGroup !== null) {
      this.masterGroup_.remove(this.visibleLineGroup);
    }

  }
};

/**
 * @param {boolean} isVisible whether to show the boxes or hide them.
 */
lgb.world.view.ParticleSystemView.prototype.showBoxes = function(isVisible) {

  if (isVisible) {

    this.boxGroup_ = new THREE.Object3D();
    this.boxGroup_.name = this.title + '-BoxGroup';

    var len = this.dataModel.meshes.length;

    for (var i = 0; i < len; i++) {
      var boxMesh = this.dataModel.meshes[i];
      this.boxGroup_.add(boxMesh);
    }

    this.masterGroup_.add(this.boxGroup_);

  } else {
    this.masterGroup_.remove(this.boxGroup_);
  }
};

lgb.world.view.ParticleSystemView.prototype.setBuildingHeight = function(buildingHeightModel) {

  this.topFloorMaxY_ = buildingHeightModel.topFloorMaxY;
  this.setY_();
};

lgb.world.view.ParticleSystemView.prototype.setY_ = function() {

  if (null != this.topFloorMaxY_ && null != this.sceneY_) {
    this.masterGroup_.position.y = this.topFloorMaxY_ + this.sceneY_;
  }

};

/**
 * event Handler
 * @param {e.RenderNotify} event The event.
 */
lgb.world.view.ParticleSystemView.prototype.onRender = function(event) {
  //first remove any particles at the end

  //if none are at the end, create a new particle
  this.currentFrameNumber++;
  if (this.currentFrameNumber > this.launchDelayBetweenParticles) {
    this.currentFrameNumber = 0;

    if (this.inActiveParticles.length > 0 && this.dataModel.isEmitting) {
      var p = this.inActiveParticles.pop();
      p.reset();
      this.activeParticles.push(p);
    }
    
  }

  var i = this.activeParticles.length;
  var popIdxList = [];
  while (i--) {
    var p = this.activeParticles[i];

    if (p == null || p.render == null) {
      throw ('error rendering particle element');
    }

    p.render();

    if (p.isFinished) {
      popIdxList.push(i);
    }
  }

  if (popIdxList.length > 0) {
    var finishedParticle = this.activeParticles.splice(popIdxList[0], 1)[0];
    this.inActiveParticles.push(finishedParticle);
  }

  if (!this.dataModel.isEmitting) {
    if (this.activeParticles.length < 1) {
      if (this.dataModel.isRunning) {
        this.requestDataModelChange('isRunning', false);
      }
    }
  }

  this.threePS.geometry.verticesNeedUpdate = true;
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.PsController');

goog.require('lgb.core.BaseController');



goog.require('lgb.world.model.ParticleSystemModel');
goog.require('lgb.world.view.ParticleSystemView');



/**
 * @constructor
 * @extends lgb.core.BaseController
 * @param {lgb.world.model.ParticleSystemModel} dataModel The model.
 */
lgb.world.controller.PsController = function(dataModel) {
  lgb.core.BaseController.call(this);

  this.dataModel = dataModel;

};
goog.inherits(lgb.world.controller.PsController, lgb.core.BaseController);


/**
 * @private
 */
lgb.world.controller.PsController.prototype.init = function() {

  this.view = new lgb.world.view.ParticleSystemView( this.dataModel );
  this.bind_();
  this.view.init();

};


/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.PsController.prototype.bind_ = function() {

  this.listenTo(
    this.view,
    e.RequestDataModelChange,
    this.onRequestDataModelChange_
   );
    
    
    
   this.relayLocal(this.view, e.AddToWorldRequest); 
    
};




lgb.world.controller.PsController.prototype.onRequestDataModelChange_ =
  function(event) {

  this.dataModel.changePropertyEx(event.payload.property, event.payload.newValue);
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 	 
 	 /**
 * @author Raj Dye - raj@rajdye.com
*/

goog.provide('lgb.component.Tree');
goog.require('lgb.world.view.BaseV');


/**
 * Html component that contains a cusmtom Tree
 * @param {string} parentHtmlID The CSS id of the parent.
 * @param {string} subID The second  part fo the CSS id.
 * @param {string} title Ysed for the label of the component.
 * @constructor
 * @extends {lgb.BaseV}
 */
lgb.component.Tree = function(ds) {
    
  lgb.world.view.BaseV.call(this);
  
  lgb.assert (ds);
  this.ds = ds;
  
  this.nodeStatusList_ = [];
};
goog.inherits(lgb.component.Tree, lgb.world.view.BaseV);






lgb.component.Tree.prototype.makeElement = function() {

  this.mainDiv_= $('<div>');
  
  this.kendoTreeView_ = this.mainDiv_.kendoTreeView(
    {
    expanded : true,
    loadOnDemand : false,
    checkboxes : {
      checkChildren : true
    },
    dataSource : this.ds.kendoDS

  }).data("kendoTreeView");
  
  
  return this.mainDiv_;
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

/**
 * @author Raj Dye - raj@rajdye.com
 */

goog.provide('lgb.component.TreeDataSource');

goog.require('lgb.component.BaseDataSource');




lgb.component.TreeDataSource = function(objectList, propertyName, title, parentHtmlID, subID) {

  
  this.title_ = title;
  this.propertyName_ = propertyName;
  
  lgb.component.BaseDataSource.call(this);

  this.parentHtmlID = parentHtmlID;
  this.htmlID = parentHtmlID + '-' + subID;
  this.changedItems_ = [];
  
  if(objectList) {
    this.build_(objectList);
  }

};
goog.inherits(lgb.component.TreeDataSource, lgb.component.BaseDataSource);



lgb.component.TreeDataSource.prototype.build_ = function(objectList) {

  var items = [];
  
  objectList.forEach( function(val, idx) {
    
    items.push(
      { text:val.title,
        checked:val[this.propertyName_ ],
        idx:val.idx,
        hasChildren : false
       }
    );
    
  });
  
  var rootNodeAry = [{
    text : this.title_,
    items : items,
    checked : false,
    hasChildren : true,
    id : 0,
    idx:-1
  }];

  var options = {
    data : rootNodeAry
  };

  this.kendoDS = new kendo.data.HierarchicalDataSource(options);
  this.kendoDS.read();

  this.rootNode  = this.kendoDS.get(0);
  this.rootNode .load();

  this.bind_();
};


  
lgb.component.TreeDataSource.prototype.bind_ = function() {

  this.kendoDS.bind("change", this.d(this.onChangeDS_));

};

lgb.component.TreeDataSource.prototype.getChangedItems = function() {

  return this.changedItems_;
  
};


lgb.component.TreeDataSource.prototype.onChangeDS_ = function(event) {

  if (event.field == "checked") {

    this.changedItems_ = [];
    this.view_ = this.kendoDS.view();
    
    event.items.forEach(this.d(this.processOneItem));
    
    if (this.changedItems_.length > 0) {
      
      this.changedItems_.propertyName = this.propertyName_;
      this.dispatchChangedEx('changedItems', this.changedItems_);
    }

  }

};

lgb.component.TreeDataSource.prototype.processOneItem = function(node, idx, that) {


  if (node.idx > -1) {
    
    var statusItem = {
      idx : node.idx,
      isChecked : node.checked,
      text : node.text
    };
  
    this.changedItems_.push(statusItem);
    
  }

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.gui.view.ParticleSystemMasterGUI');

goog.require('lgb.gui.view.BaseGUI');
goog.require('lgb.world.model.BuildingHeightModel');
goog.require('lgb.world.model.ParticleSystemMasterModel');

goog.require('lgb.component.Tree');
goog.require('lgb.component.TreeDataSource');

goog.require('lgb.component.TreeH');
goog.require('lgb.component.TreeDataSourceH');

goog.require('lgb.core.Config');


/**
 * @constructor
 * @extends {lgb.gui.view.BaseGUI}
 * @param {lgb.world.model.LightingModel} dataModel The model to display.
 */
lgb.gui.view.ParticleSystemMasterGUI = function(dataModel) {

  this._TITLE = 'Airflow';
  lgb.gui.view.BaseGUI.call(this, dataModel, 'PsMasterGUI');
};
goog.inherits(lgb.gui.view.ParticleSystemMasterGUI, lgb.gui.view.BaseGUI);

/**
 * Initializes the View
 */
lgb.gui.view.ParticleSystemMasterGUI.prototype.init = function() {
  
  
    var list = this.dataModel.getPsModelList();
    
  //  this.treeActiveDS = new lgb.component.TreeDataSourceH(list,'isStarted',
     // 'Active Systems',  this.htmlID, 'active-systems');
      
    this.treeActiveDS = new lgb.component.TreeDataSource(list,'isStarted',
      'Active Systems',  this.htmlID, 'active-systems');
      
    this.treeBoxesDS = new lgb.component.TreeDataSource(list,'showBoxes',
      'Show Boxes',  this.htmlID, 'show-boxes');
      
      
    this.treeCurvesDS = new lgb.component.TreeDataSource(list,'showCurves',
      'Show Curves',  this.htmlID, 'show-curves');
      
      
    this.bind_();
    this.injectHtml();
    
    this.triggerLocal(e.RequestAddToTestingInput, this);
  
};


/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.gui.view.ParticleSystemMasterGUI.prototype.bind_ = function() {


    
  this.listenTo(this.treeActiveDS,
    e.DataModelChangedEx,
    this.onDataModelChangedEx_);  
    
  this.listenTo(this.treeBoxesDS,
    e.DataModelChangedEx,
    this.onDataModelChangedEx_);
    
  this.listenTo(this.treeCurvesDS,
    e.DataModelChangedEx,
    this.onDataModelChangedEx_);
    
};


lgb.gui.view.ParticleSystemMasterGUI.prototype.onDataModelChangedEx_ = function(event) {
  
    var propertyName = event.payload.changedItems.propertyName;
    var changedItem = event.payload.changedItems[0];
    
    var property = {
      idx: changedItem.idx,
      name: propertyName
    };
    
    var newValue = changedItem.isChecked;
    
    this.requestDataModelChange(property, newValue);
};



/**
 * injects the html into the DOM
 */
lgb.gui.view.ParticleSystemMasterGUI.prototype.injectHtml = function() {


  this.treeActive = new lgb.component.Tree(this.treeActiveDS);
  var element = this.treeActive.makeElement();
  this.append(element);

  this.treeBoxes = new lgb.component.Tree(this.treeBoxesDS);
  var element = this.treeBoxes.makeElement();
  this.append(element);

  this.treeCurves = new lgb.component.Tree(this.treeCurvesDS);
  var element = this.treeCurves.makeElement();
  this.append(element);

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.PsMasterController');

goog.require('lgb.gui.view.ParticleSystemMasterGUI');
goog.require('lgb.core.BaseController');
goog.require('lgb.world.controller.PsController');
goog.require('lgb.world.model.ParticleSystemModel');
goog.require('lgb.world.model.ParticleSystemMasterModel');
goog.require('lgb.world.view.ParticleSystemView');
goog.require('lgb.world.view.ParticleSystemMasterView');


/**
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.PsMasterController = function() {

  lgb.core.BaseController.call(this);
  this.childControllers_ = [];

};
goog.inherits(lgb.world.controller.PsMasterController, lgb.core.BaseController);


/**
 * Initialized the controller.
 */
lgb.world.controller.PsMasterController.prototype.init = function() {
  
  this.dataModel = new lgb.world.model.ParticleSystemMasterModel();
  
  this.guiView = new lgb.gui.view.ParticleSystemMasterGUI(this.dataModel);
  this.view = new lgb.world.view.ParticleSystemMasterView(this.dataModel);
  
  this.bind_();
  this.dataModel.load();

};


lgb.world.controller.PsMasterController.prototype.bind_ = function() {
  
  this.listenToOnce(
    this.dataModel,
    e.DataModelInitialized,
    this.onDataModelInitialized_
   );
   
  this.listenTo (
    this.guiView,
    e.RequestDataModelChange,
    this.onRequestDataModelChange_
   );
   

  this.relay(
    this.guiView,
    e.RequestAddToTestingInput
    );
    
    
  this.relayLocal(this.view, e.AddToWorldRequest);
};

lgb.world.controller.PsMasterController.prototype.onDataModelInitialized_ =
  function(event) {

  this.init2_();
 
};



lgb.world.controller.PsMasterController.prototype.init2_ = function() {
  
  var list = this.dataModel.getPsModelList();
  this.each( list, this.makeChildController_ );
  this.view.init();
  this.guiView.init();

};




lgb.world.controller.PsMasterController.prototype.makeChildController_ = function(psModel) {
  
  var psController = new lgb.world.controller.PsController(psModel);
  
  this.listenToOnce(
    psController,
    e.AddToWorldRequest,
    this.onChildSystemLoaded_
   );
   
   psController.init();
   this.childControllers_.push(psController);

};




lgb.world.controller.PsMasterController.prototype.onChildSystemLoaded_ =
  function(event) {

  this.view.addChild(event.payload);
  
};





lgb.world.controller.PsMasterController.prototype.onRequestDataModelChange_ =
  function(event) {
  
  this.dataModel.changePropertyEx(event.payload.property, event.payload.newValue);
  
};




/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.BuildingController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.controller.HvacController');
goog.require('lgb.gui.controller.TestLightingController');
goog.require('lgb.world.controller.EnvelopeController');
goog.require('lgb.world.controller.RoofTopController');
goog.require('lgb.world.controller.FurnitureController');
goog.require('lgb.world.controller.CrossSectionController');
goog.require('lgb.world.controller.ZoneController');
goog.require('lgb.world.controller.PsMasterController');
goog.require('lgb.gui.controller.ViewpointController');

goog.require('lgb.world.model.BuildingModel');
goog.require('lgb.world.view.BuildingView');


/**
 * MVC controller for the BuildingController
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.world.controller.BuildingController = function() {
  lgb.core.BaseController.call(this);
  this.init_();
};
goog.inherits(lgb.world.controller.BuildingController, lgb.core.BaseController);


/**
 * initializes the controller
 * @private
 */
lgb.world.controller.BuildingController.prototype.init_ = function() {
    
  this.dataModel = new lgb.world.model.BuildingModel();
  this.view = new lgb.world.view.BuildingView(this.dataModel);
  
  this.bind1_();
  
  this.view.init();
  
  this.zoneController_ = new lgb.world.controller.ZoneController();
  this.roofTopController_ = new lgb.world.controller.RoofTopController();
  this.hvacController_ = new lgb.world.controller.HvacController();
  
  this.lightingController_ = new lgb.gui.controller.TestLightingController();
  this.furnitureController_ = new lgb.world.controller.FurnitureController();
  this.crossSectionController_ = new lgb.world.controller.CrossSectionController();
  
  this.envelopeController_ = new lgb.world.controller.EnvelopeController();
  this.psMasterController_ = new lgb.world.controller.PsMasterController();
  
  this.viewpointController_ = new lgb.gui.controller.ViewpointController();
  this.viewpointController_.setAnchors(this.view.anchors);
  
  this.bind2_();
  
  this.viewpointController_.init();
  this.zoneController_.init();
  this.roofTopController_.init();
  this.hvacController_.init();
  
  this.lightingController_.init();
  this.furnitureController_.init();
  this.crossSectionController_.init();
  this.envelopeController_.init();
  this.psMasterController_.init();

};


/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.BuildingController.prototype.bind1_ = function() {

  this.listen(
    e.BuildingHeightChanged,
    this.onBuildingHeightChanged_);

  this.relay(
    this.view,
    e.AddToWorldRequest);
  
};


lgb.world.controller.BuildingController.prototype.bind2_ = function() {


  this.listenTo(
    this.envelopeController_,
    e.AddToWorldRequest,
    this.onAddToGround_
    );
    
  this.listenTo(
    this.furnitureController_,
    e.AddToWorldRequest,
    this.onAddToFloor_
    );
    
    
  this.listenTo(
    this.zoneController_,
    e.AddToWorldRequest,
    this.onAddToFloor_
    );
    

  this.listenTo(
    this.roofTopController_,
    e.AddToWorldRequest,
    this.onAddToRoof_
    );
    
    
  this.listenTo(
    this.hvacController_,
    e.AddToWorldRequest,
    this.onAddToCeiling_
    );
    
  this.listenTo(
    this.lightingController_,
    e.AddToWorldRequest,
    this.onAddToCeiling_
    );


  this.listenTo(
    this.crossSectionController_,
    e.AddToWorldRequest,
    this.onAddToFloor_
    );
    
    
  this.listenTo(
    this.psMasterController_,
    e.AddToWorldRequest,
    this.onAddToCeiling_
    );
    

  this.listen(
    e.ViewpointNodesLoaded,
    this.onViewpointNodesLoaded_
    );
    
    
};




lgb.world.controller.BuildingController.prototype.onViewpointNodesLoaded_ =
  function(event) {
    
    this.viewpointController_.loadViewpoint(event.payload);

};



lgb.world.controller.BuildingController.prototype.onAddToAnchor_ =
  function(event) {
  
   var node = event.payload;
   
   if (node.anchor && node.anchor == "ceiling") {
      this.view.addToCeiling(node);
   } else {
      this.view.addToFloor(node);
   }

};



lgb.world.controller.BuildingController.prototype.onAddToCeiling_ =
  function(event) {
   this.view.addToCeiling(event.payload);
};



lgb.world.controller.BuildingController.prototype.onAddToFloor_ =
  function(event) {
   this.view.addToFloor(event.payload);
};


lgb.world.controller.BuildingController.prototype.onAddToRoof_ =
  function(event) {
   this.view.addToRoof(event.payload);
};


lgb.world.controller.BuildingController.prototype.onAddToGround_ =
  function(event) {
   this.view.addToGround_(event.payload);
};


lgb.world.controller.BuildingController.prototype.onBuildingHeightChanged_ =
  function(event) {
    
   this.view.setBuildingHeight(event.payload);
   
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.WorldSelectionModel');

goog.require('lgb.world.model.BaseModel');
goog.require('goog.array');
goog.require('lgb');
/**
 * @constructor
 * @extends lgb.world.model.BaseModel
 */
lgb.world.model.WorldSelectionModel = function() {

  lgb.world.model.BaseModel.call(this);
  this.init_();

};
goog.inherits(lgb.world.model.WorldSelectionModel, lgb.world.model.BaseModel);

/**
 * sets default properties.
 * @private
 */
lgb.world.model.WorldSelectionModel.prototype.init_ = function() {
  
  this.meshToSystemNodeIDMap = {
    "Damper - Top": 'MX',
    "Damper - Center": 'MX',
    "Damper - Left": 'MX',
    "Fan - Left": 'FAN',
    "Fan - Right": 'FAN',
    "Cooling Coil": 'CC',
    "Heating Coil": 'HC',
    "Filter" : 'FLT',
    "Boiler" : 'BOI',
    "Chiller" : 'CHL',
    "Cooler" : 'CTW',
    "Diffuser01" : "DIF",
    "Diffuser02" : "DIF",
    "Diffuser03" : "DIF",
    "Diffuser04" : "DIF",
    "Diffuser05" : "DIF",
    "Diffuser06" : "DIF",
    "Diffuser07" : "DIF",
    "Diffuser08" : "DIF",
    "Diffuser09" : "DIF"
  };

  this.systemNodeToMeshRefMap = {};
  this.selectableMeshes = {};
  this.selectableMeshesAry = [];
  
  this.selectedMeshList = [];
  this.deselected = [];
  
  // this.systemNodeSelected = null;
};


/**
 * If there is anything selected return the name of it.
 * @return {string} the name of the slected mesh.
 */
lgb.world.model.WorldSelectionModel.prototype.getOneSelected = function() {
  if (this.selectedMeshList.length < 1) {
    return '';
  } else {
    return this.selectedMeshList[0].name;
  }
};


/**
 * @param {Array.<string>} meshList Contains mesh names.
 */
lgb.world.model.WorldSelectionModel.prototype.selectMeshList = function(meshList) {

  this.deselected = goog.array.clone(this.selectedMeshList);
  this.selectedMeshList = meshList;
  
  this.dispatchChangedEx('selectedMeshList', this.selectedMeshList);
};




/**
 * @param {THREE.MeshCollider} intersect Used for collision detection.
 */
lgb.world.model.WorldSelectionModel.prototype.selectIntersect = function(intersect) {

  //select none

  this.selectedMeshListIntersect=intersect;


  if (intersect != null) {

    if (intersect.object == null) {
      throw ('intersect.object == null');
    }
    
    if (intersect.object.name == null || intersect.object.name == '') {
      throw ('intersect.mesh.name  == null or ""');
    }
    
    
    var systemNodeSelected = this.meshToSystemNodeIDMap[intersect.object.name];
    if (!systemNodeSelected) {
      
     systemNodeSelected = "NONE";
    }
        

  }

  return systemNodeSelected;
};


lgb.world.model.WorldSelectionModel.prototype.addMesh_ = function(mesh) {
  
  this.selectableMeshes[mesh.name] = mesh;
  this.selectableMeshesAry.push(mesh);
  
  var systemNodeID = this.meshToSystemNodeIDMap[mesh.name];
  
  if(systemNodeID) {
   
    if (!this.systemNodeToMeshRefMap.hasOwnProperty(systemNodeID)) {
      this.systemNodeToMeshRefMap[systemNodeID] = [];
    }
    
    this.systemNodeToMeshRefMap[systemNodeID].push(mesh);
    
  } else {
    debugger;
  }
  
};


lgb.world.model.WorldSelectionModel.prototype.addMeshAry = function(meshAry) {
  this.each(meshAry, this.addMesh_);
};


lgb.world.model.WorldSelectionModel.prototype.selectSystemNode = function(systemNodeID) {
  
    var meshList = this.systemNodeToMeshRefMap[systemNodeID];
    
    if (null == meshList) {
      meshList = [];
    }
    
    this.selectMeshList(meshList);

};





/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.view.WorldSelectionView');

goog.require('lgb.world.model.WorldSelectionModel');
goog.require('lgb.world.view.BaseV');


/**
 * @constructor
 * @extends {lgb.world.view.BaseV}
 * @param {lgb.world.model.WorldSelectionModel} dataModel The MVC data Model.
 * @param {Element} containerDiv The DOM element.
 * @param {THREE.Camera} camera The camera needed to identify collisions.
 */
lgb.world.view.WorldSelectionView = function(dataModel, containerDiv, camera, scene) {
    
  lgb.world.view.BaseV.call(this, dataModel, "SelectionView", lgb.core.Config.WEBGL_CONTAINER_DIV_ID);
  
  this.containerDiv_ = containerDiv;
  this.camera_ = camera;
  this.scene_ = scene;

};
goog.inherits(lgb.world.view.WorldSelectionView, lgb.world.view.BaseV);



/**
 * Initializes the View
 */
lgb.world.view.WorldSelectionView.prototype.init = function() {

  this.projector_ = new THREE.Projector();
  this.mouse = { x: 0, y: 0 };
  
  this.containerDiv_.bind('mouseup', this.d(this.onClick_));
   
  this.selectedMaterial = new THREE.MeshLambertMaterial({ color: 0xbb0000 });
  this.savedMaterials = {};

  this.listenForChange_('selectedMeshList');

};



lgb.world.view.WorldSelectionView.prototype.onChange_selectedMeshList_ = function(selectedMeshList) {
  
  this.each(this.dataModel.deselected, this.changeMaterial_, false);
  this.each(selectedMeshList, this.changeMaterial_, true);
};


lgb.world.view.WorldSelectionView.prototype.changeMaterial_ = function(mesh, makeRed) {
  
  if(makeRed) {
      mesh.material = this.selectedMaterial;
  } else {
      mesh.material = new THREE.MeshFaceMaterial();
  }
};


/**
 * @private
 * @param {jQuery.event} event The event fired when a user clicks.
 */
lgb.world.view.WorldSelectionView.prototype.onClick_ = function(event) {
  
  //check for left mouse button
  if (0 == event.button) {
    
    var viewportWidth = this.containerDiv_.width();
    var viewportHeight = this.containerDiv_.height();
    
    var offset = this.containerDiv_.offset();
    var offsetParent = this.containerDiv_.offsetParent();
    
    var clientX = event.clientX - offset.left;
    var clientY = event.clientY - offset.top;
    
    var percentX = clientX / viewportWidth;
    var percentY = clientY / viewportHeight;
    
    this.mouse.x = percentX * 2 - 1;
    this.mouse.y = -percentY * 2 + 1;

    this.renderListenerKey = this.listenOnce(e.RenderNotify, this.onRenderNotify_checkCollision_);
  }
  
};



/**
 * event handler.
 * @param {e.RenderNotify} event Fired by the World Controller.
 */
lgb.world.view.WorldSelectionView.prototype.onRenderNotify_checkCollision_ = function(event) {

  var vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
  this.projector_.unprojectVector(vector, this.camera_);

  var ray = new THREE.Raycaster(this.camera_.position, vector.sub(this.camera_.position).normalize());
  
  
  var intersectList = ray.intersectObjects(this.dataModel.selectableMeshesAry, true);

  if (intersectList.length > 0) {

    var intersect = intersectList[0];
    this.triggerLocal(e.Object3DSelected, intersect);

  }
  
};


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.WorldSelectionController');

goog.require('lgb.core.BaseController');
goog.require('lgb.world.model.WorldSelectionModel');
goog.require('lgb.world.view.WorldSelectionView');


/**
 * @constructor
 * @extends lgb.core.BaseController
 * @param {Element} containerDiv The DIV to use.
 * @param {THREE.Camera} camera We need a reference to this to pass to the view.
 */
lgb.world.controller.WorldSelectionController = function( camera, scene, containerDiv) {

  lgb.core.BaseController.call(this);
  this.camera_ = camera;
  this.scene_ = scene;
  this.containerDiv_ = containerDiv;
  this.init_();

};
goog.inherits(lgb.world.controller.WorldSelectionController,
  lgb.core.BaseController);


/**
 * @private
 */
lgb.world.controller.WorldSelectionController.prototype.init_ = function() {

  this.dataModel = new lgb.world.model.WorldSelectionModel();

  this.view = new lgb.world.view.WorldSelectionView(this.dataModel,
    this.containerDiv_,
    this.camera_,
    this.scene_);

  this.bind_();
  this.view.init();
};


/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.WorldSelectionController.prototype.bind_ = function() {
  
  this.relay(this.view, e.AddToWorldRequest);

  this.listenTo(this.view,
    e.Object3DSelected,
    this.onObject3DSelected_
    );

  this.listen(
    e.SelectableLoaded,
    this.onSelectableLoaded_);
    
  this.listen(
    e.RequestSelectSystemNode,
    this.onRequestSelectSystemNode_);
    
};



lgb.world.controller.WorldSelectionController.prototype.onRequestSelectSystemNode_ =
  function(event) {

  this.dataModel.selectSystemNode(event.payload);

};


lgb.world.controller.WorldSelectionController.prototype.onObject3DSelected_ =
  function(event) {

  var intersect = event.payload;
  var systemNodeID = this.dataModel.selectIntersect(intersect);
  
  this.trigger(e.RequestSelectSystemNode, systemNodeID);
  
};



lgb.world.controller.WorldSelectionController.prototype.onSelectableLoaded_ =
  function(event) {

  this.dataModel.addMeshAry(event.payload);
};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.gui.view.RenderGUI');

goog.require('lgb.gui.view.BaseGUI');


/**
 * @constructor
 * @param {lgb.world.model.VisibilityModel} dataModel The data model to display.
 * @param {string} parentHtmlID the CSS id of the parent to inject into the DOM.
 * @extends {lgb.gui.view.BaseGUI}
 */
lgb.gui.view.RenderGUI = function(dataModel, htmlID) {

  lgb.gui.view.BaseGUI.call(this, dataModel, htmlID);

};
goog.inherits(lgb.gui.view.RenderGUI, lgb.gui.view.BaseGUI);


/**
 * Initializes the View
 */
lgb.gui.view.RenderGUI.prototype.init = function(renderer) {
  
  this.renderer_  = renderer;
  this.containerDiv_ = $('#' + this.htmlID);
  
  //this.setMainElement();
  
  this.containerDiv_.attr('unselectable','on').css('UserSelect','none').css('MozUserSelect','none');
  $('body').attr('unselectable','on').css('UserSelect','none').css('MozUserSelect','none');
  

};



lgb.gui.view.RenderGUI.prototype.calculateSize = function() {
    
    var w = this.containerDiv_.width();
    var h = this.containerDiv_.height();
    this.renderer_.setSize(w,h);
};




lgb.gui.view.RenderGUI.prototype.bind_ = function() {
  


};



lgb.gui.view.RenderGUI.prototype.injectInto = function(parentElement) {
  
  goog.base(this,  'injectInto', parentElement);
  
  this.bind_();
      

};

/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.model.RenderModel');

goog.require('lgb.world.model.BaseModel');




lgb.world.model.RenderModel = function() {



  
};
goog.inherits(lgb.world.model.RenderModel, lgb.world.model.BaseModel);



lgb.world.model.RenderModel.prototype.init_ = function() {
 
  

  return;
};
 


/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.world.controller.RenderController');

goog.require('lgb.world.controller.BuildingController');
goog.require('lgb.world.controller.CameraController');
goog.require('lgb.core.BaseController');
goog.require('lgb.world.controller.TrackBallController');
goog.require('lgb.world.controller.UtilityController');
goog.require('lgb.world.controller.WorldSelectionController');

goog.require('lgb.world.model.RenderModel');
goog.require('lgb.gui.view.RenderGUI');
goog.require('lgb.gui.view.StatsView');
goog.require('lgb');



/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 * @param {Element} containerDiv The DIV to use
 * when we render 3D.
 */
lgb.world.controller.RenderController = function() {
  lgb.core.BaseController.call(this);
};
goog.inherits(lgb.world.controller.RenderController, lgb.core.BaseController);


/**
 * Initializes the RenderController Controller after the document is ready
 */
lgb.world.controller.RenderController.prototype.init = function() {
  
  this.timestamp = 0;
  
  this.dataModel = new lgb.world.model.RenderModel();
  this.view = new lgb.gui.view.RenderGUI(this.dataModel, lgb.core.Config.WEBGL_CONTAINER_DIV_ID);

  this.scene_ = new THREE.Scene();
  this.scene_.name = "mainScene";
  
  this.initRenderer_();
  
  this.view.init(this.renderer_ );
  
  this.bind_();

  this.cameraController_ = new lgb.world.controller.CameraController(
    this.renderer_.domElement
  );

  this.camera_ = this.cameraController_.getCamera();
  this.scene_.add(this.camera_);

  this.initLights_();
  
  this.view.calculateSize();
  this.view.containerDiv_.append(this.renderer_.domElement);
  
};





lgb.world.controller.RenderController.prototype.getCamera = function() {
  
  return  this.camera_;
  
};



/**
 * configures lights and adds them to the scene
 * @private
 */
lgb.world.controller.RenderController.prototype.initLights_ = function() {
  /**
   * light source 1
   * @type {THREE.AmbientLight}
   * @private
   */
  this.lightGroup_ = new THREE.Object3D();
  this.lightGroup_.name = "LightGroup";
  
  this.ambientLight_ = new THREE.AmbientLight(0x111111);
  this.ambientLight_ .name = "AmbientLight";
  this.lightGroup_.add(this.ambientLight_);

  this.light1_ = new THREE.DirectionalLight( 0xffffff, 0.5 , 60);
  this.light1_ .name = "Light1";
  this.light1_.position.set( 0, 70, -45 );
  this.light1_.target.name = "Light1_target";
  this.lightGroup_.add( this.light1_ );
  this.lightGroup_.add( this.light1_.target );
  
  this.light2_ = new THREE.DirectionalLight( 0xffffff, 0.6 , 60);
  this.light2_ .name = "Light2";
  this.light2_.position.set( -45, -70, 0 );
  this.light2_.target.name = "Light2_target";
  this.lightGroup_.add( this.light2_ );
  this.lightGroup_.add( this.light2_.target );
  
  this.light3_ = new THREE.DirectionalLight( 0xffffff, 0.8 , 60);
  this.light3_ .name = "Light3";
  this.light3_.position.set( 45, 0, 45 );
  this.light3_.target.name = "Light3_target";
  this.lightGroup_.add( this.light3_ );
  this.lightGroup_.add( this.light3_.target );
  
  this.scene_.add( this.lightGroup_ );
};


/**
 * initialize the renderer in a browser specific way
 * @private
 */
lgb.world.controller.RenderController.prototype.initRenderer_ = function() {
  /**
   * @type {THREE.WebGLRenderer}
   * @private
   */
  this.renderer_ = new THREE.WebGLRenderer(
    { antialias: false, 
      alpha:1
      }
    );
  
  
  this.renderer_.domElement.id='wbGLrenderer';
  $(this.renderer_.domElement).attr('unselectable','on').css('UserSelect','none').css('MozUserSelect','none');

  this.renderEvent_ = new lgb.core.Event (e.RenderNotify);

  if (window.webkitRequestAnimationFrame) {
    this.renderDelegate = this.d(this.onRenderWebkit_);
    window.webkitRequestAnimationFrame(this.renderDelegate);
  } else if (window.mozRequestAnimationFrame) {
    this.renderDelegate = this.d(this.onRenderMoz_);
    window.mozRequestAnimationFrame(this.renderDelegate);
  } else if (window.oRequestAnimationFrame) {
    this.renderDelegate = this.d(this.onRenderOReq_);
    window.oRequestAnimationFrame(this.renderDelegate);
  } else {
    this.renderDelegate = this.d(this.onRenderMisc_);
    window.requestAnimationFrame(this.renderDelegate);
  }
};





/**
 * Binds specific event types to functions which handle the events.
 * If no event target is specified then the listener is set  on the global
 * event bus.
 * @private
 */
lgb.world.controller.RenderController.prototype.bind_ = function() {
  
  this.listen(e.AddToWorldRequest, this.onAddToWorldRequest_);
  this.listen(e.LayoutChange, this.onLayoutChange_);
  
};


lgb.world.controller.RenderController.prototype.onLayoutChange_ = function(event) {
  this.view.calculateSize();
};


/**
 * Handles an event fired by View classes
 * @private
 * @param {lgb.core.Event} event The event that tells us
 * the Object3D that the event target would like to load.
 */
lgb.world.controller.RenderController.prototype.onAddToWorldRequest_ = function(event) {
  var obj = event.payload;

  if ('' == obj.name) {
    throw ('Please name the THREE.Object3D before ' +
    'you request to add it to the scene.');
  } else {
    lgb.logInfo('adding to scene: ' + obj.name);
  }

  this.scene_.add(obj);
};



/**
 * platform specific render function for unknown browser
 * @private
 * @param {number} timestamp A timestamp.
 */
lgb.world.controller.RenderController.prototype.onRenderOReq_ = function(timestamp) {
  window.oRequestAnimationFrame(mainController.renderController_.onRenderOReq_);
  mainController.renderController_.renderHelper(timestamp);
};


/**
 * platform specific render function for mozilla browser
 * @private
 * @param {number} timestamp A timestamp.
 */
lgb.world.controller.RenderController.prototype.onRenderMoz_ = function(timestamp) {

  window.mozRequestAnimationFrame(mainController.renderController_.onRenderMoz_);
  mainController.renderController_.renderHelper(timestamp);
};


/**
 * platform specific render function for chrome browser
 * @private
 * @param {number} timestamp A timestamp.
 */
lgb.world.controller.RenderController.prototype.onRenderWebkit_ = function(timestamp) {

  window.webkitRequestAnimationFrame(
      mainController.renderController_.onRenderWebkit_
    );

  mainController.renderController_.renderHelper(timestamp);
};


/**
 * platform specific render function for misc browser
 * untested.
 * @private
 * @param {number} timestamp A timestamp.
 */
lgb.world.controller.RenderController.prototype.onRenderMisc_ = function(timestamp) {

  window.requestAnimationFrame(mainController.renderController_.onRenderMisc_);
  mainController.renderController_.renderHelper(timestamp);
};


/**
 * platform independant render function
 * I made this 'public' in an effort to optimize the render loop.
 * @param {number} timestamp A timestamp.
 */
lgb.world.controller.RenderController.prototype.renderHelper = function(timestamp) {
  //TODO (Raj): further optimze the render loop removing the Tween stuff.

  var currentTimeStamp = timestamp;
  var delta = 0;

  if (this.timestamp != 0) {
    delta = currentTimeStamp - this.timestamp;
  }

  this.timestamp = currentTimeStamp;
  createjs.Tween.tick(delta, false);
  

  //THREE.AnimationHandler.update( 1/60 );
  this.renderEvent_.payload = timestamp;

  goog.events.dispatchEvent(lgb.globalEventBus, this.renderEvent_);
  this.renderer_.render(this.scene_, this.camera_);

};
/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */

goog.provide('lgb.core.Global');




/**@typedef {Object} */
lgb.core.Global = {};

  /**
  * replaces markers like {0} with a string
  *
  * @param {string} arg1 The value to insert.
  * @param {string=} arg2 The value to insert.
  * @param {string=} arg3 The value to insert.
  * @param {string=} arg4 The value to insert.
  * @param {string=} arg5 The value to insert.
  * @param {string=} arg6 The value to insert.
  * @return {string} The correctly formatted string.
  */
  String.prototype.format = function(arg1, arg2, arg3, arg4, arg5, arg6) {
    var args = arguments;
    return this.replace(/\{\{|\}\}|\{(\d+)\}/g, function(m, n) {
      if (m == '{{') { return '{'; }
      if (m == '}}') { return '}'; }
      return args[n];
    });
  };



/**
 * Provides requestAnimationFrame in a cross browser way.
 * http://paulirish.com/2011/requestanimationframe-for-smart-animating/
 */
if (!window.requestAnimationFrame) {

  /**
   * the function def.
   */
  window.requestAnimationFrame = (function() {

    return window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    function(
      /* function FrameRequestCallback */ callback,
      /* DOMElement Element */ element) 
    {
      window.setTimeout(callback, 1000 / 60);
    };

  })();

}


function isArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
}/**
 * @author Raj Dye - raj@rajdye.com
 * Copyright (c) 2011 Institute for Sustainable Performance of Buildings (Superb)
 */
 
goog.provide('lgb.core.MainController');

goog.require('lgb');
goog.require('lgb.core.EventBus');
goog.require('lgb.core.Global');
goog.require('lgb.core.Config');
goog.require('lgb.core.BaseController');
goog.require('goog.debug.Logger');

goog.require('lgb.scenario.controller.ScenarioController');
goog.require('lgb.world.controller.RenderController');

goog.require('lgb.gui.controller.LayoutController');
goog.require('lgb.world.controller.BuildingController');
goog.require('lgb.world.controller.UtilityController');
// goog.require('lgb.world.controller.WorldSelectionController');





/**
 * MVC controller for the App
 * @constructor
 * @extends lgb.core.BaseController
 */
lgb.core.MainController = function() {
  
  lgb.core.BaseController.call(this);
  lgb.globalEventBus = new lgb.core.EventBus();

  console.log('lgb.core.MainController');
  
  var delegate = jQuery.proxy(this.init, this);
  jQuery(document).ready(delegate);
};
goog.inherits(lgb.core.MainController, lgb.core.BaseController);



/**
 * Initializes the Main Controller after the document is ready
 */
lgb.core.MainController.prototype.init = function() {

  //console.log('lgb.core.MainController.init');
  
  this.injectErrorWindow_();
  
  
/*
  window.onerror = function(errorMsg, url, lineNumber) {
    var w = $('#errorWindow').data('kendoWindow');
     w.content(errorMsg + '<br />url:' + url + '<br />line:' + lineNumber);
       w.open();
     debugger;
  };*/

  
/*

*/

  this.layoutController_ = new lgb.gui.controller.LayoutController();
  
  var theTitle = lgb.core.Config.getTitle();
   $('title').html(theTitle);
   

  this.scenarioController_ = new lgb.scenario.controller.ScenarioController();
   
  this.renderController_ = new lgb.world.controller.RenderController();
  this.renderController_.init();
  
  
  if (lgb.core.Config.SHOW_STATS) {
   // this.statsView_ = new lgb.gui.view.StatsView(this.view.containerDiv_);
  } else {
    this.statsView_ = null;
  }
  
  this.buildingController_ = new lgb.world.controller.BuildingController();
  this.utilityController_ = new lgb.world.controller.UtilityController();
  
  
  /**@type {lgb.world.controller.WorldSelectionController} */
  // this.selectionController_ =
    // new lgb.world.controller.WorldSelectionController(
      // this.renderController_.getCamera(),
      // this.renderController_.scene_,
      // this.renderController_.view.containerDiv_
  // );
  
  
  /** @type {lgb.world.controller.TrackBallController} */
  this.trackController_ = new lgb.world.controller.TrackBallController(
    this.renderController_.getCamera()
  );
  
  
  $(window).resize(this.d(this.onNativeWindowResize_));
  
   
  this.simulationMainController_ = new lgb.simulation.controller.MainController();
  this.simulationMainController_.init();
  
  this.trigger(e.RequestLoadScenario, "VerySimpleScenario");
    
  this.logger_ = goog.debug.Logger.getLogger('lgb.core.MainController');

  lgb.logInfo(lgb.core.Config.getTitle());
  lgb.logInfo('jQuery version: ' + $('').jquery);



};



/**
 * Handles the browser resize event
 * then dispatches a lgb event
 * @private
 * @param {Event} event The browser's event.
 */
lgb.core.MainController.prototype.onNativeWindowResize_ =
  function(event) {

  var payload = {
    w:window.innerWidth,
    h:window.innerHeight
    };
  
  this.trigger(e.WindowResize, payload);  

};



/**
 * Injects the HTML needed for the modal
 * dialog that apears if an exception occurs
 * @private
 */
lgb.core.MainController.prototype.injectErrorWindow_ = function() {
  var container = $('<p>')
    .attr('id', 'errorWindow')
    .appendTo('body');

   var w = $('#errorWindow').kendoWindow({
       draggable: false,
       resizable: false,
       width: '500px',
       height: '300px',
       title: 'Exception Ocurred',
       modal: true,
       visible: false,
       actions: ['Refresh', 'Maximize', 'Close']
   }).data('kendoWindow');

   w.center();
   
   container.attr('unselectable','on').css('UserSelect','none').css('MozUserSelect','none');
   
};


lgb.core.MainController.start =
  function() {


  if (typeof LGB_WEBROOT != 'undefined') {
     lgb.core.Config.WEBROOT = LGB_WEBROOT;
  }
  
  lgb.init();
  
  window.mainController = new lgb.core.MainController();

};

