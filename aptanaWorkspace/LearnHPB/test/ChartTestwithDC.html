
<!DOCTYPE html>
<html lang="en">
<head>


    <meta charset="UTF-8">

    <link type="text/css" href="../css/bootstrap.min.css" rel="stylesheet" />
    <link type="text/css" href="../css/dc.css" rel="stylesheet" />
    
    <script src="../js/lib/d3.js"></script>
    <script src="../js/lib/crossfilter.js"></script>
    <script src="../js/lib/dc.js"></script>
    <script src="../js/lib/colorbrewer.js"></script>
    
    <script src="../js/lib/jquery.src.js"></script>
    <script src="../js/lib/purl.js"></script>
      
</head>
<body>


  
  <div class="row">
      <div id="monthly-move-chart">
          <div class="clearfix"></div>
      </div>
  </div>
  
  <div class="row">
      <div id="monthly-volume-chart"></div>
  </div>


     
<script>
        
  var moveChart = null;
  var volumeChart = null;
  var margins = {top: 20, right: 0, bottom: 20, left: 70};
  
  //$(window).resize(calculateLayout);
  
  var delegate = jQuery.proxy(init);
  jQuery(document).ready(delegate);
  


  
function calculateLayout() {
  
  
    var url = $.url(); // parse the current page URL
    var width = url.param('width');
    var height = url.param('height');
    
    if (undefined == width) {
      width = window.outerWidth - (margins.left + margins.right) + 70;
      
    } else {
      
      width = parseFloat (width);
    }
    
    
    if (undefined == height) {
      height = window.outerHeight - ((margins.top + margins.bottom) * 2) - 20;
      
    } else {
      
      height = parseFloat (height);
    }
  


   
    var h1 = (height * 0.80);
    var h2 = (height * 0.20);
  
  
    moveChart
        .width(width)
        .height(h1);
        
    volumeChart
        .width(width)
        .height(h2);
        
     dc.renderAll();
     
}
  
function init() {
  
  showChart();

}



function showChart() {
  
    moveChart = dc.lineChart("#monthly-move-chart");
    volumeChart = dc.barChart("#monthly-volume-chart");

    var url = $.url(); // parse the current page URL
    var width = url.param('width');
    var height = url.param('height');
    
    if (undefined == width) {
      width = window.outerWidth - (margins.left + margins.right) + 70;
      
    } else {
      
      width = parseFloat (width);
    }
    
    
    if (undefined == height) {
      height = window.outerHeight - ((margins.top + margins.bottom) * 2) - 20;
      
    } else {
      
      height = parseFloat (height) - ((margins.top + margins.bottom) * 2);
    }
  
  
    
    var h1 = (height * 0.75);
    var h2 = (height * 0.25);
  
   
  d3.csv("ndx.csv", function (data) {
      /* since its a csv file we need to format the data a bit */
      var dateFormat = d3.time.format("%m/%d/%Y");
      var numberFormat = d3.format(".2f");
  
      data.forEach(function (d) {
          d.dd = dateFormat.parse(d.date);
          d.month = d3.time.month(d.dd); // pre-calculate month for better performance
          d.close = +d.close; // coerce to number
          d.open = +d.open;
      });
  
      //### Create Crossfilter Dimensions and Groups
      //See the [crossfilter API](https://github.com/square/crossfilter/wiki/API-Reference) for reference.
      var ndx = crossfilter(data);
      var all = ndx.groupAll();
  
      // dimension by year
      var yearlyDimension = ndx.dimension(function (d) {
          return d3.time.year(d.dd).getFullYear();
      });
      
      
   
  
      // dimension by full date
      var dateDimension = ndx.dimension(function (d) {
          return d.dd;
      });
  
      // dimension by month
      var moveMonths = ndx.dimension(function (d) {
          return d.month;
      });
      // group by total movement within month
      var monthlyMoveGroup = moveMonths.group().reduceSum(function (d) {
          return Math.abs(d.close - d.open);
      });
      // group by total volume within move, and scale down result
      var volumeByMonthGroup = moveMonths.group().reduceSum(function (d) {
          return d.volume / 500000;
      });
      var indexAvgByMonthGroup = moveMonths.group().reduce(
          function (p, v) {
              ++p.days;
              p.total += (v.open + v.close) / 2;
              p.avg = Math.round(p.total / p.days);
              return p;
          },
          function (p, v) {
              --p.days;
              p.total -= (v.open + v.close) / 2;
              p.avg = p.days ? Math.round(p.total / p.days) : 0;
              return p;
          },
          function () {
              return {days: 0, total: 0, avg: 0};
          }
      );
  
  
  
  
      // counts per weekday
      var dayOfWeek = ndx.dimension(function (d) {
          var day = d.dd.getDay();
          var name=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
          return day+"."+name[day];
       });
      var dayOfWeekGroup = dayOfWeek.group();
  
      //### Define Chart Attributes
      //Define chart attributes using fluent methods. See the [dc API Reference](https://github.com/NickQiZhu/dc.js/blob/master/web/docs/api-1.7.0.md) for more information
      //
  
      //#### Stacked Area Chart
      //Specify an area chart, by using a line chart with `.renderArea(true)`
      moveChart
          .renderArea(true)
          .width(width)
          .height(h1)
          .transitionDuration(1000)
          .margins(margins)
          .dimension(moveMonths)
          .mouseZoomable(true)
          // Specify a range chart to link the brush extent of the range with the zoom focue of the current chart.
          .rangeChart(volumeChart)
          .x(d3.time.scale().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))
          .round(d3.time.month.round)
          .xUnits(d3.time.months)
          .elasticY(true)
          .renderHorizontalGridLines(true)
          .legend(dc.legend().x(800).y(10).itemHeight(13).gap(5))
          .brushOn(false)
          // Add the base layer of the stack with group. The second parameter specifies a series name for use in the legend
          // The `.valueAccessor` will be used for the base layer
          .group(indexAvgByMonthGroup, "Monthly Index Average")
          .valueAccessor(function (d) {
              return d.value.avg;
          })
          // stack additional layers with `.stack`. The first paramenter is a new group.
          // The second parameter is the series name. The third is a value accessor.
          .stack(monthlyMoveGroup, "Monthly Index Move", function (d) {
              return d.value;
          })
          // title can be called by any stack layer.
          .title(function (d) {
              var value = d.value.avg ? d.value.avg : d.value;
              if (isNaN(value)) value = 0;
              return dateFormat(d.key) + "\n" + numberFormat(value);
          });
  
      volumeChart.width(width)
          .height(h2)
          .margins(margins)
          .dimension(moveMonths)
          .group(volumeByMonthGroup)
          .centerBar(true)
          .gap(1)
          .x(d3.time.scale().domain([new Date(1985, 0, 1), new Date(2012, 11, 31)]))
          .round(d3.time.month.round)
          .alwaysUseRounding(true)
          .xUnits(d3.time.months);
          
       dc.renderAll();
  
  });

  
}
  


      </script>

</body>
</html>
